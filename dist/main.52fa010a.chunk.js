(this.webpackJsonpapp = this.webpackJsonpapp || []).push([
    [0],
    [
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        function (e, t, i) {},
        function (e, t, i) {},
        function (e, t, i) {},
        function (e, t, i) {
            "use strict";
            i.r(t), (t.default = i.p + "static/media/debug_body.193b9327.obj");
        },
        function (e, t, i) {
            "use strict";
            i.r(t), (t.default = i.p + "static/media/debug_wheel.291c4dc1.obj");
        },
        function (e, t, i) {},
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        function (e, t, i) {},
        function (e, t, i) {
            "use strict";
            i.r(t), (t.default = i.p + "static/media/mono_2.a6225cf4.obj");
        },
        function (e, t, i) {
            "use strict";
            i.r(t), (t.default = i.p + "static/media/mono_wheel.0c7cdca8.obj");
        },
        function (e, t, i) {
            "use strict";
            i.r(t), (t.default = i.p + "static/media/bus-02.07c5f9f2.obj");
        },
        function (e, t, i) {
            "use strict";
            i.r(t), (t.default = i.p + "static/media/bus-wheel.32095e6e.obj");
        },
        function (e, t, i) {
            "use strict";
            i.r(t), (t.default = i.p + "static/media/roadster-07-int.9a99909d.obj");
        },
        function (e, t, i) {
            "use strict";
            i.r(t), (t.default = i.p + "static/media/roadster_wheel_02.bbc40837.obj");
        },
        function (e, t, i) {
            "use strict";
            i.r(t), (t.default = i.p + "static/media/steering_wheel.9e78c67a.obj");
        },
        function (e, t, i) {
            "use strict";
            i.r(t), (t.default = i.p + "static/media/dashboard.fee32a07.obj");
        },
        function (e, t, i) {
            "use strict";
            i.r(t), (t.default = i.p + "static/media/marsrock.055b2928.obj");
        },
        ,
        ,
        ,
        ,
        ,
        function (e, t, i) {},
        ,
        function (e, t, i) {},
        function (e, t, i) {},
        function (e, t, i) {},
        function (e, t, i) {},
        function (e, t, i) {},
        function (e, t, i) {},
        function (e, t, i) {},
        function (e, t, i) {
            "use strict";
            i.r(t);
            var s = i(2),
                n = i.n(s),
                a = i(23),
                o = i.n(a),
                r = (i(33), i(19), i(1)),
                h = i(27);
            class l {
                constructor(e = null, t = null) {
                    if (((this.listeners = []), (this.value = null), (this.storageKey = null), (this.default = null), (this.value = e), (this.default = e), (this.storageKey = t), t && localStorage.getItem(t)))
                        try {
                            this.value = JSON.parse(localStorage.getItem(t));
                        } catch (i) {
                            console.warn("Failed to load saved value for ", t);
                        }
                }
                reset() {
                    this.set(JSON.parse(JSON.stringify(this.default)));
                }
                set(e) {
                    this.value !== e && ((this.value = e), this.onChanged(this.value), this.storageKey && localStorage.setItem(this.storageKey, JSON.stringify(this.value)));
                }
                onChanged(e) {
                    for (let t of this.listeners) t(e);
                }
                addListener(e) {
                    "function" === typeof e && (this.listeners.includes(e) || this.listeners.push(e));
                }
                removeListener(e) {
                    let t = this.listeners.indexOf(e);
                    t >= 0 && this.listeners.splice(t, 1);
                }
            }
            var d = new l(!0);
            var c = { mouseWidgetHeight: 24, mouseWidgetWidth: 640, useMouse: !0 };
            class p {
                constructor(e, t = null) {
                    (this.listeners = { any: [] }), (this.value = {}), (this.default = {}), (this.storageKey = null);
                    for (let n in e) this.default[n] = JSON.parse(JSON.stringify(e[n]));
                    this.storageKey = t;
                    let i = !1;
                    if (t && localStorage.getItem(t))
                        try {
                            let s = JSON.parse(localStorage.getItem(t));
                            if (e) for (let t in e) t in s ? ((this.value[t] = s[t]), (this[t] = s[t])) : ((this.value[t] = e[t]), (this[t] = e[t]));
                            else for (let e in s) (this.value[e] = s[e]), (this[e] = s[e]);
                            i = !0;
                        } catch (s) {
                            console.warn("Failed to load saved value for ", t);
                        }
                    if (!i && e) for (let n in e) (this.value[n] = e[n]), (this[n] = e[n]);
                }
                reset() {
                    this.setMany(this.default);
                }
                setMany(e) {
                    for (let t in e) this.set(t, e[t], !0);
                    for (let t in e) this.onChanged(t, this.value[t]);
                }
                set(e, t, i = !1) {
                    e in this.value && this.value[e] !== t && ((this.value[e] = t), (this[e] = t), i || this.onChanged(e, this.value[e]), this.storageKey && localStorage.setItem(this.storageKey, JSON.stringify(this.value)));
                }
                onChanged(e, t) {
                    for (let i of this.listeners[e] || []) i(t);
                    for (let i of this.listeners.any || []) i(e);
                }
                addListener(e, t) {
                    "function" === typeof t && (e in this.listeners || (this.listeners[e] = []), this.listeners[e].push(t));
                }
                removeListener(e, t) {
                    if (!(e in this.listeners)) return;
                    let i = this.listeners[e].indexOf(t);
                    i >= 0 && this.listeners[e].splice(i, 1);
                }
            }
            var u = { Boolean: 0, Enum: 1, Integer: 2, Float: 3, IntegerRange: 4, FloatRange: 5 };
            const g = new l(
                    {
                        Forward: "0",
                        Backward: "2",
                        Boost: "0",
                        Handbrake: "",
                        ToggleHandbrake: "",
                        Autodrive: "",
                        Reset: "",
                        Headlights: "",
                        StickySteer: "",
                        NextScene: "",
                        PrevScene: "",
                        CameraMode: "",
                        Mute: "",
                        Pause: "",
                        ToggleUI: "",
                        ToggleDebug: "",
                    },
                    "controls_mouse"
                ),
                m = new p({ axisWidth: 0.5, steerSmoothing: 0.5, steerRange: 0.9, linearity: 0.25 }, "controls_mouse_settings"),
                x = {
                    axisWidth: { readable: "Steer bar width", desc: "Sets how much of the screen width is used for steering input", type: u.FloatRange, default: 0.5, min: 0.2, max: 1, precision: 2 },
                    steerSmoothing: { readable: "Steer smoothing", desc: "Applies gentle smoothing to the steering input", type: u.FloatRange, default: 1, min: 0, max: 1, precision: 2 },
                    steerRange: { readable: "Steer range", desc: "Alters the maximum steer angle", type: u.FloatRange, default: 0.9, min: 0.25, max: 1, precision: 2 },
                    linearity: { readable: "Steer linearity", desc: "Less linearity means more precision at small steer angles", type: u.FloatRange, default: 0.25, min: 0, max: 1, precision: 2 },
                },
                v = { F3: !0, F4: !0, Tab: !0 };
            var f = new (class {
                constructor() {
                    (this.key = {}),
                        (this.keyHeld = {}),
                        (this.mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 }),
                        (this.mouseDown = []),
                        (this.mouseScreen = { x: 0, y: 0 }),
                        (this.mouseAxis = { x: 0, y: 0 }),
                        (this.listeners = {}),
                        (this.scrollLock = null),
                        (this.click = { left: !1, right: !1 }),
                        (this.onMouseDownBound = this.onMouseDown.bind(this)),
                        (this.onMouseUpBound = this.onMouseUp.bind(this)),
                        (this.onMouseMoveBound = this.onMouseMove.bind(this)),
                        (this.scroll = 0),
                        (this.scrollDelta = 0),
                        (this.scrollFactor = -1),
                        (this.onScrollBound = this.onScroll.bind(this)),
                        (this.scrollSense = 0.05),
                        (this.onKeyDownBound = (e) => {
                            this.onKeyDown(e);
                        }),
                        (this.onKeyDown = this.onKeyDownUnlocked),
                        (this.onKeyDownNull = () => {}),
                        (this.onKeyUpBound = (e) => {
                            this.onKeyUp(e);
                        }),
                        (this.onKeyUp = this.onKeyUpUnlocked),
                        (this.onKeyUpNull = () => {}),
                        (this.mouseEnabled = !0),
                        (this.keysLocked = !1),
                        (this.mouseWasEnabled = !0),
                        (this.halfScreen = { x: window.innerWidth / 2, y: window.innerHeight / 2 });
                }
                init(e) {
                    (this.dom = e),
                        this.dom.addEventListener("mousedown", this.onMouseDownBound, !1),
                        this.dom.addEventListener("mouseup", this.onMouseUpBound, !1),
                        this.dom.addEventListener("mousemove", this.onMouseMoveBound, !1),
                        this.dom.addEventListener("wheel", this.onScrollBound, !1),
                        this.dom.addEventListener("keydown", this.onKeyDownBound, !1),
                        this.dom.addEventListener("keyup", this.onKeyUpBound, !1);
                }
                destroy() {
                    this.dom.removeEventListener("mousedown", this.onMouseDownBound, !1),
                        this.dom.removeEventListener("mouseup", this.onMouseUpBound, !1),
                        this.dom.removeEventListener("mousemove", this.onMouseMoveBound, !1),
                        this.dom.removeEventListener("wheel", this.onScrollBound, !1),
                        this.dom.removeEventListener("keydown", this.onKeyDownBound, !1),
                        this.dom.removeEventListener("keyup", this.onKeyUpBound, !1);
                }
                addListener(e, t) {
                    e in this.listeners || (this.listeners[e] = []), this.listeners[e].push(t);
                }
                removeListener(e, t) {
                    if (e in this.listeners) {
                        let i = this.listeners[e].indexOf(t);
                        i >= 0 && this.listeners[e].splice(i, 1);
                    }
                }
                onMouseDown(e) {
                    this.mouseEnabled && ((this.mouseDown[e.button] = !0), 0 == e.button ? (this.click.left = !0) : 2 == e.button && (this.click.right = !0), e.preventDefault());
                }
                onMouseUp(e) {
                    this.mouseEnabled && ((this.mouseDown[e.button] = !1), 0 == e.button ? (this.click.left = !1) : 2 == e.button && (this.click.right = !1), e.preventDefault());
                }
                onMouseMove(e) {
                    this.mouseEnabled &&
                        ((this.mouse.x = e.clientX),
                        (this.mouseWidth = Math.max(320, m.axisWidth * window.innerWidth)),
                        (this.mouseScreen.x = Math.max(Math.min(1, ((e.clientX - window.innerWidth / 2) / window.innerWidth) * 2), -1)),
                        (this.mouseAxis.x = Math.max(Math.min(1, ((e.clientX - this.halfScreen.x) / this.mouseWidth) * 2), -1)),
                        (this.mouse.y = e.clientY),
                        (this.mouseHeight = window.innerHeight * (c.mouseWidgetHeight / 100)),
                        (this.mouseScreen.y = -(e.clientY - window.innerHeight / 2) / (window.innerHeight / 2)),
                        (this.mouseAxis.y = (-(e.clientY - (this.halfScreen.y - this.mouseHeight) - this.halfScreen.y) / this.halfScreen.y) * 2));
                }
                onScroll(e) {
                    (this.scrollDelta = e.deltaY > 0 ? 1 : -1), (this.scroll += this.scrollDelta * this.scrollSense), (this.scroll = Math.min(Math.max(this.scroll, -1), 1));
                }
                onKey(e) {
                    if (e in this.listeners) {
                        for (let t of this.listeners[e]) t();
                        return !0;
                    }
                    return !1;
                }
                onKeyDownUnlocked(e) {
                    (this.key[e.code] = !0), (this.onKey(e.code) || v[e.code]) && e.preventDefault(), (this.keyHeld[e.code] = !0);
                }
                onKeyUpUnlocked(e) {
                    (this.key[e.code] = !1), (this.keyHeld[e.code] = !1);
                }
                resetKeyState() {
                    for (let e in this.key) this.key[e] = !1;
                }
                setMouseEnabled(e) {
                    (this.mouseEnabled = e), (this.scroll = 0), (this.mouseAxis.x = 0), (this.mouseAxis.y = 0);
                    for (let t = 0; t < this.mouseDown.length; t++) this.mouseDown[t] = !1;
                    (this.click.left = !1), (this.click.right = !1);
                }
                lockKeys() {
                    this.keysLocked || (this.resetKeyState(), (this.mouseWasEnabled = this.mouseEnabled), this.setMouseEnabled(!1), (this.keysLocked = !0), (this.onKeyDown = this.onKeyDownNull), (this.onKeyUp = this.onKeyUpNull));
                }
                unlockKeys() {
                    this.keysLocked && ((this.keysLocked = !1), this.setMouseEnabled(!0), (this.onKeyDown = this.onKeyDownUnlocked), (this.onKeyUp = this.onKeyUpUnlocked));
                }
                lockScroll(e) {
                    null == this.scrollLock && (this.scrollLock = e);
                }
                unlockScroll(e) {
                    this.scrollLock == e && (this.scrollLock = null);
                }
                setSize(e, t) {
                    (this.halfScreen.x = e / 2), (this.halfScreen.y = t / 2);
                }
            })();
            var w = class {
                static update(e, t) {}
            };
            const b = new l(
                    {
                        Forward: "KeyW",
                        Left: "KeyA",
                        Backward: "KeyS",
                        Right: "KeyD",
                        Boost: "ShiftLeft",
                        Handbrake: "Space",
                        ToggleHandbrake: "KeyB",
                        Autodrive: "KeyF",
                        Reset: "KeyR",
                        Headlights: "KeyH",
                        StickySteer: "KeyV",
                        NextScene: "KeyE",
                        PrevScene: "KeyQ",
                        CameraMode: "KeyC",
                        Mute: "KeyM",
                        Pause: "KeyP",
                        ToggleUI: "KeyU",
                        ToggleCinecam: "KeyT",
                        ToggleDebug: "F3",
                    },
                    "controls_keys"
                ),
                A = new p({ toggleBoost: !1, doubleTapBoost: !0, softSteer: !0, steerSpeed: 1, recenterSpeed: 2, lockedSteerSpeed: 0.6 }, "controls_keys_settings"),
                y = {
                    toggleBoost: { readable: "Boost Style", type: u.Boolean, default: !1, labels: ["hold", "toggle"] },
                    doubleTapBoost: { readable: "Double-tap to boost", desc: "Engage boost by double-tapping forwards", type: u.Boolean, default: !0 },
                    softSteer: { readable: "Steer Input Style", desc: "Soft steering is more gentle; Quick steering is more direct", type: u.Boolean, default: !0, labels: ["quick", "soft"] },
                    steerSpeed: { readable: "Steer Sensitivity", desc: "How quickly the wheels turn under input", type: u.FloatRange, default: 1, min: 0.5, max: 5 },
                    recenterSpeed: { readable: "Re-center Sensitivity", desc: "How quickly the wheels recenter when input is released", type: u.FloatRange, default: 2, min: 0.5, max: 5 },
                    lockedSteerSpeed: { readable: "Locked Steer Sensitivity", desc: "Steer sensitivity when using steer lock", type: u.FloatRange, default: 0.6, min: 0.25, max: 1, precision: 2 },
                };
            let I;
            class S extends w {
                static update(e, t) {
                    (I = b.value),
                        (t.Forward = 0),
                        (t.Backward = 0),
                        (t.Left = 0),
                        (t.Right = 0),
                        (t.Handbrake = 0),
                        (t.StickySteer = 0),
                        (t.Boost = 0),
                        f.key[I.Forward] && (t.Forward = 1),
                        f.key[I.Backward] && (t.Backward = 1),
                        f.key[I.Left] && (t.Left = 1),
                        f.key[I.Right] && (t.Right = 1),
                        f.key[I.Handbrake] && (t.Handbrake = 1),
                        f.key[I.Boost] && (t.Boost = 1),
                        f.key[I.StickySteer] && (t.StickySteer = 1);
                }
            }
            S.label = "Keys";
            const M = [S, S, S];
            var D = new l(0, "config-controller-index");
            const k = new l({ Translate: "WASD", Rotate: "Mouse Look", Elevate: "Left Click", Descend: "Right Click", Zoom: "Scrollwheel", DoubleSpeed: "ShiftLeft", ResetCamera: "G", MatchSpeed: "CapsLock", ToggleCinecam: "T (default)" }),
                C = new p({ baseSpeed: 1, boostFactor: 2, elevationSpeed: 0.3, mouseSense: 1, smoothing: 0.5, zoomSpeed: 1 }, "constrols_cinecam_settings"),
                j = {
                    baseSpeed: { readable: "Base speed", type: u.FloatRange, default: 1, min: 0.2, max: 4 },
                    boostFactor: { readable: "Boost factor", type: u.FloatRange, default: 2, min: 0.5, max: 5 },
                    elevationSpeed: { readable: "Elevation speed", type: u.FloatRange, default: 0.33, min: 0.1, max: 2 },
                    mouseSense: { readable: "Mouse sensitivity", type: u.FloatRange, default: 1, min: 0.1, max: 3 },
                    smoothing: { readable: "Mouse smoothing", type: u.FloatRange, default: 0.5, min: 0, max: 1 },
                    zoomSpeed: { readable: "Zoom sensitivity", type: u.FloatRange, default: 1, min: 1, max: 5 },
                };
            var N = new l(!1);
            const z = 0,
                O = 1,
                L = {
                    Forward: { type: z, index: 7 },
                    Left: { type: O, index: 0, sign: -1, max: 1 },
                    Backward: { type: z, index: 6 },
                    Right: { type: O, index: 0, sign: 1, max: 1 },
                    Boost: { type: z, index: 1 },
                    Handbrake: { type: z, index: 5 },
                    ToggleHandbrake: { type: z, index: 4 },
                    Autodrive: { type: z, index: 0 },
                    Reset: { type: z, index: 3 },
                    Headlights: { type: z, index: 13 },
                    StickySteer: null,
                    NextScene: { type: z, index: 15 },
                    PrevScene: { type: z, index: 14 },
                    CameraMode: { type: z, index: 12 },
                    Mute: null,
                    Pause: null,
                    ToggleUI: null,
                    ToggleDebug: null,
                },
                R =
                    (new l(null),
                    {
                        connected: !0,
                        axes: [0, 0],
                        buttons: [
                            { pressed: !1, touched: !1, value: 0 },
                            { pressed: !1, touched: !1, value: 0 },
                            { pressed: !1, touched: !1, value: 0 },
                            { pressed: !1, touched: !1, value: 0 },
                            { pressed: !1, touched: !1, value: 0 },
                        ],
                    }),
                T = new l(L, "controls_gamepad"),
                P = new p({ autoBoost: !1, steerSmoothing: 0.25, steerRange: 0.9, linearity: 0.25, deadzone: 1 }, "controls_gamepad_settings"),
                G = {
                    autoBoost: { readable: "Max throttle boosts", desc: "Applies boost when at max throttle", type: u.Boolean, default: !1 },
                    steerSmoothing: { readable: "Steer smoothing", desc: "Applies gentle smoothing to the steering input", type: u.FloatRange, default: 1, min: 0, max: 1, precision: 2 },
                    steerRange: { readable: "Steer range", desc: "Alters the maximum steer angle", type: u.FloatRange, default: 0.9, min: 0.25, max: 1, precision: 2 },
                    linearity: { readable: "Steer linearity", desc: "Less linearity means more precision at small steer angles", type: u.FloatRange, default: 0.25, min: 0, max: 1, precision: 2 },
                    deadzone: { readable: "Axis Deadzone", desc: "Width of deadzone as a percentage", type: u.FloatRange, default: 0.5, min: 0, max: 10, precision: 1 },
                },
                B = {
                    Forward: 0,
                    Left: 1,
                    Right: 2,
                    Backward: 3,
                    Handbrake: 4,
                    ToggleHandbrake: 18,
                    Boost: 5,
                    Autodrive: 6,
                    Reset: 7,
                    NextScene: 8,
                    PrevScene: 9,
                    StickySteer: 10,
                    Headlights: 11,
                    CameraMode: 12,
                    ToggleUI: 13,
                    ToggleDebug: 14,
                    ToggleCinecam: 15,
                    Mute: 16,
                    Pause: 17,
                },
                W = {
                    Handbrake: !0,
                    Autodrive: !0,
                    Headlights: !0,
                    StickySteer: !0,
                    Boost: !1,
                    CameraMode: !0,
                    NextScene: !0,
                    PrevScene: !0,
                    ToggleUI: !0,
                    ToggleDebug: !0,
                    ToggleCinecam: !0,
                    ToggleHandbrake: !0,
                    Reset: !0,
                    Mute: !0,
                    Pause: !0,
                },
                E = { Autodrive: !0, Headlights: !0, CameraMode: !0, NextScene: !0, PrevScene: !0, ToggleUI: !0, ToggleDebug: !0, ToggleCinecam: !0, Reset: !0, Mute: !0, Pause: !0, ToggleHandbrake: !0 };
            let F, Z, H, Q;
            var Y = new (class {
                getGP() {
                    return navigator.getGamepads()[0];
                }
                constructor() {
                    (this.keys = {}),
                        (this.scemes = {}),
                        (this.signal = {}),
                        (this.controllerSignal = {}),
                        (this.gamepadDidPress = {}),
                        (this.listeners = {}),
                        (this.dom = {}),
                        (this.keyMapCopy = {}),
                        (this.deadzoneMin = 0.05),
                        (this.deadzoneFactor = 1.05),
                        (this.onKeyMapChangedBound = this.onKeyMapChanged.bind(this)),
                        (this.onPauseBound = () => this.on("Pause")),
                        (this.onMuteBound = () => this.on("Mute")),
                        (this.onControllerChangedBound = this.onControllerChanged.bind(this)),
                        (this.isCinecam = !1),
                        (this.hadController = 0),
                        (this.onToggleCinecamBound = this.onToggleCinecam.bind(this)),
                        (this.verifiedGamepadMap = !1),
                        (this.held = { Autodrive: !1, Headlights: !1 }),
                        (this.toggled = { Handbrake: !1, Boost: !1 }),
                        (this.keyState = { lastAccel: 0, hasAccel: !1, hasBoost: !1 }),
                        (this.mouseOff = !1),
                        (this.useMouseSim = !1),
                        (this.onGamepadRemapped = () => {}),
                        (this.remappingGamepad = !1),
                        (this.remappingGamepadControl = null),
                        (this.remapInitState = {});
                    for (let e in B) (this.signal[e] = 0), (this.controllerSignal[e] = 0), (this.listeners[e] = []);
                    D.addListener(this.onControllerChangedBound),
                        (this.controller = M[D.value]),
                        (this.keyController = M[0]),
                        this.addListener("ToggleCinecam", this.onToggleCinecamBound),
                        P.addListener("deadzone", this.updateGamepadDeadzone.bind(this)),
                        this.updateGamepadDeadzone(),
                        b.addListener(this.onKeyMapChangedBound),
                        this.onKeyMapChanged(b.value),
                        (this.keys = f.key);
                }
                updateGamepadDeadzone(e = P.deadzone) {
                    (this.deadzoneMin = e / 100), (this.deadzoneFactor = 1 / (1 - this.deadzoneMin));
                }
                initialise() {
                    this.dom.mouseMarker = document.getElementById("ui-mouse-bar-marker");
                }
                onKeyMapChanged(e) {
                    null == this.keyMapCopy
                        ? ((this.keyMapCopy = {}), f.addListener(e.Pause, this.onPauseBound), f.addListener(e.Mute, this.onMuteBound))
                        : (this.keyMapCopy.Pause !== e.Pause && (f.removeListener(this.keyMapCopy.Pause, this.onPauseBound), f.addListener(e.Pause, this.onPauseBound)),
                          this.keyMapCopy.Mute !== e.Mute && (f.removeListener(this.keyMapCopy.Mute, this.onMuteBound), f.addListener(e.Mute, this.onMuteBound))),
                        Object.assign(this.keyMapCopy, e);
                }
                init() {}
                onControllerChanged(e) {
                    if (2 == e) {
                        if (((this.verifiedGamepadMap = !1), (Q = this.getGP()), !Q)) return;
                        this.verifyControllerMap();
                    }
                }
                onToggleCinecam() {
                    N.value ? D.set(this.hadController) : ((this.hadController = D.value), D.set(0)), N.set(!N.value);
                }
                verifyControllerMap() {
                    if (((Q = this.getGP()), !Q)) return;
                    let e = {};
                    for (let t in T.value) {
                        let i = T.value[t];
                        i &&
                            (i.type == z && Q.buttons.length <= i.index && ((e[t] = null), console.warn("Unsetting missing button control for ", t)),
                            i.type == O && Q.axes.length <= i.index && ((e[t] = null), console.warn("Unsetting missing axis control for ", t)));
                    }
                    T.set({ ...T.value, ...e }), (this.verifiedGamepadMap = !0);
                }
                halfLerp(e) {
                    return 2 * ((3 - 2 * (e = e / 2 + 0.5)) * e * e - 0.5);
                }
                update() {
                    if ((this.updateKeys(), N.value))
                        return (this.signal.Left = 0), (this.signal.Right = 0), (this.signal.Forward = 0), (this.signal.Backward = 0), void (this.signal.Handbrake = this.toggled.Handbrake || this.signal.Handbrake > 0 ? 1 : 0);
                    1 == D.value
                        ? (this.updateMouse(), (this.signal.Forward = Math.min(1, this.signal.Forward + this.controllerSignal.Forward)), (this.signal.Backward = Math.min(1, this.signal.Backward + this.controllerSignal.Backward)))
                        : 2 == D.value &&
                          (this.updateGamepad(), (this.signal.Forward = Math.min(1, this.signal.Forward + this.controllerSignal.Forward)), (this.signal.Backward = Math.min(1, this.signal.Backward + this.controllerSignal.Backward))),
                        this.signal.ToggleHandbrake
                            ? ((this.toggled.Handbrake = !this.toggled.Handbrake), this.on("ToggleHandbrake", this.toggled.Handbrake))
                            : this.toggled.Handbrake && this.signal.Handbrake && ((this.toggled.Handbrake = !1), this.on("ToggleHandbrake", !1)),
                        (this.signal.Handbrake = this.toggled.Handbrake || this.signal.Handbrake > 0 ? 1 : 0);
                }
                updateKeys() {
                    (F = b.value),
                        (this.signal.Forward = 0),
                        f.key[F.Forward] || f.key.ArrowUp
                            ? (!this.keyState.hasAccel &&
                                  A.doubleTapBoost &&
                                  (!this.keyState.hasAccel &&
                                      oe.appTime - this.keyState.lastAccel < 0.2 &&
                                      (A.toggleBoost ? ((this.toggled.Boost = !this.toggled.Boost), (this.keyState.boostFromTap = this.toggled.Boost)) : (this.keyState.boostFromTap = !0)),
                                  (this.keyState.lastAccel = oe.appTime)),
                              (this.signal.Forward = 1),
                              (this.keyState.hasAccel = !0))
                            : ((this.keyState.hasAccel = !1), (this.keyState.boostFromTap = !1)),
                        (this.signal.Backward = 0),
                        (f.key[F.Backward] || f.key.ArrowDown) && (this.signal.Backward = 1),
                        (this.signal.StickySteer = f.key[F.StickySteer] ? 1 : 0),
                        (this.signal.Left = 0),
                        (f.key[F.Left] || f.key.ArrowLeft) && (this.signal.Left = 1),
                        (this.signal.Right = 0),
                        (f.key[F.Right] || f.key.ArrowRight) && (this.signal.Right = 1),
                        (this.signal.Handbrake = f.key[F.Handbrake] ? 1 : 0),
                        this.checkDebouncedKey("ToggleHandbrake", !1),
                        this.keyState.boostFromTap
                            ? (this.signal.Boost = 1)
                            : A.toggleBoost
                            ? (this.checkDebouncedKey("Boost", !1), this.signal.Boost && ((this.toggled.Boost = !this.toggled.Boost), (this.keyState.boostFromTap = !1)), (this.signal.Boost = this.toggled.Boost))
                            : (this.signal.Boost = f.key[F.Boost] ? 1 : 0),
                        (this.signal.Reset = f.key[F.Reset] ? 1 : 0),
                        this.signal.Reset && (f.key[F.Reset] = !1),
                        this.checkDebouncedKey("Autodrive"),
                        this.checkDebouncedKey("Headlights"),
                        this.checkDebouncedKey("CameraMode"),
                        this.checkDebouncedKey("NextScene"),
                        this.checkDebouncedKey("PrevScene"),
                        this.checkDebouncedKey("ToggleUI"),
                        this.checkDebouncedKey("ToggleDebug"),
                        this.checkDebouncedKey("ToggleCinecam");
                }
                updateMouse() {
                    Z = g.value;
                    for (let e in Z) null !== Z[e] && this.getMouseValue(e);
                    (this.controllerSignal.Left = 0),
                        (this.controllerSignal.Right = 0),
                        f.mouseAxis.y > 0
                            ? ((this.controllerSignal.Left = -1 * Math.min(0, f.mouseAxis.x)),
                              (this.controllerSignal.Right = Math.max(0, f.mouseAxis.x)),
                              (this.dom.mouseMarker.style.transform = "translateX(" + (50 + 50 * f.mouseAxis.x) + "%)"),
                              (this.mouseOff = !1))
                            : this.mouseOff || ((this.dom.mouseMarker.style.transform = "translateX(50%)"), (this.mouseOff = !0));
                }
                getMouseValue(e) {
                    (this.c = Z[e]),
                        (this.v = f.mouseDown[this.c] ? 1 : 0),
                        this.v > 0 ? (E[e] ? this.gamepadDidPress[e] || ((this.gamepadDidPress[e] = !0), W[e] && (this.signal[e] = 1), this.on(e, 1)) : (this.signal[e] = 1)) : (this.gamepadDidPress[e] = !1),
                        (this.controllerSignal[e] = this.v);
                }
                updateGamepadSim() {
                    (Q = R),
                        (Q.buttons[0].value = f.mouseDown[0] ? 1 : 0),
                        (Q.buttons[1].value = f.mouseDown[1] ? 1 : 0),
                        (Q.buttons[2].value = f.mouseDown[2] ? 1 : 0),
                        (Q.buttons[3].value = f.mouseDown[3] ? 1 : 0),
                        (Q.buttons[4].value = f.mouseDown[4] ? 1 : 0),
                        (Q.axes[0] = f.mouseAxis.x),
                        (Q.axes[1] = f.mouseAxis.y);
                }
                updateGamepad() {
                    if (((H = T.value), (Q = this.getGP()), Q))
                        if (this.remappingGamepad) this.updateGamepadRemap();
                        else {
                            for (let e in H) this.getGamepadValue(e);
                            P.autoBoost && (this.signal.Boost = this.signal.Boost || this.controllerSignal.Forward > 0.99);
                        }
                    else (this.controllerSignal.Forward = 0), (this.controllerSignal.Backward = 0);
                }
                updateGamepadRemap() {
                    if (((Q = this.getGP()), !Q)) return;
                    let e,
                        t,
                        i,
                        s = null;
                    if (Q.axes)
                        for (let h = 0; h < Q.axes.length; h++) {
                            var n;
                            if (((e = (null === (n = this.remapInitState.axes) || void 0 === n ? void 0 : n[h]) || 0), this.remapInitState.axes && Math.abs(Q.axes[h] - e) > 0.2)) {
                                var a, o;
                                if (((t = Math.sign(Q.axes[h])), t < 0)) (i = (null === (a = Q.axisMinimums) || void 0 === a ? void 0 : a[h]) || -1), (i = Math.abs(i));
                                else i = (null === (o = Q.axisMaximums) || void 0 === o ? void 0 : o[h]) || 1;
                                s = { type: O, index: h, sign: t, max: i };
                                break;
                            }
                        }
                    else console.warn("No axes detected");
                    if (null == s && Q.buttons)
                        for (let h = 0; h < Q.buttons.length; h++) {
                            var r;
                            if (((e = (null === (r = this.remapInitState.buttons) || void 0 === r ? void 0 : r[h].value) || 0), Math.abs(Q.buttons[h].value - e) > 0.5 || Q.buttons[h].pressed)) {
                                (s = { type: z, index: h }), (this.gamepadDidPress[this.remappingGamepadControl] = !0);
                                break;
                            }
                        }
                    if (null !== s) {
                        let e = JSON.parse(JSON.stringify(T.value));
                        T.set({ ...e, [this.remappingGamepadControl]: s }), this.onGamepadRemapped(), this.cancelGamepadRemap();
                    }
                }
                cancelGamepadRemap() {
                    (this.remappingGamepad = !1), (this.onGamepadRemapped = () => {});
                }
                initGamepadRemap(e, t) {
                    if (((Q = this.getGP()), (this.remapInitState = null), Q && Q.axes && Q.buttons)) {
                        f.setMouseEnabled(!0), (this.remapInitState = { axes: [], buttons: [] });
                        for (let e of Q.axes) this.remapInitState.axes.push(e);
                        for (let e of Q.buttons) this.remapInitState.buttons.push({ pressed: e.pressed, value: e.value });
                        (this.remappingGamepadControl = t), (this.onGamepadRemapped = e), (this.remappingGamepad = !0);
                    } else console.warn("No gamepad state found; cannot remap");
                }
                getGamepadValue(e, t = !1) {
                    (this.controllerSignal[e] = 0),
                        (this.c = H[e]),
                        this.c &&
                            (this.c.type == z && Q.buttons[this.c.index]
                                ? ((this.v = Math.abs(Q.buttons[this.c.index].value) || 0),
                                  0 == this.v && Q.buttons[this.c.index].pressed && (this.v = 1),
                                  this.v > 0
                                      ? E[e]
                                          ? this.gamepadDidPress[e] || ((this.gamepadDidPress[e] = !0), W[e] && (this.signal[e] = 1), this.remappingGamepad || this.on(e, 1))
                                          : (this.signal[e] = this.v)
                                      : (this.gamepadDidPress[e] = !1),
                                  (this.controllerSignal[e] = this.v))
                                : ((this.v = Q.axes[this.c.index] || 0),
                                  Math.sign(this.v) == this.c.sign &&
                                      (this.c.max || (this.c.max = 1), (this.v = Math.max(0, (this.v * this.c.sign - this.deadzoneMin) * this.deadzoneFactor) / this.c.max), (this.controllerSignal[e] = this.v))));
                }
                checkDebouncedKey(e, t = !0) {
                    (this.signal[e] = 0), f.key[F[e]] ? this.held[e] || ((this.signal[e] = 1), (this.held[e] = !0), t && this.on(e)) : (this.held[e] = !1);
                }
                addListener(e, t) {
                    "function" === typeof t && (this.listeners[e].includes(t) || this.listeners[e].push(t));
                }
                removeListener(e, t) {
                    if (!(e in this.listeners)) return;
                    let i = this.listeners[e].indexOf(t);
                    i >= 0 && this.listeners[e].splice(i, 1);
                }
                on(e, t = null) {
                    for (let i of this.listeners[e]) i(t);
                }
            })();
            var V = {
                Forward: "KeyW",
                Left: "KeyA",
                Right: "KeyD",
                Backward: "KeyS",
                LeftArrow: "ArrowLeft",
                UpArrow: "ArrowUp",
                RightArrow: "ArrowRight",
                DownArrow: "ArrowDown",
                Handbrake: "Space",
                CameraMatchSpeed: "CapsLock",
                BoostAccel: "ShiftLeft",
                BoostAccel2: "ShiftRight",
                Auto: "Equal",
                Mute: "KeyM",
                PageUp: "PageUp",
                PageDown: "PageDown",
                Q: "KeyQ",
                E: "KeyE",
                Camera: "KeyC",
                StickySteer: "IntlBackslash",
                Shift: "ShiftLeft",
                SwitchDrive: "KeyB",
                NodeDebug: "KeyN",
                Reset: "KeyR",
                Lights: "KeyL",
                Headlights: "KeyH",
                Pause: "KeyP",
                UI: "KeyU",
                Debug: "F3",
                Debug2: "F4",
                Reload: "F6",
                StepTicker: "BracketRight",
                Ackermann: "KeyX",
                AutoDrive: "KeyF",
                NextSkin: "KeyG",
                NextTopo: "KeyH",
                Esc: "Escape",
                Any: -1,
                Fullscreen: "F11",
                Control: "ControlLeft",
                T: "KeyT",
                Tab: "Tab",
                Plus: "NumpadAdd",
                Minus: "NumpadSubtract",
                CameraToggle: "Tab",
                ResetCamera: "KeyG",
                Caps: "CapsLock",
                Num1: "Digit1",
            };
            const U = () => {
                let e = !1;
                return (
                    (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(
                        navigator.userAgent
                    ) ||
                        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
                            navigator.userAgent.substr(0, 4)
                        )) &&
                        (e = !0),
                    e
                );
            };
            var X = U() && null === window.localStorage.getItem("force-allow-mobile");
            var J = !1;
            const q = { AudioLevel: "AudioLevel", Units: "Units", AutoPause: "AutoPause", DoubleTap: "DoubleTap", ShowWorm: "ShowWorm" },
                K = 0,
                _ = 1,
                $ = { AudioLevel: 0.5, Units: 0, AutoPause: 0, MouseLook: !1, ShowWorm: _ },
                ee = {
                    Units: { readable: "Units", type: u.Boolean, default: !1, labels: ["miles", "kilometres"], onSet: (e) => te.set("Units", e ? 1 : 0) },
                    MouseLook: { readable: "Mouse look (first-person)", type: u.Boolean, default: !1, labels: ["off", "on"], onSet: (e) => te.set("MouseLook", e) },
                    AutoPause: {
                        readable: "Pause on window change",
                        desc: "Enabling this will prevent the game from running in a separate window/monitor",
                        type: u.Boolean,
                        default: 1,
                        labels: ["off", "on"],
                        onSet: (e) => te.set("AutoPause", e ? 1 : 0),
                    },
                    ShowWorm: { readable: "Show upcoming road worm", type: u.Enum, default: _, labels: ["Always", "Manual drive only", "Never"], onSet: (e) => te.set("ShowWorm", e) },
                };
            const te = new (class extends p {
                constructor(...e) {
                    super(...e), (this.value = $), this.loadConfig();
                }
                set(e, t) {
                    super.set(e, t), window.localStorage.setItem(q[e], t);
                }
                loadConfig() {
                    let e, t;
                    for (t in this.value) (e = JSON.parse(window.localStorage.getItem(q[t]) || $[t])), console.log("GameConfig: Load ", t, e), this.set(t, e);
                }
            })($);
            var ie = te;
            const se = "no_prompt_ha";
            var ne = new (class extends l {
                constructor(...e) {
                    super(...e), (this.default = !1), (this.value = !1), (this.disabled = null != window.localStorage.getItem(se));
                }
                disable() {
                    (this.disabled = !0), window.localStorage.setItem(se, !0);
                }
            })();
            const ae = window.location.pathname.includes("dash");
            var oe = new (class {
                constructor() {
                    (this.appTime = 0),
                        (this.listeners = []),
                        (this.stateListeners = []),
                        (this.blurListeners = []),
                        (this.slowListeners = []),
                        (this.slowInterval = 20),
                        (this.slowTimer = null),
                        (this.wasPaused = !1),
                        (this.paused = !1),
                        (this.blurred = !1),
                        (this.playSpeed = 1),
                        (this.onSplash = !1),
                        (this.playLocked = !1),
                        (this.pausedInterval = null),
                        (this.tick30Bound = this.tick30.bind(this)),
                        (this.startTime = Date.now() / 1e3),
                        (this.playTime = 0),
                        (this.pTime = this.startTime),
                        (this.pSlowTime = this.startTime),
                        Y.addListener("Pause", () => {
                            this.toggle(!0);
                        }),
                        ne.addListener(() => {
                            this.retire(!0);
                        }),
                        (window.onblur = () => {
                            1 == ie.value.AutoPause && this.pause();
                        }),
                        (window.onfocus = () => {
                            this.wasPaused || this.resume();
                        }),
                        document.addEventListener("visibilitychange", (e) => {
                            "visible" == document.visibilityState ? ((this.blurred = !1), this.updateBlurListeners()) : ((this.blurred = !0), this.updateBlurListeners());
                        }),
                        X || ae || (this.tick(), (this.slowTimer = setInterval(this.tick30Bound, this.slowInterval)));
                }
                toggle(e = !1) {
                    this.paused ? this.resume(e) : ((this.wasPaused = !0), this.pause(e));
                }
                retire() {
                    (this.paused = !0), this.updateStateListeners(), cancelAnimationFrame(this.tickRAF), clearInterval(this.slowTimer), (this.tick = () => {}), (this.resume = () => {});
                }
                pause(e = !1) {
                    (this.playLocked = e || this.playLocked),
                        ae || this.paused || ((this.paused = !0), (this.pausedInterval = setInterval(this.tickPaused, 100)), this.updateStateListeners(), cancelAnimationFrame(this.tickRAF), clearInterval(this.slowTimer));
                }
                resume(e = !1) {
                    (this.playLocked && !e) ||
                        ae ||
                        (this.paused &&
                            ((this.paused = !1),
                            (this.playLocked = !1),
                            (this.wasPaused = !1),
                            clearInterval(this.pausedInterval),
                            this.updateStateListeners(),
                            (this.pTime = Date.now() / 1e3),
                            (this.pSlowTime = this.pTime),
                            this.tick(),
                            (this.slowTimer = setInterval(this.tick30Bound, this.slowInterval))));
                }
                tick() {
                    (this.tickRAF = requestAnimationFrame(() => this.tick())),
                        (this.time = Date.now() / 1e3),
                        (this.appTime = this.time - this.startTime),
                        (this.dT = this.time - this.pTime),
                        (this.dT = this.dT > 0.1 ? 0.1 : this.dT),
                        this.dT && ((this.playTime += this.dT), (this.dT *= this.playSpeed), this.updateListeners()),
                        (this.pTime = this.time);
                }
                tickPaused() {
                    Y.update();
                }
                tick30() {
                    (this.slowTime = Date.now() / 1e3), (this.slowdT = this.slowTime - this.pSlowTime), this.updateSlowListeners(this.slowdT), (this.pSlowTime = this.slowTime);
                }
                tickOnce() {
                    console.log("\n\n ---------- STEP ---------- \n\n"),
                        (this.paused = !0),
                        cancelAnimationFrame(this.tickRAF),
                        clearInterval(this.slowTimer),
                        (this.time = Date.now() / 1e3),
                        (this.appTime = this.time - this.startTime),
                        (this.dT = 0.016),
                        this.updateListeners(),
                        (this.pTime = this.time),
                        this.tick30();
                }
                updateListeners() {
                    this.listeners.map((e) => e(this.dT, this.appTime));
                }
                addListener(e) {
                    this.listeners.includes(e) || this.listeners.push(e);
                }
                removeListener(e) {
                    let t = this.listeners.indexOf(e);
                    t >= 0 && this.listeners.splice(t, 1);
                }
                updateSlowListeners() {
                    this.slowListeners.map((e) => e(this.slowdT, this.appTime));
                }
                addSlowListener(e) {
                    this.slowListeners.includes(e) || this.slowListeners.push(e);
                }
                removeSlowListener(e) {
                    let t = this.slowListeners.indexOf(e);
                    t >= 0 && this.slowListeners.splice(t, 1);
                }
                updateStateListeners() {
                    this.stateListeners.map((e) => e(this.paused));
                }
                addStateListener(e) {
                    this.stateListeners.includes(e) || this.stateListeners.push(e);
                }
                removeStateListener(e) {
                    let t = this.stateListeners.indexOf(e);
                    t >= 0 && this.stateListeners.splice(t, 1);
                }
                updateBlurListeners() {
                    this.blurListeners.map((e) => e(this.blurred));
                }
                addBlurListener(e) {
                    this.blurListeners.includes(e) || this.blurListeners.push(e);
                }
                removeBlurListener(e) {
                    let t = this.blurListeners.indexOf(e);
                    t >= 0 && this.blurListeners.splice(t, 1);
                }
            })();
            const re = {};
            let he = window.location.search.substring(1).split("&");
            for (let yu of he) {
                let e = yu.split("=");
                if (e[0].length)
                    try {
                        re[e[0]] = JSON.parse(e[1]);
                    } catch (Au) {
                        re[e[0]] = e[1].toString();
                    }
            }
            var le = re;
            let de = 1 == le.autodrive;
            de || !1 === le.autodrive || (de = null !== window.localStorage.getItem("has-autodrive"));
            var ce = new (class extends l {
                set(e) {
                    super.set(e), e ? window.localStorage.setItem("has-autodrive", !0) : window.localStorage.removeItem("has-autodrive");
                }
            })(de);
            const pe = {
                bonk: { src: i.p + "static/media/surface_hit.8d170970.wav", sound: null },
                autoOn: { src: i.p + "static/media/auto_on.4166c93e.wav", sound: null, vol: 0.5 },
                autoOff: { src: i.p + "static/media/auto_off.6dfe6c40.wav", sound: null, vol: 0.5 },
            };
            var ue = new (class {
                constructor() {
                    (this.loader = new r.d()),
                        (this.hasInit = !1),
                        (this.muted = !1),
                        (this.prevLevel = 0.5),
                        (this.onAutodriveBound = this.onAutodrive.bind(this)),
                        (this.onLevelChangedBound = this.onLevelChanged.bind(this)),
                        (this.wasMuted = !1),
                        (this.onTickerStateBound = this.onTickerState.bind(this)),
                        (this.fadeInBound = this.fadeIn.bind(this)),
                        (this.fadeCounter = 0),
                        (this.fadeTime = 1),
                        (this.initListeners = []),
                        (this.listener = new r.c()),
                        oe.addStateListener(this.onTickerStateBound),
                        oe.addBlurListener(this.onTickerStateBound),
                        this.listener.setMasterVolume(ie.AudioLevel),
                        (this.prevLevel = ie.AudioLevel),
                        ie.addListener(q.AudioLevel, this.onLevelChangedBound),
                        ce.addListener(this.onAutodriveBound);
                }
                onAutodrive(e) {
                    e ? this.play("autoOn") : this.play("autoOff");
                }
                onLevelChanged(e) {
                    (this.muted = 0 == e), this.listener.setMasterVolume(e);
                }
                onTickerState(e) {
                    oe.paused || oe.blurred ? ((this.wasMuted = this.muted), this.listener.setMasterVolume(0)) : this.wasMuted || this.listener.setMasterVolume(ie.AudioLevel);
                }
                init() {
                    if (this.hasInit) return;
                    let e;
                    "running" !== this.listener.context.state && (this.listener.context.resume(), this.listener.setMasterVolume(0), oe.addListener(this.fadeInBound));
                    for (let t in pe) (e = pe[t]), this.loadAudio(e);
                    this.hasInit = !0;
                    for (let t of this.initListeners) t();
                }
                fadeIn(e) {
                    this.fadeCounter += e;
                    let t = Math.min(ie.AudioLevel, this.fadeCounter / this.fadeTime);
                    this.listener.setMasterVolume(t), this.fadeCounter / this.fadeTime >= 1 && oe.removeListener(this.fadeInBound);
                }
                play(e) {
                    e in pe && pe[e].sound && (pe[e].sound.isPlaying && pe[e].sound.stop(), pe[e].sound.play());
                }
                loadAudio(e) {
                    let t = new r.b(this.listener);
                    this.loader.load(e.src, (i) => {
                        t.setBuffer(i), (e.sound = t), e.vol && t.setVolume(e.vol);
                    });
                }
                getAudio(e, t) {
                    let i = new r.b(this.listener);
                    this.loader.load(e, (e) => {
                        i.setBuffer(e), t(i);
                    });
                }
                getPositionalAudio(e, t, i = null) {
                    null == i && (i = new r.M(this.listener)),
                        this.loader.load(e, (e) => {
                            i.setBuffer(e), t(i);
                        });
                }
                mute() {
                    (this.muted = !0), this.listener.setMasterVolume(0);
                }
                unmute() {
                    (this.muted = !1), this.listener.setMasterVolume(1);
                }
                toggleMute() {
                    oe.paused ? (this.wasMuted = !this.wasMuted) : ((this.muted = !this.muted), this.muted && ie.AudioLevel > 0 && (this.prevLevel = ie.AudioLevel), ie.set(q.AudioLevel, this.muted ? 0 : this.prevLevel));
                }
                addInitListener(e) {
                    this.initListeners.push(e);
                }
            })();
            const ge = "reset",
                me = "modelChanged",
                xe = "headlights";
            class ve extends r.G {
                constructor() {
                    super(),
                        (this.listeners = {}),
                        (this.headlightColour = 16777215),
                        (this.geo = new r.G()),
                        (this.pPosition = new r.W()),
                        (this.frontAxlePosition = new r.W()),
                        (this.fwd = new r.W()),
                        (this.accel = new r.W()),
                        (this.pVel = new r.W()),
                        (this.vel = new r.W()),
                        (this.velDir = new r.W()),
                        (this.speed = 0),
                        (this.steer = 0),
                        (this.steerL = 0),
                        (this.steerR = 0),
                        (this.direction = 0),
                        (this.drive = 0),
                        (this.braking = !1),
                        (this.handbrake = !1),
                        (this.heading = 0),
                        (this.gradient = 0),
                        (this.roll = 0),
                        (this.pitch = 0),
                        (this.headlights = !0),
                        (this.headlightsManual = !1),
                        (this.downforce = 0),
                        (this.brakeForce = 0),
                        (this.brakeLerp = 0),
                        (this.slip = 0),
                        (this.speedLerp = 0),
                        (this.motionHeading = 0),
                        (this.wrongWay = !1),
                        (this.rockLonTarget = 0),
                        (this.rockLon = 0),
                        (this.rockLatTarget = 0),
                        (this.rockLat = 0),
                        (this.lights = { left: { light: null, target: null }, right: { light: null, target: null } }),
                        (this.hasInit = !1),
                        (this.steerDifferential = 1),
                        (this.rearSteerDifferential = 1),
                        (this.frSteerDifferential = 1),
                        (this.intensityFactor = 1),
                        (this.headlightIntensity = 1),
                        this.add(this.geo),
                        (this.lightsContainer = new r.G());
                    let e = new r.G(),
                        t = new r.T(16777215, 1, 80, 0.5, 0.5, 1.8);
                    (t.target = e), (this.lights.left.light = t), (this.lights.left.target = e);
                    let i = new r.G();
                    this.lights.right.target = i;
                    let s = t.clone();
                    (s.target = i),
                        (this.lights.right.light = s),
                        this.lightsContainer.add(t),
                        this.lightsContainer.add(s),
                        this.lightsContainer.add(e),
                        this.lightsContainer.add(i),
                        this.add(this.lightsContainer),
                        this.setHeadlightColour(this.headlightColour),
                        (this.frustumCulled = !1),
                        (this.matrixAutoUpdate = !1),
                        (this.matrixWorldAutoUpdate = !1),
                        (this.hasInit = !0);
                }
                setHeadlightColour(e) {
                    (this.headlightColour = e), this.lights.left.light.color.setHex(e), this.lights.right.light.color.setHex(e);
                }
                update() {}
                reset() {
                    this.pPosition.copy(this.position),
                        (this.speed = 0),
                        this.pVel.set(0, 0, 0),
                        this.vel.set(0, 0, 0),
                        this.velDir.set(0, 0, 0),
                        this.accel.set(0, 0, 0),
                        (this.steer = 0),
                        (this.steerL = 0),
                        (this.steerR = 0),
                        (this.drive = 0),
                        (this.direction = 0),
                        (this.braking = !1),
                        (this.handbrake = !1),
                        (this.downforce = 0),
                        (this.brakeForce = 0),
                        (this.brakeLerp = 0),
                        (this.wrongWay = !1),
                        (this.slip = 0),
                        this.frontAxlePosition.copy(this.position),
                        this.fireEvent("reset");
                }
                updateSteer() {
                    let e = Math.sin(this.steer),
                        t = Math.cos(this.steer) * this.wheels.length * 2,
                        i = (2 * this.wheels.length * e) / (t - this.wheels.width * e),
                        s = (2 * this.wheels.length * e) / (t + this.wheels.width * e);
                    (this.steerL = Math.atan(i)),
                        (this.steerR = Math.atan(s)),
                        (this.frSteerDifferential = this.wheels.length / Math.sin(this.steer) / (this.wheels.length / Math.tan(this.steer)) || 1),
                        this.bike ||
                            ((this.steerDifferential = this.wheels.length / Math.sin(this.steerL) / (this.wheels.length / Math.sin(this.steerR)) || 1),
                            (this.rearSteerDifferential = this.wheels.length / i / (this.wheels.length / s) || 1),
                            (this.frSteerDifferential = this.wheels.length / Math.sin(this.steer) / (this.wheels.length / Math.tan(this.steer)) || 1),
                            (this.steerDifferential *= this.frSteerDifferential),
                            (this.rearSteerDifferential /= this.frSteerDifferential));
                }
                setModel(e) {
                    this.reset(),
                        (this.metrics = e.metrics),
                        (this.wheels = e.wheels),
                        (this.cameras = e.cameras),
                        (this.bike = !!e.bike),
                        this.hasInit &&
                            (this.lights.left.light.position.copy(this.metrics.headlightPos),
                            this.lights.left.target.position.copy(this.metrics.headlightPos),
                            (this.lights.left.target.position.z += 1),
                            (this.lights.left.target.position.y -= 0.05),
                            this.lights.right.light.position.copy(this.lights.left.light.position),
                            (this.lights.right.light.position.x *= -1),
                            this.lights.right.target.position.copy(this.lights.left.target.position),
                            (this.lights.right.target.position.x *= -1)),
                        this.fireEvent(me);
                }
                setHeadlights(e, t = !1) {
                    (!e && !t && this.headlights && this.headlightsManual) ||
                        ((this.headlightsManual = (this.headlightsManual || t) && e), (this.headlights = e), (this.intensityFactor = e ? 1 : 0), this.setHeadlightIntensity(this.headlightIntensity), this.fireEvent(xe));
                }
                setHeadlightIntensity(e) {
                    (this.headlightIntensity = e), (this.lights.right.light.intensity = e * this.intensityFactor), (this.lights.left.light.intensity = e * this.intensityFactor);
                }
                fireEvent(e, t = null) {
                    e in this.listeners && this.listeners[e].map((e) => e(t));
                }
                addListener(e, t) {
                    e in this.listeners || (this.listeners[e] = []), this.listeners[e].push(t);
                }
                removeListener(e, t) {
                    if (!(e in this.listeners)) return;
                    let i = this.listeners[e].indexOf(t);
                    i >= 0 && this.listeners[e].splice(i, 1);
                }
            }
            var fe = new ve(),
                we = i.p + "static/media/rolling_06.84342ca7.mp3",
                be = i.p + "static/media/veh_accel_06.8478c426.mp3",
                Ae = i.p + "static/media/veh_car.9991c48a.svg",
                ye = i.p + "static/media/veh_bus.9b1fce50.svg",
                Ie = i.p + "static/media/veh_bike.af1bd6f4.svg",
                Se = i.p + "static/media/roadster-07b_map.9b87de0b.jpg";
            const Me = {
                    Chase: { pitch: { near: 0.3, far: 0.2 }, yOffset: { near: 0.8, far: 1 }, posOffset: [0, 0, 1.4], range: { near: 4, far: 4.75 }, farSpeed: 45, smoothFactor: 1.5 },
                    ChaseFar: { pitch: { near: 0.25, far: 0.15 }, yOffset: { near: 1, far: 2 }, posOffset: [0, 0, 1.4], range: { near: 6, far: 9 }, farSpeed: 45, smoothFactor: 1.25 },
                    FirstPerson: { pitch: { near: 0.05, far: 0.05 }, yOffset: { near: 0.7, far: 0.7 }, posOffset: [0, 0.45, 3.2], range: { near: 0.75, far: 0.75 }, farSpeed: 45, smoothFactor: 0.3 },
                    Bonnet: { pitch: { near: 0.05, far: 0.05 }, yOffset: { near: 0.6, far: 0.6 }, posOffset: [0, 0.4, 3.4], range: { near: 0, far: 0 }, farSpeed: 45, smoothFactor: 0.3, hideVehicle: !0 },
                },
                De = {
                    Debug: {
                        enabled: !1,
                        name: "Debug",
                        skins: [],
                        bodyObj: i(20),
                        wheelObj: i(21),
                        icon: Ae,
                        audio: { roll: we, engine: be },
                        wheels: { tyreWidth: 0.1, width: 1.36, widthHalf: 0.68, length: 2.75, radius: 0.342665, circumference: 2.1, travel: 0.07 },
                        metrics: {
                            shadowMapSize: 4,
                            accel: 9,
                            reverse: 5,
                            jerk: 48,
                            brake: 8,
                            mass: 700,
                            maxSteer: 0.68,
                            axleHeight: 0.342665,
                            dampening: 0.04,
                            rockFactor: 4,
                            drag: 0.001,
                            topSpeed: 45,
                            rollResistance: 0.06,
                            steerInterval: 1,
                            slipBase: 0.1,
                            slipMod: 0.05,
                            aeroFactor: 0.5,
                            headlightPos: { x: 0.64, y: 0.7, z: 3.1 },
                        },
                        cameras: Me,
                    },
                    Bike: {
                        enabled: !1,
                        name: "Bike",
                        skins: [],
                        bike: !0,
                        bodyObj: i(34),
                        wheelObj: i(35),
                        icon: Ie,
                        audio: { roll: we, engine: be },
                        materials: {},
                        wheels: { tyreWidth: 0.077, width: 0, widthHalf: 0, length: 1.95, radius: 0.26, circumference: 1.63, travel: 0.07 },
                        metrics: {
                            shadowMapSize: 4,
                            steerSpeed: 1.57,
                            accel: 11,
                            reverse: 5,
                            jerk: 48,
                            brake: 8,
                            mass: 700,
                            steerAccel: 8,
                            maxSteer: 0.4,
                            dampening: 0.08,
                            rockFactor: 5,
                            drag: 0.001,
                            topSpeed: 53,
                            rollResistance: 0.04,
                            steerInterval: 1.8,
                            slipBase: 1,
                            slipMod: 0,
                            aeroFactor: 0.4,
                            headlightPos: { x: 0.3, y: 0.75, z: 2.25 },
                        },
                        cameras: {
                            Chase: { pitch: { near: 0.3, far: 0.2 }, yOffset: { near: 0.8, far: 1 }, posOffset: [0, 0, 1], range: { near: 3.5, far: 4.5 }, farSpeed: 50, smoothFactor: 0.85, hideVehicle: !1 },
                            ChaseFar: { pitch: { near: 0.25, far: 0.15 }, yOffset: { near: 1, far: 2 }, posOffset: [0, 0, 1], range: { near: 6, far: 9 }, farSpeed: 50, smoothFactor: 0.65 },
                            FirstPerson: { pitch: { near: 0.05, far: 0.05 }, yOffset: { near: 0.7, far: 0.7 }, posOffset: [0, 0.4, 2.3], range: { near: 0.75, far: 0.75 }, farSpeed: 50, smoothFactor: 0.2, hideVehicle: !0 },
                        },
                    },
                    Bus: {
                        enabled: !0,
                        name: "Coach",
                        skins: [],
                        bodyObj: i(36),
                        wheelObj: i(37),
                        icon: ye,
                        audio: { roll: we, engine: be },
                        wheels: { tyreWidth: 0.2, width: 2.24, widthHalf: 1.12, length: 5.47, radius: 0.3955, circumference: 2.485, travel: 0.16 },
                        metrics: {
                            shadowMapSize: 8,
                            steerSpeed: 0.45,
                            accel: 6,
                            reverse: 5,
                            jerk: 6,
                            brake: 4,
                            mass: 1400,
                            steerAccel: 6,
                            maxSteer: 0.65,
                            axleHeight: 0.3955,
                            dampening: 0.06,
                            rockFactor: 5,
                            drag: 0.002,
                            topSpeed: 32,
                            rollResistance: 0.03,
                            steerInterval: 2,
                            slipBase: 1,
                            slipMod: 0.25,
                            aeroFactor: 0,
                            headlightPos: { x: 0.75, y: 0.75, z: 7.25 },
                        },
                        cameras: {
                            Chase: { pitch: { near: 0.35, far: 0.3 }, yOffset: { near: 1.6, far: 2.6 }, posOffset: [0, 0, 2.7], range: { near: 9, far: 11 }, farSpeed: 30, smoothFactor: 1.6 },
                            ChaseFar: { pitch: { near: 0.4, far: 0.3 }, yOffset: { near: 2, far: 4 }, posOffset: [0, 0, 2.7], range: { near: 14, far: 16 }, farSpeed: 30, smoothFactor: 1.4 },
                            FirstPerson: { pitch: { near: 0.05, far: 0.05 }, yOffset: { near: 1.8, far: 1.8 }, posOffset: [0, 0, 6.6], range: { near: 0.75, far: 0.75 }, farSpeed: 30, smoothFactor: 0.4, hideVehicle: !0 },
                        },
                    },
                    Roadster: {
                        enabled: !0,
                        name: "Roadster",
                        bodyObj: i(38),
                        wheelObj: i(39),
                        steerObj: i(40),
                        dashObj: i(41),
                        map: Se,
                        icon: Ae,
                        audio: { roll: we, engine: be },
                        wheels: { tyreWidth: 0.1, width: 1.36, widthHalf: 0.68, length: 2.75, radius: 0.342665, circumference: 2.1, travel: 0.07 },
                        skins: { basic: { body: 16316664 } },
                        metrics: {
                            shadowMapSize: 4,
                            steerSpeed: 1.57,
                            accel: 20,
                            reverse: 5,
                            jerk: 48,
                            brake: 11,
                            mass: 700,
                            steerAccel: 12,
                            maxSteer: 0.68,
                            axleHeight: 0.342665,
                            dampening: 0.04,
                            rockFactor: 4,
                            drag: 0.001,
                            topSpeed: 999,
                            rollResistance: 0.06,
                            steerInterval: 1,
                            slipBase: 0.2,
                            slipMod: 0.1,
                            aeroFactor: 0.4,
                            headlightPos: { x: 0.64, y: 0.7, z: 3.1 },
                            steeringPos: { x: 0.32, y: 0.82, z: 1.75 },
                            steeringAngle: 0.3,
                        },
                        cameras: {
                            ...Me,
                            Bonnet: { pitch: { near: 0.05, far: 0.05 }, yOffset: { near: 0.7, far: 0.7 }, posOffset: [0, 0.45, 3.2], range: { near: 0.75, far: 0.75 }, farSpeed: 45, smoothFactor: 0.3 },
                            Hood: { pitch: { near: 0.05, far: 0.05 }, yOffset: { near: 0.6, far: 0.6 }, posOffset: [0, 0.4, 3.4], range: { near: 0, far: 0 }, farSpeed: 45, smoothFactor: 0.3, hideVehicle: !0 },
                            FirstPerson: {
                                isFirstPerson: !0,
                                nearPlane: 0.08,
                                pitch: { near: 0.025, far: 0.025 },
                                yOffset: { near: 0.7, far: 0.7 },
                                posOffset: [0.32, 1.08, 1.3],
                                range: { near: 0.75, far: 0.75 },
                                farSpeed: 45,
                                smoothFactor: 0,
                            },
                        },
                    },
                    Rover: {
                        enabled: !1,
                        name: "Rover",
                        skins: [],
                        bodyObj: i(20),
                        wheelObj: i(21),
                        icon: Ae,
                        audio: { roll: we, engine: be },
                        materials: {},
                        wheels: { tyreWidth: 0.25, width: 2, widthHalf: 1, length: 3, radius: 0.4, circumference: 2.513, travel: 0.15 },
                        metrics: {
                            shadowMapSize: 4,
                            steerSpeed: 1.57,
                            accel: 7,
                            reverse: 5,
                            jerk: 48,
                            brake: 8,
                            mass: 700,
                            steerAccel: 12,
                            maxSteer: 0.68,
                            axleHeight: 0.4,
                            dampening: 0.03,
                            rockFactor: 5,
                            drag: 0.001,
                            topSpeed: 35,
                            rollResistance: 0.06,
                            steerInterval: 1,
                            slipBase: 0.1,
                            slipMod: 0.05,
                            aeroFactor: 0.5,
                            headlightPos: { x: 0.64, y: 0.7, z: 3.1 },
                        },
                        cameras: Me,
                    },
                };
            const ke = { Roadster: De.Roadster, Bike: De.Bike, Coach: De.Bus, Debug: De.Debug },
                Ce = ["Roadster", "Bike", "Coach"];
            const je = 0,
                Ne = 1,
                ze = 2,
                Oe = { type: "config-vehicle-type", mode: "config-vehicle-mode", input: "config-vehicle-input", side: "config-vehicle-side", steerRotation: "config-vehicle-steer-angle", gripFactor: "config-vehicle-grip" },
                Le = { type: "Roadster", mode: 0, input: 0, side: 1, steerRotation: 270, gripFactor: 1 },
                Re = {
                    side: { readable: "Driver Side", type: u.Boolean, default: !1, labels: ["right", "left"], onSet: (e) => Te.set("side", e ? 1 : 0) },
                    mode: {
                        readable: "Drive Mode",
                        desc: "Controls which wheels receive acceleration power",
                        type: u.Enum,
                        default: je,
                        labels: ["All-wheel drive", "Front-wheel drive", "Rear-wheel drive"],
                        onSet: (e) => Te.set("mode", e),
                    },
                    steerRotation: {
                        readable: "Max steering wheel angle",
                        desc: "How far the steering wheel rotates at maximum input (degrees)",
                        type: u.FloatRange,
                        default: 270,
                        min: 180,
                        max: 450,
                        precision: 0,
                        onSet: (e) => Te.set("steerRotation", e),
                    },
                    gripFactor: { readable: "Tyre grip factor", desc: "Lower values will be more slippery", type: u.FloatRange, default: 1, min: 0.25, max: 3, precision: 2, onSet: (e) => Te.set("gripFactor", e) },
                };
            const Te = new (class extends p {
                constructor() {
                    super(), (this.value = Le), this.loadConfig();
                }
                set(e, t) {
                    super.set(e, t), console.log("Set ", e, t), window.localStorage.setItem(Oe[e], t);
                }
                resetMemory() {
                    for (let e in this.value) window.localStorage.setItem(Oe[e], Le[e]);
                }
                loadConfig() {
                    let e, t;
                    for (t in this.value) {
                        if (((e = Le[t]), window.localStorage.getItem(Oe[t])))
                            try {
                                e = JSON.parse(window.localStorage.getItem(Oe[t]));
                            } catch (Au) {
                                console.warn("Failed to load setting from storage: ", t), (e = Le[t]);
                            }
                        (this[t] = e), console.log("VehicleConfig: Load ", t, e), this.set(t, e);
                    }
                }
            })();
            var Pe = Te;
            const Ge = () => Date.now().toString(16).substring(3);
            let Be = Ge(),
                We = 0,
                Ee = window.location.search.substring(1).split("&"),
                Fe = localStorage.getItem("seed");
            if (Fe) {
                console.log("Restoring seed from local storage"), (Be = Fe);
                let e = localStorage.getItem("config-scene-topography") || "normal",
                    t = Be + "?" + e,
                    i = 0;
                try {
                    (i = JSON.parse(localStorage.getItem(t)) || 0), console.log("Restoring saved progress to node ", i);
                } catch (Au) {
                    console.warn("Could not load saved progress for seed ", Be);
                }
                We = i;
            }
            if (Ee.length)
                for (let yu of Ee) {
                    let e = yu.split("=");
                    if ("seed" == e[0]) console.log("Overriding seed with querystring"), (Be = e[1]);
                    else if ("node" == e[0]) {
                        console.log("Overriding start node with querystring");
                        try {
                            We = JSON.parse(e[1]);
                        } catch (Au) {
                            console.error("Invalid start node param");
                        }
                    }
                }
            localStorage.setItem("seed", Be);
            const Ze = (e = null, t = !1) => (null === e && (e = Ge()), (e = e.toString()) == Be || (!He(e) && (localStorage.setItem("seed", e), t && window.location.reload(), (Be = e), !0))),
                He = (e) => {
                    let t = e.toString();
                    return !!(t.length <= 0 || t.includes("?") || t.includes(" ")) && (console.warn("Invalid seed ", t), !0);
                };
            (Be = Be.toString()), console.log("SEED: ", Be);
            if (((Fe = localStorage.getItem("start-node")), Fe)) {
                console.log("Restoring starting node as ", Fe);
                try {
                    We = JSON.parse(Fe);
                } catch (Au) {
                    console.warn("Failed to retrieve intial node from ls");
                }
            }
            localStorage.removeItem("start-node");
            We > 0 && (We -= 5);
            var Qe =
                "\n\n  uniform sampler2D noiseMap;\n  uniform bool isNight;\n\n  attribute float variant;\n  // attribute vec3 groundNormal;\n  attribute float shadow;\n\n  #define SPRITE_NORMAL vec3(0.0, 1.0, 0.0);\n\n  varying vec2 vUvOffset;\n  varying float vShadow;\n  varying float vNoise;\n\n  varying float vLightGrass;\n  varying float vDarkGrass;\n  #ifdef TREES\n    uniform bool highDef;\n  #endif\n\n";
            var Ye =
                "\n\n  // Get uvLookup  from variant\n\n  /* Indexed into the texture as such:\n\n    2 | 3\n    - + -\n    0 | 1\n\n  */\n\n  vShadow = 1.0 - shadow;\n\n  // Common pieces for bush and grass\n  #if defined(GRASS) || defined(BUSH)\n    // We're only interested in the INSTANCE position for this, not vertex pos\n    vec4 wPos = modelMatrix * instanceMatrix * vec4(1.0);\n\n    float fade = texture2D(noiseMap, vec2(\n      wPos.x / 100.0,\n      wPos.z / 100.0\n    )).r;\n\n    float fade0 = texture2D(noiseMap, vec2(\n      wPos.x / 800.0,\n      wPos.z / 800.0\n    )).r;\n\n    float fade1 = texture2D(noiseMap, vec2(\n      wPos.x / 6400.0,\n      wPos.z / 6400.0\n    )).r;\n\n    fade0 = min(max(0.0,(fade0 - 0.25) * 2.0), 1.0);\n    float fade1b = min(max(0.0,(fade1 - 0.25) * 2.0), 1.0);\n\n    float heightVal = min(1.0, wPos.y/100.0);\n\n    vDarkGrass = 1.0;//1.1 - fade1b * 0.1;\n    vLightGrass = max(0.0, fade1b * heightVal * (fade0 + heightVal));\n\n    if(variant < 2.0) {\n      vLightGrass *= variant / 4.0 + 0.5;\n    }\n\n    #ifdef GRASS\n      float vari = 2.0;\n      if(shadow > 0.1) {\n        vari = floor(fade * 2.0) + 2.0;\n      }\n\n    #endif\n\n    #ifdef BUSH\n      float vari = variant; // Use given actual type for bushes maybe?\n    #endif\n\n    vUvOffset.x = mod(vari, 2.0) * 0.5;\n    vUvOffset.y = floor(vari / 2.0) * 0.5;\n\n  #endif\n\n  // Grass specific pieces\n  #ifdef GRASS\n\n    vNoise = fade;\n\n    if((vLightGrass + vNoise / 10.0 > 0.5 || fade < 0.25) && variant > 0.8) {\n      // 0, 0 for lower left, which is the pale hay type\n      vUvOffset *= 0.0;\n    }\n\n    //// HEATHER\n\n    heightVal =\n      min(1.0, wPos.y / 170.0)\n      *\n      fade1\n      *\n      (texture2D(noiseMap, vec2(\n        wPos.x / 1200.0,\n        wPos.z / 1200.0\n      )).r / 2.0 + 0.5);\n\n    heightVal = smoothstep(0.47, 0.53, heightVal) * fade0;\n\n    if(heightVal > 0.5 && variant > 0.8) {\n\n      // Sink the bush at the edges of the heather patch\n      transformed.y -= 1.0 - heightVal;\n\n      vUvOffset.x = 0.5;\n      vUvOffset.y = 0.0;\n      vLightGrass = 1.0 - heightVal;// - 0.5) * 2.0;\n      vDarkGrass = 1.0;\n    }\n\n  #endif\n\n\n  #ifdef TREES\n\n    vec4 wPos = modelMatrix * instanceMatrix * vec4( 1.0 );\n\n    vNoise = texture2D(noiseMap, vec2(\n      wPos.x / 4000.0,\n      wPos.z / 4000.0\n    )).r\n    *\n    texture2D(noiseMap, vec2(\n      wPos.x / 800.0,\n      wPos.z / 800.0\n    )).r;\n    // *\n    // (min(1.0, wPos.y / 25.0)) * 2.0\n    // -\n    // 0.5;\n\n    // vNoise *= 0.4;\n\n    // float vari = texture2D(noiseMap, vec2(\n    //   wPos.x / 200.0,\n    //   wPos.z / 200.0\n    // )).r;\n    //\n    // // Manually sample ranges\n    // if(vari < 0.4) {\n    //   vari = 0.0;\n    // } else if(vari < 0.6) {\n    //   vari = 1.0;\n    // } else {\n    //   vari = 2.0;\n    // }\n\n    // abuse vShadow for more texture\n    if(highDef) {\n      vShadow = texture2D(noiseMap, vec2(\n        wPos.x / 20.0,\n        wPos.z / 20.0\n      )).r - 0.5;\n    }\n\n    vUvOffset.x = mod(variant, 2.0) * 0.5;\n    vUvOffset.y = floor(variant / 2.0) * 0.5;\n\n  #endif\n\n  #ifdef AUTO_NORMAL\n    vNormal = SPRITE_NORMAL;\n  #endif\n";
            var Ve =
                "\n  varying vec2 vUvOffset;\n  varying float vShadow;\n  varying float vNoise;\n\n  varying float vLightGrass;\n  varying float vDarkGrass;\n\n  uniform vec4 colouration;\n\n  #ifdef TREES\n    uniform sampler2D mapb;\n    uniform bool highDef;\n  #endif\n";
            var Ue =
                "\n\nvec4 texelColor = texture2D( map, vUv + vUvOffset );\n\n  #ifdef GRASS\n    texelColor += colouration * vLightGrass * vNoise;\n    texelColor.rgb *= vDarkGrass;\n    texelColor.rgb *= vShadow;\n  #endif\n\n  #ifdef BUSH\n    texelColor.rgb *= 1.0 - (vLightGrass * 0.1);\n    texelColor.rgb *= vShadow;\n  #endif\n\n  #ifdef TREES\n    // Possibly use a second set\n    if(highDef == true) {\n      if(vNoise > 0.25) {\n        texelColor = texture2D( mapb, vUv + vUvOffset );\n      }\n      texelColor += colouration * vShadow;\n    }\n  #endif\n\n  diffuseColor *= texelColor;\n";
            const Xe = new r.U(),
                Je = (e, t = 1, i = r.O) => {
                    let s = Xe.load(e);
                    return (s.wrapS = i), (s.wrapT = i), (s.anisotropy = t), s;
                },
                qe = (e, t = {}) => {
                    for (let i in t) e.userData[i] = { value: t[i] };
                    return (
                        (e.userData.isNight = { value: !1 }),
                        (i) => {
                            for (let s in t) i.uniforms[s] = e.userData[s];
                            (i.uniforms.isNight = e.userData.isNight),
                                (i.vertexShader = i.vertexShader.replace("#define STANDARD", "#define STANDARD\n" + Qe)),
                                (i.vertexShader = i.vertexShader.replace("#include <begin_vertex>", "#include <begin_vertex>\n" + Ye)),
                                (i.fragmentShader = i.fragmentShader.replace("#define STANDARD", "#define STANDARD\n" + Ve)),
                                (i.fragmentShader = i.fragmentShader.replace("#include <normal_fragment_begin>", "\n  float faceDirection = -1.0;\n  vec3 normal = normalize(vNormal);  \n  vec3 geometryNormal = normal;\n")),
                                (i.fragmentShader = i.fragmentShader.replace("#include <map_fragment>", Ue)),
                                (i.fragmentShader = i.fragmentShader.replace(
                                    "#include <lights_fragment_begin>",
                                    "\n/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef USE_CLEARCOAT\n\n\tgeometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\n#ifdef USE_IRIDESCENCE\n\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\n\tif ( material.iridescenceThickness == 0.0 ) {\n\n\t\tmaterial.iridescence = 0.0;\n\n\t} else {\n\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\n\t}\n\n\tif ( material.iridescence > 0.0 ) {\n\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\n\t\t// Iridescence F0 approximation\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\n\t}\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n/* REFERENCE\n\nvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n  vec3 lVector = spotLight.position - geometry.position;\n  light.direction = normalize( lVector );\n  float angleCos = dot( light.direction, spotLight.direction );\n  float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n  if ( spotAttenuation > 0.0 ) {\n    float lightDistance = length( lVector );\n    light.color = spotLight.color * spotAttenuation;\n    light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n    light.visible = ( light.color != vec3( 0.0 ) );\n  } else {\n    light.color = vec3( 0.0 );\n    light.visible = false;\n  }\n}\n\nstruct SpotLight {\n  vec3 position;\n  \n\t\tvec3 direction;\n  \n\t\tvec3 color;\n  \n\t\tfloat distance;\n  \n\t\tfloat decay;\n  \n\t\tfloat coneCos;\n  \n\t\tfloat penumbraCos;\n  \n\t\n}\n\n*/\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n  #ifdef AUTO_NORMAL\n    geometry.normal = geometry.viewDir;\n  #endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n    // Temper the intensity since we're directly reflecting; 100%  is just too bright\n    spotLight.color *= 0.75;\n    // Extra tempering if autonorm (perfectly vertical)\n    #ifdef AUTO_NORMAL\n      spotLight.color *= 0.33;\n    #endif\n\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\n\t\t// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n  geometry.normal = normal;\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n"
                                ));
                        }
                    );
                },
                Ke = (e) => {
                    (e.vertexShader = e.vertexShader.replace("#define STANDARD", "#define STANDARD\n" + Qe)),
                        (e.vertexShader = e.vertexShader.replace("#include <uv2_vertex>", "#include <uv2_vertex>\n" + Ye)),
                        (e.fragmentShader = e.fragmentShader.replace("#define STANDARD", "#define STANDARD\n" + Ve)),
                        (e.fragmentShader = e.fragmentShader.replace("#include <map_fragment>", Ue));
                },
                _e = (e, t = 0.75, i = 0, s = null, n = {}, a = {}) => {
                    let o = new r.F({ map: Je(e, i, r.h), alphaTest: t, side: r.k, depthTest: !0, roughness: 1, defines: n });
                    return s && (o.normalMap = Je(s, i)), (o.onBeforeCompile = qe(o, a)), o;
                },
                $e = (e, t = 0.75, i = 0, s = null, n = null, a = {}, o = {}) => {
                    let h = new r.F({ map: Je(e, i, r.O), alphaTest: t, side: r.k, depthTest: !0, roughness: 1, defines: a });
                    return s && (h.normalMap = Je(s, i)), (h.onBeforeCompile = qe(h, o)), h;
                };
            var et = Je;
            const tt = [
                    { midlineHorizon: 2e3, midlineFineHorizon: 100, farSize: 200, viewDist: 200, fwdHorizon: 40, rearHorizon: 10, nearFwdHorizon: 15, wallGenHorizon: 65, wallRenderHorizon: 20 },
                    { midlineHorizon: 2e3, midlineFineHorizon: 100, farSize: 400, viewDist: 800, fwdHorizon: 90, rearHorizon: 15, nearFwdHorizon: 25, wallGenHorizon: 80, wallRenderHorizon: 35 },
                    { midlineHorizon: 2e3, midlineFineHorizon: 110, farSize: 700, viewDist: 1400, fwdHorizon: 180, rearHorizon: 20, nearFwdHorizon: 30, wallGenHorizon: 95, wallRenderHorizon: 50 },
                    { midlineHorizon: 2e3, midlineFineHorizon: 125, farSize: 1e3, viewDist: 2e3, fwdHorizon: 250, rearHorizon: 30, nearFwdHorizon: 40, wallGenHorizon: 115, wallRenderHorizon: 70 },
                    { midlineHorizon: 2e3, midlineFineHorizon: 150, farSize: 1500, viewDist: 3e3, fwdHorizon: 250, rearHorizon: 40, nearFwdHorizon: 50, wallGenHorizon: 115, wallRenderHorizon: 90 },
                ],
                it = [
                    { medRes: 5, nearRes: 10 },
                    { medRes: 8, nearRes: 16 },
                    { medRes: 10, nearRes: 20 },
                    { medRes: 12, nearRes: 24 },
                ],
                st = isNaN(parseInt(window.localStorage.getItem("config-view-lod-index"))) ? 2 : parseInt(window.localStorage.getItem("config-view-lod-index"));
            let nt = isNaN(parseInt(window.localStorage.getItem("config-detail-lod-index"))) ? 1 : parseInt(window.localStorage.getItem("config-detail-lod-index")),
                at = tt[st],
                ot = it[nt];
            const rt = (e) => {
                    (at = tt[e]),
                        (At = at.farSize),
                        (yt = At / 10),
                        (St = at.viewDist),
                        (Mt = St / Math.cos(((It * (Math.PI / 180)) / 2) * (window.screen.availWidth / window.screen.availHeight))),
                        (ct = at.midlineHorizon),
                        (gt = at.midlineFineHorizon),
                        (jt = at.fwdHorizon),
                        (Nt = at.rearHorizon),
                        (Lt = at.nearFwdHorizon),
                        (Rt = at.rearHorizon),
                        (Yt = at.wallGenHorizon),
                        (Vt = at.wallRenderHorizon),
                        (Dt.density = Math.sqrt(5 / (St * St)));
                },
                ht = (e) => {
                    (ot = it[e]), (nt = e), (Ct = ot.medRes), (Ot = ot.nearRes), (Dt = e > 1 ? new r.q(16777215, Math.sqrt(5 / (St * St))) : new r.p(16777215, 0.1 * St, St));
                },
                lt = (e, t, i) => {
                    Dt.color.setHex(e), (Dt.near = t), (Dt.far = i), Dt.isFogExp2 && (Dt.density = Math.sqrt(5 / (i * i)));
                },
                dt = () => Dt;
            let ct = 1500;
            const pt = 1e3,
                ut = ct - pt;
            let gt = at.midlineFineHorizon,
                mt = 7;
            const xt = (e) => {
                    mt = e;
                },
                vt = new r.a(16777215, 0.1),
                ft = new r.s(16777215, 16777215, 0.2),
                wt = new r.j(16777215, 0.6);
            wt.sunOffset = new r.W(0, 100, 0);
            const bt = new r.i(16777215);
            let At = at.farSize,
                yt = At / 10,
                It = 68,
                St = At * Math.floor(2.5),
                Mt = St / Math.cos(((It * (Math.PI / 180)) / 2) * (window.screen.availWidth / window.screen.availHeight));
            let Dt = new r.p(16777215, 0.1 * St, St);
            const kt = 10;
            let Ct = ot.medRes,
                jt = at.fwdHorizon,
                Nt = at.rearHorizon;
            const zt = 10;
            let Ot = ot.nearRes,
                Lt = at.nearFwdHorizon,
                Rt = Nt;
            let Tt = 1.4;
            const Pt = (e) => {
                Tt = e;
            };
            let Gt = 0.95;
            const Bt = (e) => {
                Gt = e;
            };
            let Wt = 0.85;
            const Et = (e) => {
                Wt = e;
            };
            let Ft = 3;
            const Zt = (e) => {
                    Ft = e;
                },
                Ht = 0.4,
                Qt = new r.F({ map: null, alphaTest: 0.75 });
            let Yt = at.wallGenHorizon,
                Vt = at.wallRenderHorizon;
            const Ut = 30;
            at.treeRenderHorizon;
            const Xt = new r.C({ depthTest: !1, fog: !0, map: et(null, 2) });
            (Xt.userData.nearCol = { value: new r.i(0) }),
                (Xt.userData.farCol = { value: new r.i(65535) }),
                (Xt.userData.hasClouds = { value: !0 }),
                (Xt.userData.camPos = { value: new r.W() }),
                (Xt.userData.time = { value: 0 }),
                (Xt.onBeforeCompile = (e) => (
                    (e.uniforms.nearCol = Xt.userData.nearCol),
                    (e.uniforms.farCol = Xt.userData.farCol),
                    (e.uniforms.hasClouds = Xt.userData.hasClouds),
                    (e.uniforms.camPos = Xt.userData.camPos),
                    (e.uniforms.time = Xt.userData.time),
                    (e.vertexShader = e.vertexShader.replace(
                        "#include <uv_pars_vertex>",
                        "#include <uv_pars_vertex>\n\n  uniform float time;\n  uniform vec3 camPos;\n\n  varying vec4 wPos;\n  varying vec2 vUUv;\n  varying vec2 vUUUv;\n\n  float skyScale = 7000.0; // Width of sky texture in metres\n  float skyScale2 = 5600.0;\n"
                    )),
                    (e.vertexShader = e.vertexShader.replace(
                        "#include <uv_vertex>",
                        "#include <uv_vertex>\n\n  wPos = modelMatrix * vec4( position, 1.0 );\n\n  // Distance (height) from camera to virtual plane\n  // Big hmm here, these values may intersect with road on rare occasions, could min them\n  float h0 = 350.0 - camPos.y;\n  // Distance from camera to image plane\n  float h1 = 450.0 - camPos.y;\n\n  float lowerScale = skyScale2 * h1 / h0;\n  float motionScale = (h1 - h0) / h0;\n\n  vUUv.x = wPos.x + time;\n  vUUv.y = wPos.z + time;\n\n  vUUv /= skyScale;\n\n  vUUUv.x = ((wPos.x + camPos.x * motionScale ) / lowerScale) + (3000.0 + time) / skyScale2;\n  vUUUv.y = ((wPos.z + camPos.z * motionScale ) / lowerScale) + (3000.0 + time) / skyScale2;\n\n"
                    )),
                    (e.vertexShader = e.vertexShader.replace("#include <fog_vertex>", "vFogDepth = -mvPosition.z;\n#ifdef FOG_EXP2\nvFogDepth = max(0.0, (vFogDepth - fogNear) * (fogFar / (fogFar - fogNear)));\n#endif\n")),
                    (e.fragmentShader = e.fragmentShader.replace(
                        "#include <uv_pars_fragment>",
                        "#include <uv_pars_fragment>\n\n  uniform vec3 nearCol;\n  uniform vec3 farCol;\n  uniform bool hasClouds;\n\n  varying vec2 vUUv;\n  varying vec2 vUUUv;\n\n  const highp float NOISE_GRANULARITY = 0.1;\n\n  highp float random(vec2 coords) {\n     return (fract(sin(dot(coords.xy, vec2(12.9898,78.233))) * 43758.5453) * 0.2) - 0.1;\n  }\n"
                    )),
                    (e.fragmentShader = e.fragmentShader.replace(
                        "#include <aomap_fragment>",
                        "#include <aomap_fragment>\n\n  float vX = (vUv.x - 0.5) * 5.0;\n  float vY = (vUv.y - 0.5) * 5.0;\n\n  float dist = max(0.0, 1.0 - sqrt((vX * vX) + (vY * vY)));\n\n  // DITHERING - todo only on high qual?\n  // dist += random(vec2(vX, vY));\n\n  vec4 skyCol = vec4(mix(farCol, nearCol, dist*dist), 1.0);\n\n  if(hasClouds) {\n\n    // vec4 upperClouds = texture2D(map, vUUv);\n    // vec4 lowerClouds = texture2D(map, vUUUv);\n    //\n    // if(lowerClouds.a > 0.5) {\n    //   lowerClouds.rgb = mix(lowerClouds.rgb, vec3(1.0, 0.5, 0.28), (lowerClouds.a - 0.5) * 2.0);\n    // }\n    //\n    // vec4 cloudCol = max(upperClouds, lowerClouds);\n\n    vec4 cloudCol = max(texture2D( map, vUUv ), texture2D(map, vUUUv)); // MAX\n    // vec4 cloudCol = texture2D( map, vUUv ) * texture2D(map, vUUUv); // MULTIPLY\n    // vec4 cloudCol = (texture2D(map, vUUv) + texture2D( map, vUUUv )) / 2.0; // AVERAGE\n\n    // Apply colour if we have it?\n\n    diffuseColor = mix(skyCol, cloudCol, cloudCol.a);\n\n  } else {\n    diffuseColor = skyCol;\n  }\n\n"
                    )),
                    e
                ));
            const Jt = { discretisedTail: null, head: null, tail: null, vehicleIndex: 0, vehicleNode: null, initIndex: 0 },
                qt = {},
                Kt = (e, t, i, s = !1, n = !1) => {
                    for (
                        qt.checkNode = i,
                            qt.dist = (i.p.x - e) * (i.p.x - e) + (i.p.z - t) * (i.p.z - t),
                            qt.closestDist = qt.dist,
                            qt.closestNode = qt.checkNode,
                            qt.closestFwdDist = qt.dist,
                            qt.closestRearDist = qt.dist,
                            qt.checkInterval = 10;
                        qt.checkInterval > 0;
                        qt.checkInterval -= 9
                    ) {
                        for (
                            qt.checkMargin = 10 == qt.checkInterval ? 1.9 : 1.2, qt.closestFwdNode = qt.closestNode, qt.closestRearNode = qt.closestNode, qt.lastChance = !1, qt.checkCount = 0, qt.checkNode = qt.closestFwdNode;
                            !(qt.checkCount >= 10 || qt.checkNode.i + qt.checkInterval > Jt.tail.i);

                        ) {
                            if (
                                (qt.checkInterval > 1 ? (qt.checkNode = qt.checkNode.next.next.next.next.next.next.next.next.next.next) : (qt.checkNode = qt.checkNode.next),
                                (qt.dist = (qt.checkNode.p.x - e) * (qt.checkNode.p.x - e) + (qt.checkNode.p.z - t) * (qt.checkNode.p.z - t)),
                                qt.dist < qt.closestDist)
                            )
                                (qt.lastChance = !1), (qt.closestDist = qt.dist), (qt.closestFwdDist = qt.closestDist), (qt.closestFwdNode = qt.checkNode);
                            else if (qt.dist < qt.closestDist * qt.checkMargin) qt.lastChance = !1;
                            else {
                                if (qt.lastChance) break;
                                qt.lastChance = !0;
                            }
                            qt.checkCount++;
                        }
                        for (qt.checkNode = qt.closestRearNode, qt.lastChance = !1, qt.checkCount = 0; !(qt.checkCount >= 10 || qt.checkNode.i - qt.checkInterval < Jt.head.i); ) {
                            if (
                                (qt.checkInterval > 1 ? (qt.checkNode = qt.checkNode.prev.prev.prev.prev.prev.prev.prev.prev.prev.prev) : (qt.checkNode = qt.checkNode.prev),
                                (qt.dist = (qt.checkNode.p.x - e) * (qt.checkNode.p.x - e) + (qt.checkNode.p.z - t) * (qt.checkNode.p.z - t)),
                                qt.dist < qt.closestDist)
                            )
                                (qt.lastChance = !1), (qt.closestDist = qt.dist), (qt.closestRearDist = qt.closestDist), (qt.closestRearNode = qt.checkNode);
                            else if (qt.dist < qt.closestDist * qt.checkMargin) qt.lastChance = !1;
                            else {
                                if (qt.lastChance) break;
                                qt.lastChance = !0;
                            }
                            qt.checkCount++;
                        }
                        if ((qt.closestFwdDist < qt.closestRearDist ? (qt.closestNode = qt.closestFwdNode) : (qt.closestNode = qt.closestRearNode), !s)) break;
                    }
                    return { n: qt.closestNode, d2: qt.closestDist };
                },
                _t = (e, t, i, s = !1, n = !1) => {
                    var a, o;
                    if (((qt.side = i.n.x * (t - i.p.z) - i.n.z * (e - i.p.x)), n && console.log(e, t, i.p.x, i.p.z), qt.side < 0 && (null === (a = i.next) || void 0 === a ? void 0 : a.next)))
                        for (qt.t = i.next.n.x * (t - i.next.p.z) - i.next.n.z * (e - i.next.p.x); qt.t < 0 && i.next; ) (qt.side = qt.t), (i = i.next), (qt.t = i.next.n.x * (t - i.next.p.z) - i.next.n.z * (e - i.next.p.x));
                    else for (; qt.side > 0 && i.prev; ) (i = i.prev), (qt.side = i.n.x * (t - i.p.z) - i.n.z * (e - i.p.x));
                    if (
                        ((qt.x1 = i.p.x),
                        (qt.z1 = i.p.z),
                        (qt.x2 = i.next.p.x),
                        (qt.z2 = i.next.p.z),
                        (qt.len = (qt.x2 - qt.x1) * (qt.x2 - qt.x1) + (qt.z2 - qt.z1) * (qt.z2 - qt.z1)),
                        (qt.t = ((e - qt.x1) * (qt.x2 - qt.x1) + (t - qt.z1) * (qt.z2 - qt.z1)) / qt.len),
                        (qt.t = Math.max(Math.min(qt.t, 1), 0)),
                        s && (null === (o = i.next.ps) || void 0 === o ? void 0 : o.length))
                    ) {
                        var r, h;
                        if (
                            ((qt.t1 = Math.min(0.999, qt.t) * i.ps.length),
                            (qt.t2 = Math.floor(qt.t1)),
                            (qt.t1 = qt.t1 - qt.t2),
                            (qt.pa = i.ps[qt.t2]),
                            (qt.na = i.ns[qt.t2]),
                            (qt.pb = i.next.p),
                            (qt.nb = i.next.n),
                            qt.t2 < i.ps.length - 1 && ((qt.pb = i.ps[qt.t2 + 1]), (qt.nb = i.ns[qt.t2 + 1])),
                            n && console.log(qt.t1, qt.t2),
                            void 0 === qt.na || void 0 === qt.pa)
                        )
                            console.log("UNDEFINED looking up ", e, t),
                                console.log(i),
                                console.log(i.ps),
                                console.log(null === (r = i.ps) || void 0 === r ? void 0 : r.length),
                                console.log(i.ns),
                                console.log(null === (h = i.ns) || void 0 === h ? void 0 : h.length),
                                console.log(qt.t1, qt.t2);
                        return (
                            (qt.side = qt.na.x * (t - qt.pa.z) - qt.na.z * (e - qt.pa.x)),
                            qt.side < 0 && qt.t2 < i.ps.length - 2
                                ? qt.nb.x * (t - qt.pb.z) - qt.nb.z * (e - qt.pb.x) < 0 && (qt.t2++, (qt.pa = i.ps[qt.t2]), (qt.pb = i.ps[qt.t2 + 1]), (qt.na = i.ns[qt.t2]))
                                : qt.side > 0 && qt.t2 > 0 && (qt.t2--, (qt.pa = i.ps[qt.t2]), (qt.pb = i.ps[qt.t2 + 1]), (qt.na = i.ns[qt.t2])),
                            (qt.x1 = qt.pa.x),
                            (qt.z1 = qt.pa.z),
                            (qt.x2 = qt.pb.x),
                            (qt.z2 = qt.pb.z),
                            (qt.len = (qt.x2 - qt.x1) * (qt.x2 - qt.x1) + (qt.z2 - qt.z1) * (qt.z2 - qt.z1)),
                            (qt.t1 = ((e - qt.x1) * (qt.x2 - qt.x1) + (t - qt.z1) * (qt.z2 - qt.z1)) / qt.len),
                            (qt.x3 = qt.x1 + qt.t1 * (qt.x2 - qt.x1)),
                            (qt.z3 = qt.z1 + qt.t1 * (qt.z2 - qt.z1)),
                            (qt.x1 = qt.x3 - e),
                            (qt.z1 = qt.z3 - t),
                            (qt.side = qt.x1 * qt.na.x + qt.z1 * qt.na.z),
                            {
                                d: Math.sqrt(qt.x1 * qt.x1 + qt.z1 * qt.z1),
                                y: qt.pa.y + qt.t1 * (qt.pb.y - qt.pa.y),
                                da: i.da + qt.t * (i.next.da - i.da),
                                s: qt.side < 0 ? -1 : 1,
                                w: i.w + qt.t * (i.next.w - i.w),
                                g: i.g + qt.t * (i.next.g - i.g),
                                t: qt.t,
                                n: i,
                            }
                        );
                    }
                    return (
                        (qt.x3 = qt.x1 + qt.t * (qt.x2 - qt.x1)),
                        (qt.z3 = qt.z1 + qt.t * (qt.z2 - qt.z1)),
                        (qt.x1 = qt.x3 - e),
                        (qt.z1 = qt.z3 - t),
                        (qt.side = qt.x1 * i.n.x + qt.z1 * i.n.z),
                        {
                            d: Math.sqrt(qt.x1 * qt.x1 + qt.z1 * qt.z1),
                            y: i.p.y + qt.t * (i.next.p.y - i.p.y),
                            da: i.da + qt.t * (i.next.da - i.da),
                            s: qt.side < 0 ? -1 : 1,
                            w: i.w + qt.t * (i.next.w - i.w),
                            g: i.g + qt.t * (i.next.g - i.g),
                            t: qt.t,
                            n: i,
                        }
                    );
                };
            var $t = Jt;
            const ei = new r.W(0, 1, 0),
                ti = {};
            class ii {
                static initialise(e) {
                    console.log("Loading near grid cell..."), e();
                }
                constructor(e, t, i, s = !1) {
                    (this.retired = !1),
                        (this.isDebug = !1),
                        (this.centroid = new r.W()),
                        (this.genRow = 0),
                        (this.genIndex = 0),
                        (this.nodeIndex = 0),
                        (this.meshReady = !1),
                        (this.foliRow = 0),
                        (this.foliIndex = 0),
                        (this.foliageReady = !1),
                        (this.lod = 0),
                        (this.tileCoords = { x: 0, z: 0 }),
                        (this.originNode = null),
                        (this.isDebug = !1),
                        (this.farCell = { x: 0, z: 0 }),
                        (this.initialised = !1),
                        (this.getHeight = () => {}),
                        (this.lod = e),
                        (this.heightmap = i),
                        (this.heights = []),
                        (this.res = t),
                        (this.res1 = t + 1),
                        (this.grads = []),
                        (this.norms = new Float32Array(this.res1 * this.res1 * 3)),
                        (this.verts = new Float32Array(this.res1 * this.res1 * 3)),
                        (this.roadProx = new Float32Array(this.res1 * this.res1)),
                        (this.treeMask = new Float32Array(this.res1 * this.res1)),
                        (this.curves = new Float32Array(this.res1 * this.res1)),
                        (this.signedRoadProx = []);
                }
                initGeneration(e, t, i, s = !1, n) {
                    if (
                        ((this.initialised = !1),
                        (this.retired = !1),
                        this.hide(),
                        (this.active = !1),
                        (this.originNode = e),
                        (this.originIndex = e.i),
                        (this.coords = t),
                        (this.tileCoords = { x: t.x % yt, z: t.z % yt }),
                        (this.heightmap = n),
                        this.tileCoords.x < 0 && (this.tileCoords.x += yt),
                        this.tileCoords.z < 0 && (this.tileCoords.z += yt),
                        (this.originPos = { x: t.x * zt, y: 0, z: t.z * zt }),
                        (this.originPos.y = this.heightmap.getXZ(this.originPos.x, this.originPos.z)),
                        this.centroid.set(this.originPos.x + 5, this.originPos.y, this.originPos.z + 5),
                        (this.tileset = i),
                        (this.tileIndex = i.nextTileIndex++),
                        this.tileset.registerCallback(this.tileIndex, (e) => {
                            this.tileIndex = e;
                        }),
                        this.tileset.setRetireIndex(this.originIndex),
                        0 == this.tileIndex && this.tileset.setOrigin(this.originPos),
                        (this.indexOffset = this.tileIndex * this.tileset.vertexCount),
                        (this.genRow = 0),
                        (this.genIndex = 0),
                        (this.farCell.x = Math.floor(this.originPos.x / At)),
                        (this.farCell.z = Math.floor(this.originPos.z / At)),
                        (this.preHeights = []),
                        0 == Ih.value.detailLodIndex ? (this.precomputeHeights(), (this.getHeight = this.lookupHeight2)) : (this.getHeight = n.getXZ.bind(n)),
                        (this.preCurves = []),
                        this.precomputeCurvature(),
                        (this.initialised = this.preInitialise(s)),
                        this.initialised && s)
                    ) {
                        for (; !this.generate(); );
                        this.display(1 == this.lod);
                    }
                }
                preInitialise() {
                    return !0;
                }
                static sharpLerpAB(e, t, i) {
                    return (t - e) * i + e;
                }
                static hockeyLerp(e) {
                    if (e > 0.3333) {
                        let t = 1 - (e - 0.3333) / 0.6667;
                        return 1 - t * t * 0.5;
                    }
                    return 1.5 * e;
                }
                getNormal(e, t) {
                    let i, s;
                    (i = e < 0 ? Math.floor(((zt + (e % zt)) / zt) * this.res) : Math.floor(((e % zt) / zt) * this.res)), (s = t < 0 ? Math.floor(((zt + (t % zt)) / zt) * this.res) : Math.floor(((t % zt) / zt) * this.res));
                    let n = 3 * (i * this.res1 + s);
                    return [this.norms[n], this.norms[n + 1], this.norms[n + 2]];
                }
                getNormalAtIndex(e) {}
                lookupHeight(e, t) {
                    return (
                        (ti.tx = ((e - this.originPos.x) / zt) * this.res),
                        (ti.tz = ((t - this.originPos.z) / zt) * this.res),
                        (ti.x = Math.floor(ti.tx)),
                        (ti.z = Math.floor(ti.tz)),
                        (ti.tx -= ti.x),
                        (ti.tz -= ti.z),
                        (ti.xi = ti.x * this.res1),
                        (ti.zi = ti.z),
                        (ti.c1 = this.heights[ti.xi + ti.zi] * (1 - ti.tx) + this.heights[ti.xi + this.res1 + ti.zi] * ti.tx),
                        (ti.c2 = this.heights[ti.xi + ti.zi + 1] * (1 - ti.tx) + this.heights[ti.xi + this.res1 + ti.zi + 1] * ti.tx),
                        ti.c1 * (1 - ti.tz) + ti.c2 * ti.tz
                    );
                }
                lerpHeight(e, t, i) {
                    return (
                        (ti.lh = 0),
                        (i.h = i.n.h + i.t * (i.n.next.h - i.n.h)),
                        (i.gfa = i.n.gfa + i.t * (i.n.next.gfa - i.n.gfa)),
                        (i.ga = Math.max(Math.abs(i.g), Math.abs(i.h)) / 3.6),
                        (i.w += Ht + i.ga),
                        (i.y -= 0.015 + 0.025 * i.gfa),
                        (i.ga = 1 - i.ga * i.ga),
                        (ti.rm = 4 + 16 * Math.min(0.75, Math.max(0.4, i.ga))),
                        i.d < i.w + ti.rm
                            ? i.d < i.w && !i.n.bridge
                                ? (ti.lh = i.y)
                                : ((ti.lt = Math.max(0, Math.min(1, (2 * (i.d - i.w)) / ti.rm))),
                                  (ti.lt = ii.hockeyLerp(ti.lt)),
                                  (ti.lh = this.getHeight(e, t)),
                                  i.n.bridge && ti.lh < 0 && (ti.lh > -i.y ? (ti.lt = Math.max(ti.lt, ti.lh / -i.y)) : (ti.lt = 1)),
                                  (ti.lh = ti.lh * ti.lt + i.y * (1 - ti.lt)))
                            : (ti.lh = this.getHeight(e, t)),
                        ti.lh
                    );
                }
                static lerpHeightGlobal(e, t, i, s) {
                    let n = 0;
                    if (((i.ga = Math.max(Math.abs(i.g), Math.abs(i.n.h)) / 3.6), (i.w += Ht + i.ga), (i.y -= 0.01 + 0.02 * i.n.gfa), (i.ga = 1 - i.ga * i.ga), (ti.rm = 4 + 16 * Math.min(0.75, Math.max(0.4, i.ga))), i.d < i.w + ti.rm))
                        if (i.d < i.w && !i.n.bridge) n = i.y;
                        else {
                            let a = Math.max(0, Math.min(1, (2 * (i.d - i.w)) / ti.rm));
                            (a = ii.hockeyLerp(a)), (n = s(e, t)), i.n.bridge && n < 0 && (a = n > -i.y ? Math.max(a, n / -i.y) : 1), (n = n * a + i.y * (1 - a));
                        }
                    else n = s(e, t);
                    return n;
                }
                lookupHeight2(e, t) {
                    return (
                        (ti.tx = (e - this.originPos.x) / zt),
                        (ti.tz = (t - this.originPos.z) / zt),
                        ti.tx < 0
                            ? ((ti.tx += 1),
                              ti.tz < 0
                                  ? ((ti.tz += 1), (ti.c1 = this.preHeights[0] * (1 - ti.tx) + this.preHeights[1] * ti.tx), (ti.c2 = this.preHeights[4] * (1 - ti.tx) + this.preHeights[5] * ti.tx))
                                  : ti.tz > 1
                                  ? ((ti.tz -= 1), (ti.c1 = this.preHeights[8] * (1 - ti.tx) + this.preHeights[9] * ti.tx), (ti.c2 = this.preHeights[12] * (1 - ti.tx) + this.preHeights[13] * ti.tx))
                                  : ((ti.c1 = this.preHeights[4] * (1 - ti.tx) + this.preHeights[5] * ti.tx), (ti.c2 = this.preHeights[8] * (1 - ti.tx) + this.preHeights[9] * ti.tx)))
                            : ti.tx > 1
                            ? ((ti.tx -= 1),
                              ti.tz < 0
                                  ? ((ti.tz += 1), (ti.c1 = this.preHeights[2] * (1 - ti.tx) + this.preHeights[3] * ti.tx), (ti.c2 = this.preHeights[6] * (1 - ti.tx) + this.preHeights[7] * ti.tx))
                                  : ti.tz > 1
                                  ? ((ti.tz -= 1), (ti.c1 = this.preHeights[10] * (1 - ti.tx) + this.preHeights[11] * ti.tx), (ti.c2 = this.preHeights[14] * (1 - ti.tx) + this.preHeights[15] * ti.tx))
                                  : ((ti.c1 = this.preHeights[6] * (1 - ti.tx) + this.preHeights[7] * ti.tx), (ti.c2 = this.preHeights[10] * (1 - ti.tx) + this.preHeights[11] * ti.tx)))
                            : ti.tz < 0
                            ? ((ti.tz += 1), (ti.c1 = this.preHeights[1] * (1 - ti.tx) + this.preHeights[2] * ti.tx), (ti.c2 = this.preHeights[5] * (1 - ti.tx) + this.preHeights[6] * ti.tx))
                            : ti.tz > 1
                            ? ((ti.tz -= 1), (ti.c1 = this.preHeights[9] * (1 - ti.tx) + this.preHeights[10] * ti.tx), (ti.c2 = this.preHeights[13] * (1 - ti.tx) + this.preHeights[14] * ti.tx))
                            : ((ti.c1 = this.preHeights[5] * (1 - ti.tx) + this.preHeights[6] * ti.tx), (ti.c2 = this.preHeights[9] * (1 - ti.tx) + this.preHeights[10] * ti.tx)),
                        ti.c1 * (1 - ti.tz) + ti.c2 * ti.tz
                    );
                }
                generate() {
                    if (!this.initialised) return (this.initialised = this.preInitialise()), !1;
                    if (this.genRow > this.res) return !0;
                    let e, t, i, s, n, a, o, r, h;
                    (this.genIndex = this.genRow * (this.res + 1) * 3), (r = (this.genRow / this.res) * 10);
                    for (let l = 0; l <= this.res; l++)
                        (h = (l / this.res) * 10),
                            (e = this.genIndex + 3 * l),
                            (t = e / 3),
                            (a = r + this.originPos.x),
                            (o = h + this.originPos.z),
                            (n = _t(a, o, this.originNode, 1 == this.lod)),
                            (n.e = Ht + Math.abs(n.da)),
                            (this.signedRoadProx[t] = n.d - (n.w + n.e)),
                            (i = n.d - n.w),
                            (s = this.lerpHeight(a, o, n)),
                            this.isDebug && console.log(n.t, n.n.h, n.n.gfa, n.n.next.gfa),
                            (this.heights[t] = s),
                            (this.roadProx[t] = i),
                            (this.treeMask[t] = 0),
                            (this.verts[e] = a - this.tileset.origin.x),
                            (this.verts[e + 1] = s - this.tileset.origin.y),
                            (this.verts[e + 2] = o - this.tileset.origin.z);
                    return (
                        this.genRow > 0 && (this.computeSquareNormalsRow(this.genRow - 1), this.postProcessRow(this.genRow - 1)),
                        this.genRow++,
                        this.genRow > this.res &&
                            (this.computeSquareNormalsRow(this.genRow - 1),
                            (this.centroid.y = (this.heights[0] + this.heights[this.res] + this.heights[this.res * this.res1] + this.heights[this.res1 * this.res + this.res]) / 4),
                            this.centroid.sub(this.tileset.origin),
                            this.postProcessRow(this.genRow - 1),
                            this.postProcessCell()),
                        this.genRow > this.res
                    );
                }
                postProcessRow(e) {}
                postProcessCell() {}
                computeSquareNormalsRow(e) {
                    let t,
                        i,
                        s,
                        n,
                        a,
                        o,
                        h,
                        l,
                        d,
                        c,
                        p = zt / this.res,
                        u = 2 * p,
                        g = new r.W(),
                        m = new r.W();
                    for (d = e * this.res1, t = 0; t <= this.res; t++) {
                        (o = e * p + this.originPos.x),
                            (h = t * p + this.originPos.z),
                            0 == t ? ((o = e * p + this.originPos.x), (h = this.originPos.z - p), (l = _t(o, h, this.originNode, 1 == this.lod)), (n = this.lerpHeight(o, h, l))) : (n = this.heights[d + (t - 1)]),
                            t == this.res ? ((o = e * p + this.originPos.x), (h = this.originPos.z + (t + 1) * p), (l = _t(o, h, this.originNode, 1 == this.lod)), (a = this.lerpHeight(o, h, l))) : (a = this.heights[d + (t + 1)]),
                            0 == e ? ((o = this.originPos.x - p), (h = t * p + this.originPos.z), (l = _t(o, h, this.originNode, 1 == this.lod)), (i = this.lerpHeight(o, h, l))) : (i = this.heights[(e - 1) * this.res1 + t]),
                            e == this.res
                                ? ((o = (e + 1) * p + this.originPos.x), (h = t * p + this.originPos.z), (l = _t(o, h, this.originNode, 1 == this.lod)), (s = this.lerpHeight(o, h, l)))
                                : (s = this.heights[(e + 1) * this.res1 + t]),
                            g.set(u, s - i, 0),
                            m.set(0, a - n, u),
                            g.cross(m).normalize().negate(),
                            (c = 3 * (d + t)),
                            (this.norms[c] = g.x),
                            (this.norms[c + 1] = g.y),
                            (this.norms[c + 2] = g.z);
                        let r = e / this.res1,
                            x = t / this.res1,
                            v = this.preCurves[0] * (1 - r) + this.preCurves[1] * r,
                            f = this.preCurves[2] * (1 - r) + this.preCurves[3] * r;
                        (this.curves[d + t] = v * (1 - x) + f * x), (this.grads[d + t] = 1 - Math.abs(g.dot(ei)));
                    }
                }
                precomputeHeights() {
                    this.preHeights.length = 0;
                    let e,
                        t,
                        i = this.originPos.x,
                        s = this.originPos.z;
                    for (t = -1; t < 3; t++) for (e = -1; e < 3; e++) this.preHeights.push(this.heightmap.getXZ(i + 10 * e, s + 10 * t));
                }
                precomputeCurvature() {
                    let e = this.originPos.x,
                        t = this.originPos.z;
                    this.getCurvature(e, t), this.getCurvature(e + 10, t), this.getCurvature(e, t + 10), this.getCurvature(e + 10, t + 10);
                }
                getCurvature(e, t, i = 5) {
                    let s = this.heightmap.getXZLayer(e - i, t, 0) + this.heightmap.getXZLayer(e + i, t, 0) + this.heightmap.getXZLayer(e, t - i, 0) + this.heightmap.getXZLayer(e, t + i, 0);
                    (s = s / 4 - this.heightmap.getXZ(e, t)), this.preCurves.push(0.02 * s);
                }
                display(e = !1) {
                    (this.active = !0), this.tileset.tileReady(this.tileIndex, this.verts, this.norms, this.curves, this.roadProx, this.treeMask, this.centroid, e);
                }
                show() {
                    this.tileset.draw(), (this.active = !0);
                }
                hide() {
                    this.active = !1;
                }
                retire() {
                    this.tileset.hideTile(this.tileIndex), (this.retired = !0);
                }
            }
            var si = ii;
            class ni extends r.g {
                constructor(e, t) {
                    super();
                    let i,
                        s,
                        n,
                        a,
                        o = [],
                        h = [],
                        l = [],
                        d = [];
                    (this.res = e), (this.size = t), (this.count = (e + 1) * (e + 1));
                    for (let r = 0; r <= e; r++)
                        for (let c = 0; c <= e; c++)
                            o.push((r / e) * t, 0, (c / e) * t),
                                l.push(0),
                                r < e && c < e && ((i = r * (e + 1) + c), (s = r * (e + 1) + (c + 1)), (n = (r + 1) * (e + 1) + c), (a = (r + 1) * (e + 1) + (c + 1)), h.push(i, s, n), h.push(s, a, n)),
                                d.push(0);
                    this.setIndex(h),
                        this.setAttribute("position", new r.o(new Float32Array(o), 3)),
                        this.setAttribute("heightOffset", new r.o(new Float32Array(l), 1)),
                        this.attributes.heightOffset.setUsage(r.l),
                        this.setAttribute("normal", new r.o(new Float32Array(o.length), 3)),
                        this.attributes.normal.setUsage(r.l),
                        this.setAttribute("curvature", new r.o(new Float32Array(d), 1)),
                        this.attributes.curvature.setUsage(r.l);
                }
                computeBoundingSphere() {
                    null == this.boundingSphere && (this.boundingSphere = new r.R(new r.W(), 0));
                    const e = this.attributes.position.array,
                        t = this.attributes.heightOffset.array;
                    let i = e.length,
                        s = t.length,
                        n = e[i - 3] - e[0],
                        a = t[s - 1] - t[0],
                        o = e[i - 1] - e[2],
                        h = n * n + a * a + o * o,
                        l = this.res * (this.res + 1),
                        d = this.res,
                        c = 3 * l,
                        p = 3 * d;
                    (n = e[p] - e[c]), (a = t[d] - t[l]), (o = e[p + 2] - e[c + 2]);
                    let u = n * n + a * a + o * o;
                    u > h
                        ? ((this.boundingSphere.radius = Math.sqrt(u) / 2), this.boundingSphere.center.set((e[c] + e[p]) / 2, (t[l] + t[d]) / 2, (e[c + 2] + e[p + 2]) / 2))
                        : ((this.boundingSphere.radius = Math.sqrt(h) / 2), this.boundingSphere.center.set((e[0] + e[i - 3]) / 2, (t[0] + t[s - 1]) / 2, (e[2] + e[i - 1]) / 2)),
                        isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                }
                computeTriangleNormals() {
                    const e = this.index,
                        t = this.attributes.position,
                        i = this.attributes.normal,
                        s = new r.W(),
                        n = new r.W(),
                        a = new r.W(),
                        o = new r.W(),
                        h = new r.W(),
                        l = new r.W(),
                        d = new r.W(),
                        c = new r.W();
                    let p, u, g;
                    for (let r = 0, m = e.count; r < m; r += 3)
                        (p = e.getX(r + 0)),
                            (u = e.getX(r + 1)),
                            (g = e.getX(r + 2)),
                            s.fromBufferAttribute(t, p),
                            n.fromBufferAttribute(t, u),
                            a.fromBufferAttribute(t, g),
                            d.subVectors(a, n),
                            c.subVectors(s, n),
                            d.cross(c),
                            o.fromBufferAttribute(i, p),
                            h.fromBufferAttribute(i, u),
                            l.fromBufferAttribute(i, g),
                            o.add(d),
                            h.add(d),
                            l.add(d),
                            i.setXYZ(p, o.x, o.y, o.z),
                            i.setXYZ(u, h.x, h.y, h.z),
                            i.setXYZ(g, l.x, l.y, l.z);
                    this.normalizeNormals(), (this.attributes.normal.needsUpdate = !0);
                }
            }
            const ai = new r.W(0, 1, 0),
                oi = { vecV: new r.W(), vecH: new r.W() };
            var ri = class {
                constructor(e, t) {
                    (this.isDebug = !1),
                        (this.genRow = 0),
                        (this.genIndex = 0),
                        (this.nodeIndex = 0),
                        (this.latestIndex = 0),
                        (this.overlapIndex = 0),
                        (this.overlapCells = []),
                        (this.needsOverlapRedraw = !1),
                        (this.ready = !1),
                        (this.originNode = null),
                        (this.exitNode = null),
                        (this.isDebug = !1),
                        (this.res = yt),
                        (this.res1 = this.res + 1),
                        (this.res3 = 3 * this.res1),
                        (this.size = At),
                        (this.heightmap = e),
                        (this.heights = []),
                        (this.grads = []),
                        (this.geo = new ni(this.res, this.size)),
                        (this.ground = new r.B(this.geo, t)),
                        (this.verts = this.geo.attributes.position.array),
                        (this.heightOffsets = this.geo.attributes.heightOffset.array),
                        (this.mesh = new r.G()),
                        (this.mesh.matrixAutoUpdate = !1),
                        (this.mesh.renderOrder = 10),
                        this.mesh.add(this.ground),
                        (this.mesh.visible = !1);
                }
                initGeneration(e, t, i, s, n, a, o = !1) {
                    this.hide(),
                        (this.originNode = i),
                        (this.exitNode = s),
                        (this.originCoords = { x: e, z: t }),
                        (this.originPos = { x: e * this.size, y: 0, z: t * this.size }),
                        (this.heightmap = a),
                        this.mesh.position.copy(this.originPos),
                        (this.needsOverlapRedraw = o),
                        (this.genRow = 0),
                        (this.genIndex = 0),
                        (this.overlapIndex = 0),
                        (this.overlapCells.length = 0),
                        (this.overlapTile = null),
                        n && ((this.overlapTile = n), (this.overlapCells = Object.keys(this.overlapTile))),
                        (this.originPos.y = this.heightmap.getXZ(this.originPos.x, this.originPos.z)),
                        (this.mesh.position.y = this.originPos.y),
                        (this.isDebug = !1),
                        (this.ready = !1);
                }
                resetOverlapMap(e, t) {
                    (this.exitNode = e), (this.overlapIndex = 0), (this.overlapCells.length = 0), (this.overlapTile = null), t && ((this.overlapTile = t), (this.overlapCells = Object.keys(this.overlapTile)));
                }
                forceGenerate() {
                    for (; !this.generate(); );
                    this.display();
                }
                generate() {
                    if (this.genRow <= this.res) {
                        for (this.genIndex = this.genRow * this.res1 * 3, oi.i = 0; oi.i <= this.res; oi.i++)
                            (oi.index = this.genIndex + 3 * oi.i),
                                (oi.index3 = this.genRow * this.res1 + oi.i),
                                (oi.x = this.verts[oi.index] + this.originPos.x),
                                (oi.z = this.verts[oi.index + 2] + this.originPos.z),
                                (oi.h = this.heightmap.getXZ(oi.x, oi.z)),
                                (this.heights[oi.index3] = oi.h),
                                (this.heightOffsets[oi.index3] = oi.h - this.mesh.position.y);
                        return (
                            this.genRow > 0 && this.computeSquareNormalsRow(this.genRow - 1),
                            this.genRow++,
                            this.genRow > this.res && (this.computeSquareNormalsRow(this.genRow - 1), (this.geo.attributes.normal.needsUpdate = !0), (this.geo.attributes.curvature.needsUpdate = !0)),
                            !1
                        );
                    }
                    if (this.overlapIndex < this.overlapCells.length) {
                        for (oi.oz in ((oi.ox = this.overlapCells[this.overlapIndex]), this.overlapTile[oi.ox]))
                            this.overlapTile[oi.ox][oi.oz] < 0 || ((oi.index = oi.ox * this.res1 + 1 * oi.oz), (this.heightOffsets[oi.index] = this.heights[oi.index] - this.mesh.position.y - (6 + 2.5 * this.overlapTile[oi.ox][oi.oz])));
                        return this.overlapIndex++, !1;
                    }
                    return this.mesh.visible && this.display(), (this.ready = !0), !0;
                }
                lookupHeight(e, t) {
                    return e < 0 || e > At || t < 0 || t > At
                        ? this.heightmap.getXZ(this.originPos.x + e, this.originPos.z + t)
                        : ((oi.cx = Math.max(e / 10, 0)),
                          (oi.cz = Math.max(t / 10, 0)),
                          (oi.ix = Math.min(yt - 1, Math.floor(oi.cx))),
                          (oi.iz = Math.min(yt - 1, Math.floor(oi.cz))),
                          (oi.index = this.res1 * oi.ix + oi.iz),
                          (oi.px = oi.cx - oi.ix),
                          (oi.pz = oi.cz - oi.iz),
                          (oi.hx = this.heights[oi.index] * (1 - oi.px) + this.heights[oi.index + this.res1] * oi.px),
                          (oi.hz = this.heights[oi.index + 1] * (1 - oi.px) + this.heights[oi.index + this.res1 + 1] * oi.px),
                          oi.hx * (1 - oi.pz) + oi.hz * oi.pz);
                }
                display(e = !1) {
                    if (e && !this.ready) for (; !this.generate(); );
                    (this.geo.attributes.heightOffset.needsUpdate = !0), this.geo.computeBoundingSphere(), this.mesh.updateMatrix(), this.show();
                }
                retire() {
                    this.hide();
                }
                show() {
                    this.mesh.visible = !0;
                }
                hide() {
                    this.mesh.visible = !1;
                }
                computeSquareNormalsRow(e) {
                    for (oi.d = At / this.res, oi.d2 = 2 * oi.d, oi.normalAttribute = this.geo.attributes.normal, oi.curvatureAttribute = this.geo.attributes.curvature, oi.rowIndex = e * this.res1, oi.j = 0; oi.j <= this.res; oi.j++)
                        (oi.hAvg = 0),
                            (oi.tX = e * oi.d + this.originPos.x),
                            (oi.tZ = oi.j * oi.d + this.originPos.z),
                            (oi.hAvg += this.heightmap.getXZLayer(oi.tX + 5, oi.tZ, 0)),
                            (oi.hAvg += this.heightmap.getXZLayer(oi.tX - 5, oi.tZ, 0)),
                            (oi.hAvg += this.heightmap.getXZLayer(oi.tX, oi.tZ + 5, 0)),
                            (oi.hAvg += this.heightmap.getXZLayer(oi.tX, oi.tZ - 5, 0)),
                            (oi.hAvg = oi.hAvg / 4 - this.heights[oi.rowIndex + oi.j]),
                            0 == oi.j ? ((oi.tX = e * oi.d + this.originPos.x), (oi.tZ = this.originPos.z - oi.d), (oi.left = this.heightmap.getXZ(oi.tX, oi.tZ))) : (oi.left = this.heights[oi.rowIndex + (oi.j - 1)]),
                            oi.j == this.res ? ((oi.tX = e * oi.d + this.originPos.x), (oi.tZ = this.originPos.z + (oi.j + 1) * oi.d), (oi.right = this.heightmap.getXZ(oi.tX, oi.tZ))) : (oi.right = this.heights[oi.rowIndex + (oi.j + 1)]),
                            0 == e ? ((oi.tX = this.originPos.x - oi.d), (oi.tZ = oi.j * oi.d + this.originPos.z), (oi.up = this.heightmap.getXZ(oi.tX, oi.tZ))) : (oi.up = this.heights[(e - 1) * this.res1 + oi.j]),
                            e == this.res ? ((oi.tX = (e + 1) * oi.d + this.originPos.x), (oi.tZ = oi.j * oi.d + this.originPos.z), (oi.down = this.heightmap.getXZ(oi.tX, oi.tZ))) : (oi.down = this.heights[(e + 1) * this.res1 + oi.j]),
                            oi.vecV.set(oi.d2, oi.down - oi.up, 0),
                            oi.vecH.set(0, oi.right - oi.left, oi.d2),
                            oi.vecV.cross(oi.vecH).normalize().negate(),
                            oi.normalAttribute.setXYZ(oi.rowIndex + oi.j, oi.vecV.x, oi.vecV.y, oi.vecV.z),
                            (this.grads[oi.rowIndex + oi.j] = 1 - Math.abs(oi.vecV.dot(ai))),
                            (oi.curvatureAttribute.array[oi.rowIndex + oi.j] = 0.02 * oi.hAvg);
                }
            };
            class hi {
                constructor() {
                    (this.nearGridCell = si), (this.farGridCell = ri);
                }
                sanitiseConfig(e) {
                    this.skinList.includes(e.value.skin) || (console.log("Scene config not compatible; reverting to default skin"), e.set("skin", "default", !0), e.set("weatherIndex", 0, !0));
                }
                loader() {
                    return 1;
                }
                updateConfig(e, t) {}
                reset(e, t, i) {
                    this.initialise(e, t, i);
                }
                initialise(e, t, i) {
                    (this.seed = e), i();
                }
                onMidlineReady() {}
                onGridReady() {}
                nextWeather() {}
                setScene(e) {}
                setWeather(e) {}
                nextSkin() {}
                nextTopography() {}
                prepareGeometry() {}
                update() {}
                destroy() {}
            }
            (hi.sceneName = "Scene"), (hi.hasTrees = !0), (hi.hasGrass = !0);
            var li = class {
                constructor(e) {
                    this.rand = new window.alea(e || Be);
                }
                generate() {}
                getXZ(e, t) {
                    return 0;
                }
                getCell(e, t) {
                    return (
                        e in this.cacheAccess || (this.cacheAccess[e] = {}),
                        (this.cacheAccess[e][t] = !0),
                        (this.cache[e] && this.cache[e][t]) || this.cacheCell(e, t),
                        e in this.cacheAccess || (this.cacheAccess[e] = {}),
                        (this.cacheAccess[e][t] = !0),
                        this.cache[e][t]
                    );
                }
                clearCache() {
                    if (this.cacheCount <= this.maxCached) return;
                    let e, t;
                    for (e in this.cache) {
                        for (t in this.cache[e])
                            if (this.cacheAccess[e][t]) this.cacheAccess[e][t] = !1;
                            else if ((delete this.cache[e][t], delete this.cacheAccess[e][t], this.cacheCount--, this.cacheCount <= this.maxCached)) break;
                        if (this.cacheCount <= this.maxCached) break;
                    }
                }
                generateCell(e, t) {
                    return [];
                }
                cacheCell(e, t) {
                    this.cacheCount++, this.clearCache();
                    let i = this.generateCell(e, t);
                    e in this.cache || (this.cache[e] = {}), (this.cache[e][t] = i);
                }
                destroy() {}
            };
            const di = "Hanne!",
                ci = { layer: 0, d: 0, h: 0, sq: 0, sqb: 0, wx: 0, wz: 0, ox: 0, oz: 0, px: 0, pz: 0, cell: null, ix: 0, iz: 0, depth: 0 },
                pi = { ...ci },
                ui = {};
            var gi = class extends li {
                    constructor(...e) {
                        super(...e),
                            (this.resolution = 5),
                            (this.depth = 3),
                            (this.upscale = 2),
                            (this.heightScale = 1),
                            (this.heightOffset = 0),
                            (this.upscaleType = 0),
                            (this.controls = []),
                            (this.cache = {}),
                            (this.cacheAccess = {}),
                            (this.cacheCount = 0),
                            (this.maxCached = 9),
                            (this.qCache = {}),
                            (this.smoothingFunc = () => {}),
                            (this.useQuick = !1);
                        let t = e[1] || {};
                        switch (
                            (null !== t.heightScale && (this.heightScale = t.heightScale),
                            null !== t.resolution && (this.resolution = t.resolution),
                            (this.seed = e[0] || di),
                            (this.depth = t.depth || 3),
                            (this.radiusType = null == t.radiusType ? 1 : t.radiusType),
                            (this.upscale = t.upscale || 2),
                            (this.upscaleType = null == t.upscaleType ? 0 : t.upscaleType),
                            (this.upscaleFactor = null == t.upscaleFactor ? 2 : t.upscaleFactor),
                            (this.squared = t.squared || !1),
                            (this.compound = t.compound || !1),
                            (this.depthHeightFactor = t.depthHeightFactor || 1),
                            (this.smoothLerpIndex = null == t.smoothLerp ? 2 : t.smoothLerp),
                            this.smoothLerpIndex)
                        ) {
                            case 2:
                                this.smoothingFunc = this.smootherLerp;
                                break;
                            case 1:
                                this.smoothingFunc = this.smoothLerp;
                                break;
                            case 0:
                            default:
                                this.smoothingFunc = this.sharpLerp;
                        }
                        if (null != t.resolutions) (this.resolutions = t.resolutions), (this.resolution = this.resolutions[0]), (this.depth = this.resolutions.length);
                        else {
                            this.resolutions = [this.resolution];
                            for (let e = 0; e < this.depth - 1; e++) this.resolutions.push(this.calculateNextDepthResolution(this.resolutions[e], e));
                        }
                        (this.controls = []), (this.cellScaleMetres = 1e3), (this.cellScaleWorld = 3e3), (this.heightOffset = t.heightOffset), this.cacheCell(0, 0);
                    }
                    cosLerp(e) {
                        return Math.cos(3.1415 * e) + 1;
                    }
                    sharpLerp(e) {
                        return 1 - e;
                    }
                    smoothLerp(e) {
                        return -1 * (3 - 2 * e) * e * e + 1;
                    }
                    smootherLerp(e) {
                        return (e * (6 * e - 15) + 10) * e * e * e * -1 + 1;
                    }
                    sharpLerpAB(e, t, i) {
                        return (t - e) * i + e;
                    }
                    smootherLerpAB(e, t, i) {
                        return (i * (6 * i - 15) + 10) * i * i * i * (t - e) + e;
                    }
                    lerpHeight(e, t, i, s) {
                        return (e = (s.x - t) * (s.x - t) + (s.z - i) * (s.z - i)) < s.r2 ? this.smoothingFunc(e / s.r2) * s.y : 0;
                    }
                    clearCache() {
                        if (!(this.cacheCount <= this.maxCached))
                            for (ui.ox in this.cache) {
                                for (ui.oz in this.cache[ui.ox])
                                    if (this.cacheAccess[ui.ox][ui.oz]) this.cacheAccess[ui.ox][ui.oz] = !1;
                                    else if ((delete this.cache[ui.ox][ui.oz], delete this.cacheAccess[ui.ox][ui.oz], this.cacheCount--, this.cacheCount <= this.maxCached)) break;
                                if (this.cacheCount <= this.maxCached) break;
                            }
                    }
                    cacheCell(e, t) {
                        for (
                            this.cacheCount++, this.clearCache(), ui.cell = [], ui.hFactor = 1, ui.rand = new window.alea(this.seed + e + t), ui.depthRes = this.resolution, ui.layer = [], ui.dhf = this.depthHeightFactor, ui.d = 0;
                            ui.d < this.depth;
                            ui.d++
                        ) {
                            for (ui.depthRes = this.resolutions[ui.d], ui.hFactor = (this.resolution / ui.depthRes) * ui.dhf, ui.dhf *= this.depthHeightFactor, ui.layer = [], ui.rad = 1 / ui.depthRes, ui.i = 0; ui.i < ui.depthRes; ui.i++) {
                                for (ui.subLayer = [], ui.j = 0; ui.j < ui.depthRes; ui.j++)
                                    (ui.h = 2 * ui.rand() - 1),
                                        this.squared && (ui.h < 0 ? (ui.h *= -ui.h * (1 + ui.h) * 4) : (ui.h *= ui.h * (1 - ui.h) * 4)),
                                        (ui.h *= ui.hFactor),
                                        ui.subLayer.push({ x: (ui.i + 0.5) / ui.depthRes, y: ui.h * this.heightScale, z: (ui.j + 0.5) / ui.depthRes, r: ui.rad, r2: ui.rad * ui.rad });
                                ui.layer.push(ui.subLayer);
                            }
                            ui.cell.push(ui.layer);
                        }
                        e in this.cache || (this.cache[e] = {}), (this.cache[e][t] = ui.cell);
                    }
                    calculateNextDepthResolution(e, t) {
                        switch (this.upscaleType) {
                            case 5:
                                let i,
                                    s = this.resolution,
                                    n = this.resolution;
                                for (let e = 0; e < t + 1; e++) (i = s + n), (n = s), (s = i);
                                return i;
                            case 4:
                                return e * this.upscaleFactor + (t + 1);
                            case 3:
                                return Math.round(e * this.upscaleFactor);
                            case 2:
                                return Math.pow(this.resolution, t + 2);
                            case 1:
                                return this.resolution + Math.pow(this.upscale, t + 1);
                            case 0:
                            default:
                                return e + this.upscale * (t + 1);
                        }
                    }
                    getNextDepthResolution(e, t) {
                        return this.resolutions[t + 1];
                    }
                    getResolution(e, t) {
                        return this.resolutions[t];
                    }
                    getNode(e, t, i, s) {}
                    getCell(e, t) {
                        return (
                            e in this.cacheAccess || (this.cacheAccess[e] = {}),
                            (this.cacheAccess[e][t] = !0),
                            (this.cache[e] && this.cache[e][t]) || this.cacheCell(e, t),
                            e in this.cacheAccess || (this.cacheAccess[e] = {}),
                            (this.cacheAccess[e][t] = !0),
                            this.cache[e][t]
                        );
                    }
                    getQuickCell(e, t) {
                        return (
                            (this.cache[e] && this.cache[e][t]) || this.cacheCell(e, t),
                            e in this.cacheAccess || (this.cacheAccess[e] = {}),
                            (this.cacheAccess[e][t] = !0),
                            (this.qCache[e] && this.qCache[e][t]) || this.quickCache(e, t, this.cache[e][t][this.depth - 1]),
                            this.qCache[e][t]
                        );
                    }
                    quickCache(e, t, i) {
                        if (e in this.qCache) {
                            if (t in this.qCache[e]) return;
                        } else this.qCache[e] = {};
                        let s = [];
                        this.useQuick = !1;
                        for (let n of i) {
                            let i = [];
                            for (let s of n) i.push({ x: s.x, y: this.getXZ((e + s.x) * this.cellScaleWorld, (t + s.z) * this.cellScaleWorld), z: s.z, r: s.r, r2: s.r2 });
                            s.push(i);
                        }
                        (this.useQuick = !0), (this.qCache[e][t] = s);
                    }
                    getXZQuick(e, t) {
                        let i, s, n, a, o, r;
                        return (
                            (pi.d = 0),
                            (pi.h = 0),
                            (pi.wx = e / this.cellScaleWorld),
                            (pi.wz = t / this.cellScaleWorld),
                            (pi.ox = Math.floor(pi.wx)),
                            (pi.oz = Math.floor(pi.wz)),
                            (pi.px = pi.wx - pi.ox),
                            (pi.pz = pi.wz - pi.oz),
                            (pi.layer = this.getQuickCell(pi.ox, pi.oz)),
                            (pi.sq = this.getResolution(this.resolution, this.depth - 1)),
                            (pi.sqb = pi.sq - 1),
                            (pi.ssq = pi.sq),
                            (pi.ssqb = pi.sqb),
                            (i = pi.px * pi.sq - 0.5),
                            (pi.ix = Math.floor(pi.px * pi.sq - 0.5)),
                            (s = pi.pz * pi.sq - 0.5),
                            (pi.iz = Math.floor(pi.pz * pi.sq - 0.5)),
                            (i -= pi.ix),
                            (s -= pi.iz),
                            pi.ix >= 0
                                ? ((n = pi.iz >= 0 ? pi.layer[pi.ix][pi.iz].y : this.getQuickCell(pi.ox, pi.oz - 1)[pi.ix][pi.sqb].y), (a = pi.iz < pi.ssqb ? pi.layer[pi.ix][pi.iz + 1].y : this.getQuickCell(pi.ox, pi.oz + 1)[pi.ix][0].y))
                                : ((n = pi.iz >= 0 ? this.getQuickCell(pi.ox - 1, pi.oz)[pi.sqb][pi.iz].y : this.getQuickCell(pi.ox - 1, pi.oz - 1)[pi.sqb][pi.sqb].y),
                                  (a = pi.iz < pi.ssqb ? this.getQuickCell(pi.ox - 1, pi.oz)[pi.sqb][pi.iz + 1].y : this.getQuickCell(pi.ox - 1, pi.oz + 1)[pi.sqb][0].y)),
                            pi.ix < pi.ssqb
                                ? ((o = pi.iz >= 0 ? pi.layer[pi.ix + 1][pi.iz].y : this.getQuickCell(pi.ox, pi.oz - 1)[pi.ix + 1][pi.sqb].y),
                                  (r = pi.iz < pi.ssqb ? pi.layer[pi.ix + 1][pi.iz + 1].y : this.getQuickCell(pi.ox, pi.oz + 1)[pi.ix + 1][0].y))
                                : ((o = pi.iz >= 0 ? this.getQuickCell(pi.ox + 1, pi.oz)[0][pi.iz].y : this.getQuickCell(pi.ox + 1, pi.oz - 1)[0][pi.sqb].y),
                                  (r = pi.iz < pi.ssqb ? this.getQuickCell(pi.ox + 1, pi.oz)[0][pi.iz + 1].y : this.getQuickCell(pi.ox + 1, pi.oz + 1)[0][0].y)),
                            (n = this.sharpLerpAB(n, a, s)),
                            (o = this.sharpLerpAB(o, r, s)),
                            this.sharpLerpAB(n, o, i)
                        );
                    }
                    getXZLayer(e, t, i) {
                        (ci.layer = 0),
                            (ci.d = 0),
                            (ci.h = 0),
                            (ci.sq = this.resolution),
                            (ci.sqb = ci.sq - 1),
                            (ci.wx = e / this.cellScaleWorld),
                            (ci.wz = t / this.cellScaleWorld),
                            (ci.ox = Math.floor(ci.wx)),
                            (ci.oz = Math.floor(ci.wz)),
                            (ci.px = ci.wx - ci.ox),
                            (ci.pz = ci.wz - ci.oz),
                            (ci.cell = this.getCell(ci.ox, ci.oz));
                        let s = this.depth;
                        ci.depth = 0;
                        let n = 0;
                        for (ci.layer of ci.cell)
                            if (n++ === i) {
                                if (ci.depth == s) break;
                                (ci.ix = Math.floor(ci.px * ci.sq - 0.5)),
                                    (ci.iz = Math.floor(ci.pz * ci.sq - 0.5)),
                                    (ci.th = 0),
                                    ci.ix >= 0
                                        ? (ci.iz >= 0 ? (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz, ci.layer[ci.ix][ci.iz])) : (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz + 1, this.getCell(ci.ox, ci.oz - 1)[ci.depth][ci.ix][ci.sqb])),
                                          ci.iz < ci.sqb ? (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz, ci.layer[ci.ix][ci.iz + 1])) : (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz - 1, this.getCell(ci.ox, ci.oz + 1)[ci.depth][ci.ix][0])))
                                        : (ci.iz >= 0
                                              ? (ci.th += this.lerpHeight(ci.d, ci.px + 1, ci.pz, this.getCell(ci.ox - 1, ci.oz)[ci.depth][ci.sqb][ci.iz]))
                                              : (ci.th += this.lerpHeight(ci.d, ci.px + 1, ci.pz + 1, this.getCell(ci.ox - 1, ci.oz - 1)[ci.depth][ci.sqb][ci.sqb])),
                                          ci.iz < ci.sqb
                                              ? (ci.th += this.lerpHeight(ci.d, ci.px + 1, ci.pz, this.getCell(ci.ox - 1, ci.oz)[ci.depth][ci.sqb][ci.iz + 1]))
                                              : (ci.th += this.lerpHeight(ci.d, ci.px + 1, ci.pz - 1, this.getCell(ci.ox - 1, ci.oz + 1)[ci.depth][ci.sqb][0]))),
                                    ci.ix < ci.sqb
                                        ? (ci.iz >= 0
                                              ? (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz, ci.layer[ci.ix + 1][ci.iz]))
                                              : (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz + 1, this.getCell(ci.ox, ci.oz - 1)[ci.depth][ci.ix + 1][ci.sqb])),
                                          ci.iz < ci.sqb
                                              ? (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz, ci.layer[ci.ix + 1][ci.iz + 1]))
                                              : (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz - 1, this.getCell(ci.ox, ci.oz + 1)[ci.depth][ci.ix + 1][0])))
                                        : (ci.iz >= 0
                                              ? (ci.th += this.lerpHeight(ci.d, ci.px - 1, ci.pz, this.getCell(ci.ox + 1, ci.oz)[ci.depth][0][ci.iz]))
                                              : (ci.th += this.lerpHeight(ci.d, ci.px - 1, ci.pz + 1, this.getCell(ci.ox + 1, ci.oz - 1)[ci.depth][0][ci.sqb])),
                                          ci.iz < ci.sqb
                                              ? (ci.th += this.lerpHeight(ci.d, ci.px - 1, ci.pz, this.getCell(ci.ox + 1, ci.oz)[ci.depth][0][ci.iz + 1]))
                                              : (ci.th += this.lerpHeight(ci.d, ci.px - 1, ci.pz - 1, this.getCell(ci.ox + 1, ci.oz + 1)[ci.depth][0][0]))),
                                    (ci.h += ci.th),
                                    ci.depth++,
                                    (ci.sq = this.resolutions[ci.depth]),
                                    (ci.sqb = ci.sq - 1);
                            } else ci.depth++, (ci.sq = this.resolutions[ci.depth]), (ci.sqb = ci.sq - 1);
                        return ci.h + this.heightOffset;
                    }
                    getXZ(e, t, i) {
                        for (ci.layer of ((ci.d = 0),
                        (ci.h = 0),
                        (ci.heightFactor = 1),
                        (ci.sq = this.resolution),
                        (ci.sqb = ci.sq - 1),
                        (ci.wx = e / this.cellScaleWorld),
                        (ci.wz = t / this.cellScaleWorld),
                        (ci.ox = Math.floor(ci.wx)),
                        (ci.oz = Math.floor(ci.wz)),
                        (ci.px = ci.wx - ci.ox),
                        (ci.pz = ci.wz - ci.oz),
                        (ci.cell = this.getCell(ci.ox, ci.oz)),
                        (i = i || this.depth),
                        (ci.depth = 0),
                        ci.cell)) {
                            if (ci.depth == i) break;
                            (ci.ix = Math.floor(ci.px * ci.sq - 0.5)),
                                (ci.iz = Math.floor(ci.pz * ci.sq - 0.5)),
                                (ci.th = 0),
                                ci.ix >= 0
                                    ? (ci.iz >= 0 ? (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz, ci.layer[ci.ix][ci.iz])) : (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz + 1, this.getCell(ci.ox, ci.oz - 1)[ci.depth][ci.ix][ci.sqb])),
                                      ci.iz < ci.sqb ? (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz, ci.layer[ci.ix][ci.iz + 1])) : (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz - 1, this.getCell(ci.ox, ci.oz + 1)[ci.depth][ci.ix][0])))
                                    : (ci.iz >= 0
                                          ? (ci.th += this.lerpHeight(ci.d, ci.px + 1, ci.pz, this.getCell(ci.ox - 1, ci.oz)[ci.depth][ci.sqb][ci.iz]))
                                          : (ci.th += this.lerpHeight(ci.d, ci.px + 1, ci.pz + 1, this.getCell(ci.ox - 1, ci.oz - 1)[ci.depth][ci.sqb][ci.sqb])),
                                      ci.iz < ci.sqb
                                          ? (ci.th += this.lerpHeight(ci.d, ci.px + 1, ci.pz, this.getCell(ci.ox - 1, ci.oz)[ci.depth][ci.sqb][ci.iz + 1]))
                                          : (ci.th += this.lerpHeight(ci.d, ci.px + 1, ci.pz - 1, this.getCell(ci.ox - 1, ci.oz + 1)[ci.depth][ci.sqb][0]))),
                                ci.ix < ci.sqb
                                    ? (ci.iz >= 0
                                          ? (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz, ci.layer[ci.ix + 1][ci.iz]))
                                          : (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz + 1, this.getCell(ci.ox, ci.oz - 1)[ci.depth][ci.ix + 1][ci.sqb])),
                                      ci.iz < ci.sqb
                                          ? (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz, ci.layer[ci.ix + 1][ci.iz + 1]))
                                          : (ci.th += this.lerpHeight(ci.d, ci.px, ci.pz - 1, this.getCell(ci.ox, ci.oz + 1)[ci.depth][ci.ix + 1][0])))
                                    : (ci.iz >= 0
                                          ? (ci.th += this.lerpHeight(ci.d, ci.px - 1, ci.pz, this.getCell(ci.ox + 1, ci.oz)[ci.depth][0][ci.iz]))
                                          : (ci.th += this.lerpHeight(ci.d, ci.px - 1, ci.pz + 1, this.getCell(ci.ox + 1, ci.oz - 1)[ci.depth][0][ci.sqb])),
                                      ci.iz < ci.sqb
                                          ? (ci.th += this.lerpHeight(ci.d, ci.px - 1, ci.pz, this.getCell(ci.ox + 1, ci.oz)[ci.depth][0][ci.iz + 1]))
                                          : (ci.th += this.lerpHeight(ci.d, ci.px - 1, ci.pz - 1, this.getCell(ci.ox + 1, ci.oz + 1)[ci.depth][0][0]))),
                                (ci.temper = 1),
                                ci.depth > 0 && (ci.temper = Math.min(Math.max(0.25, (ci.h + this.heightOffset + 30) / 80), 1)),
                                (ci.h += ci.th * ci.temper),
                                ci.depth++,
                                (ci.sq = this.resolutions[ci.depth]),
                                (ci.sqb = ci.sq - 1);
                        }
                        return ci.h + this.heightOffset;
                    }
                },
                mi = i.p + "static/media/grass_summer_01.bb65c929.webp",
                xi = i.p + "static/media/gravel_01.72d5f86f.webp",
                vi = i.p + "static/media/rock_06.7e502144.webp",
                fi = i.p + "static/media/forest_summer_01.629b3e11.webp",
                wi = i.p + "static/media/heather_01.3b4049ea.webp",
                bi = i.p + "static/media/sand_01.8bf3d9a0.webp",
                Ai = i.p + "static/media/road_03.29415d96.webp",
                yi = i.p + "static/media/road_03_base.2e84c9f2.webp",
                Ii = i.p + "static/media/foliage_grass_summer.2ca20eaf.webp",
                Si = i.p + "static/media/foliage_bush_summer.7d19f331.webp",
                Mi = i.p + "static/media/trees_summer_far_04.9b418c41.webp",
                Di = i.p + "static/media/trees_summer_near_04.0b483335.webp",
                ki = i.p + "static/media/trees_summer_far_04b.71d33b5e.webp",
                Ci = i.p + "static/media/trees_summer_near_04b.c599bf59.webp",
                ji = i.p + "static/media/trees_autumn_near_01.e4b1c1b7.webp",
                Ni = i.p + "static/media/trees_autumn_far_01.476e1169.webp",
                zi = i.p + "static/media/trees_autumn_near_01b.784c372a.webp",
                Oi = i.p + "static/media/trees_autumn_far_01b.b7bc28be.webp",
                Li = i.p + "static/media/grass_autumn_01.c593833e.webp",
                Ri = i.p + "static/media/forest_autumn_01.cd958a6a.webp",
                Ti = i.p + "static/media/foliage_grass_autumn.f92557d8.webp",
                Pi = i.p + "static/media/foliage_bush_autumn.f642e219.webp",
                Gi = i.p + "static/media/trees_spring_near_01.2740d9e4.webp",
                Bi = i.p + "static/media/trees_spring_far_01.e5b43ddb.webp",
                Wi = i.p + "static/media/trees_spring_far_01b.77e3faf6.webp",
                Ei = i.p + "static/media/trees_spring_near_01b.dc9a1b07.webp",
                Fi = i.p + "static/media/grass_spring_01.768b870f.webp",
                Zi = i.p + "static/media/heather_spring_01.73869f54.webp",
                Hi = i.p + "static/media/foliage_grass_spring.2de5b784.webp",
                Qi = i.p + "static/media/foliage_bush_spring.53436f47.webp",
                Yi = i.p + "static/media/snow_01.5d24a4d9.webp",
                Vi = i.p + "static/media/forest_winter.d339edd9.webp",
                Ui = i.p + "static/media/road_04.c4c154ee.webp",
                Xi = i.p + "static/media/road_04_base.2ca13356.webp",
                Ji = i.p + "static/media/trees_winter_near_01.bc2b0a44.webp",
                qi = i.p + "static/media/trees_winter_far_01.22579e5a.webp",
                Ki = i.p + "static/media/trees_winter_near_01b.6c45b1e5.webp",
                _i = i.p + "static/media/trees_winter_far_01b.d995fc50.webp",
                $i = i.p + "static/media/rock_06_winter.1a82fc8c.webp",
                es = i.p + "static/media/foliage_brush_winter.3157e6a1.webp",
                ts = i.p + "static/media/concrete_01.467e237b.webp",
                is = i.p + "static/media/drystone_04.c9668f42.webp",
                ss = i.p + "static/media/drystone_04_snow.aee09a95.webp",
                ns = i.p + "static/media/wall_barrier_wood.06bbc7c3.webp",
                as = i.p + "static/media/wall_barrier_wood_snow.5df52f00.webp",
                os = i.p + "static/media/clouds_01b.d86e8361.webp",
                rs = i.p + "static/media/clouds_02.d765d208.webp",
                hs = i.p + "static/media/clouds_03.0544ea9f.webp",
                ls = i.p + "static/media/clouds_04.bdcd8039.webp",
                ds = i.p + "static/media/clouds_sunrise_b.76566df4.webp",
                cs = i.p + "static/media/clouds_autumn_sunset.97e16563.webp",
                ps = i.p + "static/media/clouds_winter_sunrise.10f858c5.webp",
                us = i.p + "static/media/ambiance_summer_low.2130513f.mp3",
                gs = i.p + "static/media/ambiance_cloudy.4d5b0a33.mp3",
                ms = i.p + "static/media/wind_02.deef0e2d.mp3",
                xs = i.p + "static/media/rock_06_bump.12f4b9f0.webp",
                vs = i.p + "static/media/crossfade_fine.0d1ec73b.webp",
                fs = i.p + "static/media/crossfade_finest.3013f964.webp";
            var ws = i.p + "static/media/sea_waves.fba92bab.webp";
            const bs = {
                    treemap: { heightScale: 1, heightOffset: 1.25, resolutions: [3, 13, 41], squared: !0, depthHeightFactor: 1.8, threshold: 0.3, threshold2: 0.6, threshold3: 0.65 },
                    topography: {
                        straight: { heightmap: { heightScale: 190, heightOffset: 80, resolutions: [3, 7], compound: !1, squared: !0, depthHeightFactor: 0.6 }, roadWidth: 3.2, smoothWindow: 7 },
                        casual: { heightmap: { heightScale: 160, heightOffset: 110, resolutions: [5], compound: !1, squared: !0, depthHeightFactor: 0.9 }, roadWidth: 3.2, smoothWindow: 7 },
                        normal: { heightmap: { heightScale: 160, heightOffset: 95, resolutions: [3, 12, 24], compound: !1, squared: !0, depthHeightFactor: 1 }, roadWidth: 3, smoothWindow: 7 },
                        hard: { heightmap: { heightScale: 165, heightOffset: 120, resolutions: [3, 12, 24, 36], compound: !1, squared: !0, depthHeightFactor: 0.98 }, roadWidth: 2.8, smoothWindow: 5 },
                        easy: { heightmap: { heightScale: 180, heightOffset: 110, resolutions: [3, 12], compound: !1, squared: !0, depthHeightFactor: 0.9 }, roadWidth: 3.2, smoothWindow: 7 },
                        flat: { heightmap: { heightScale: 0, heightOffset: 50, resolution: 1, depth: 1, upscale: 1 }, roadWidth: 20, smoothWindow: 7 },
                    },
                    weathers: {
                        default: {
                            audio: { ambiance: { src: us, ls: 0.1, le: 0.1 }, wind: { src: ms, ls: 0.07, le: 0.07 } },
                            water: 7048371,
                            waterSkyReflection: 10143703,
                            underwater: 4215398,
                            col: 16121855,
                            hemTop: 6710886,
                            hemGround: 16777215,
                            skyCol: 6859256,
                            skyColFar: 13368830,
                            skyMap: os,
                            amb: 0,
                            hem: 0.6,
                            dir: 0.9,
                            fogNear: 0.25,
                            fogFar: 1,
                            sunPos: [0, 100, 0],
                        },
                        clear: {
                            col: 15794175,
                            skyCol: 6859256,
                            skyColFar: 13368830,
                            hemTop: 13688285,
                            hemGround: 6317670,
                            water: 7048371,
                            waterSkyReflection: 10143703,
                            underwater: 4215398,
                            amb: 0.2,
                            hem: 0.2,
                            dir: 0.8,
                            fogNear: 0.5,
                            fogFar: 1,
                            sunPos: [0, 100, 0],
                        },
                        clearSpring: {
                            col: 16777200,
                            skyCol: 5815520,
                            skyColFar: 11599615,
                            hemTop: 12303274,
                            hemGround: 8947831,
                            water: 8034974,
                            waterSkyReflection: 10872550,
                            underwater: 4478295,
                            amb: 0,
                            hem: 0.6,
                            dir: 0.8,
                            fogNear: 0.1,
                            fogFar: 1,
                            sunPos: [0, 100, 0],
                        },
                        clearAutumn: {
                            col: 15794175,
                            skyCol: 6859256,
                            skyColFar: 13368830,
                            hemTop: 11582395,
                            hemGround: 8423560,
                            water: 7048371,
                            waterSkyReflection: 10143703,
                            underwater: 4281193,
                            amb: 0,
                            hem: 0.5,
                            dir: 0.7,
                            fogNear: 0.2,
                            fogFar: 1,
                            sunPos: [0, 100, 0],
                        },
                        clearSnow: {
                            col: 16645887,
                            skyCol: 6611189,
                            skyColFar: 9627639,
                            skyMap: null,
                            hemTop: 11582395,
                            hemGround: 10529450,
                            water: 9151142,
                            waterSkyReflection: 11592172,
                            underwater: 4213066,
                            amb: 0.4,
                            hem: 0,
                            dir: 0.6,
                            fogNear: -0.1,
                            fogFar: 1,
                        },
                        sunrise: {
                            col: 16760805,
                            skyCol: 14000311,
                            skyColFar: 15752863,
                            skyMap: ds,
                            hemTop: 16760805,
                            hemGround: 7825015,
                            water: 11240347,
                            waterSkyReflection: 13792927,
                            underwater: 4536640,
                            amb: 0,
                            hem: 0.4,
                            dir: 0.2,
                            fogNear: 0,
                            fogFar: 1,
                        },
                        springSunrise: {
                            col: 16763868,
                            skyCol: 14517675,
                            skyColFar: 16750020,
                            skyMap: ds,
                            hemTop: 16770028,
                            hemGround: 7825015,
                            water: 12682908,
                            waterSkyReflection: 14388399,
                            underwater: 4537407,
                            amb: 0,
                            hem: 0.5,
                            dir: 0.25,
                            fogNear: 0,
                            fogFar: 1,
                        },
                        autumnSunrise: {
                            col: 15191218,
                            skyCol: 12886223,
                            skyColFar: 12371399,
                            skyMap: null,
                            hemTop: 15191218,
                            water: 8285060,
                            waterSkyReflection: 9939630,
                            underwater: 3748667,
                            hemGround: 16777215,
                            amb: 0,
                            hem: 0.4,
                            dir: 0.1,
                            fogNear: 0.25,
                            fogFar: 1,
                        },
                        winterSunrise: {
                            col: 16641966,
                            skyCol: 7829367,
                            skyColFar: 13948336,
                            skyMap: ps,
                            hemTop: 13948336,
                            hemGround: 5592405,
                            water: 8158057,
                            waterSkyReflection: 13088880,
                            underwater: 4013366,
                            amb: 0,
                            hem: 0.5,
                            dir: 0.25,
                            fogNear: 0.25,
                            fogFar: 1,
                            particles: { colour: 12368284, half: !0, speed: 0.8 },
                        },
                        sunset: {
                            col: 16761489,
                            skyCol: 6611189,
                            skyColFar: 16769464,
                            skyMap: ls,
                            hemTop: 16772047,
                            hemGround: 7829367,
                            water: 10062204,
                            waterSkyReflection: 14595739,
                            underwater: 4209463,
                            amb: 0.2,
                            hem: 0.4,
                            dir: 0.3,
                            fogNear: 0,
                            fogFar: 1,
                        },
                        twilight: {
                            col: 10650820,
                            skyCol: 4539806,
                            skyColFar: 10387156,
                            skyMap: hs,
                            hemTop: 10650820,
                            hemGround: 6710886,
                            water: 4868728,
                            waterSkyReflection: 8152737,
                            underwater: 2829110,
                            amb: 0,
                            hem: 0.4,
                            dir: 0.2,
                            fogNear: 0,
                            fogFar: 1,
                            headlights: !0,
                        },
                        autumnSunset: {
                            col: 16767690,
                            skyCol: 7562623,
                            skyColFar: 13672883,
                            skyMap: cs,
                            hemTop: 15380673,
                            hemGround: 6710886,
                            water: 5984868,
                            waterSkyReflection: 13209736,
                            underwater: 3749181,
                            amb: 0,
                            hem: 0.5,
                            dir: 0.2,
                            fogNear: 0,
                            fogFar: 1,
                        },
                        winterSunset: {
                            col: 14849919,
                            skyCol: 15267574,
                            skyColFar: 16566188,
                            skyMap: null,
                            hemTop: 16433573,
                            hemGround: 6710886,
                            water: 6903885,
                            waterSkyReflection: 11903124,
                            underwater: 3353897,
                            amb: 0,
                            hem: 0.3,
                            dir: 0.1,
                            fogNear: 0,
                            fogFar: 1,
                            headlights: !0,
                        },
                        rain: {
                            audio: { ambiance: { src: gs, ls: 0.1, le: 0.1 } },
                            col: 11843770,
                            hemTop: 11183520,
                            hemGround: 6709334,
                            skyCol: 10988204,
                            skyColFar: 11843770,
                            skyMap: hs,
                            water: 7631213,
                            waterSkyReflection: 10330788,
                            underwater: 3552307,
                            amb: 0,
                            hem: 0.6,
                            dir: 0.5,
                            fogNear: 0,
                            fogFar: 1,
                            dynamicFog: !0,
                        },
                        springRain: {
                            audio: { ambiance: { src: gs, ls: 0.1, le: 0.1 } },
                            col: 13750208,
                            hemTop: 13421772,
                            hemGround: 8947848,
                            skyCol: 11381664,
                            skyColFar: 13421248,
                            skyMap: os,
                            water: 8159347,
                            waterSkyReflection: 12304304,
                            underwater: 3618868,
                            amb: 0,
                            hem: 0.6,
                            dir: 0.6,
                            fogNear: 0,
                            fogFar: 1,
                            dynamicFog: !0,
                        },
                        autumnRain: {
                            audio: { ambiance: { src: gs, ls: 0.1, le: 0.1 } },
                            col: 10262415,
                            hemTop: 16773350,
                            hemGround: 6709334,
                            skyCol: 9539465,
                            skyColFar: 10263189,
                            skyMap: rs,
                            water: 4670524,
                            waterSkyReflection: 7696744,
                            underwater: 2828839,
                            amb: 0,
                            hem: 0.5,
                            dir: 0.2,
                            fogNear: 0,
                            fogFar: 1,
                            dynamicFog: !0,
                        },
                        night: {
                            audio: { ambiance: { src: gs, ls: 0.1, le: 0.1 } },
                            col: 1184020,
                            skyCol: 1184020,
                            skyColFar: 1184020,
                            skyMap: rs,
                            water: 131332,
                            waterSkyReflection: 1184020,
                            underwater: 131332,
                            amb: 1.25,
                            hem: 0,
                            dir: 0,
                            fogNear: 0.1,
                            fogFar: 1,
                            headlights: !0,
                        },
                        nightSnow: {
                            audio: { ambiance: { src: gs, ls: 0.1, le: 0.1 } },
                            col: 1184020,
                            skyCol: 1184020,
                            skyColFar: 1184020,
                            skyMap: rs,
                            water: 131332,
                            waterSkyReflection: 1184020,
                            underwater: 131332,
                            amb: 1.25,
                            hem: 0,
                            dir: 0,
                            fogNear: 0,
                            fogFar: 0.5,
                            headlights: !0,
                            particles: { colour: 2236962, half: !1, speed: 1.75 },
                        },
                        snow: {
                            audio: { ambiance: { src: gs, ls: 0.1, le: 0.1 } },
                            col: 11772819,
                            skyCol: 11246985,
                            skyColFar: 11180677,
                            skyMap: hs,
                            water: 8353387,
                            waterSkyReflection: 10655879,
                            underwater: 3552048,
                            hemTop: 14275267,
                            hemGround: 6709334,
                            amb: 0,
                            hem: 0.6,
                            dir: 0.3,
                            fogNear: -0.1,
                            fogFar: 0.6,
                            dynamicFog: !0,
                            particles: { colour: 14406598, half: !1, speed: 1.25 },
                        },
                    },
                    skins: {
                        spring: {
                            name: "spring",
                            weathers: ["springSunrise", "clearSpring", "springRain", "autumnSunset", "night"],
                            cycles: [
                                ["clearSpring", "autumnSunset", "night", "night", "springSunrise"],
                                ["springRain", "autumnSunset", "night", "night", "springSunrise"],
                            ],
                            grass: Fi,
                            heather: Zi,
                            foliage: { trees: [Bi, Gi], treesb: [Wi, Ei], grass: Hi, bush: Qi, grassColouration: [20 / 255, 10 / 255, 20 / 255, 0], treeColouration: [-0.07, 0.1, 0.05, 0] },
                        },
                        default: {
                            name: "summer",
                            weathers: ["sunrise", "clear", "rain", "sunset", "night"],
                            cycles: [
                                ["clear", "sunset", "night", "night", "sunrise"],
                                ["rain", "sunset", "night", "night", "sunrise"],
                            ],
                            grass: mi,
                            gravel: xi,
                            rock: vi,
                            forest: fi,
                            heather: wi,
                            water: 11057343,
                            sand: bi,
                            road: Ai,
                            roadBase: yi,
                            walls: { sea: ts, fence: ns, drystone: is },
                            foliage: { trees: [Mi, Di], treesb: [ki, Ci], grass: Ii, bush: Si, grassColouration: [52 / 255, 20 / 255, 36 / 255, 0], treeColouration: [-0.05, 0.1, 0.1, 0] },
                        },
                        autumn: {
                            name: "autumn",
                            weathers: ["autumnSunrise", "clearAutumn", "autumnRain", "twilight", "night"],
                            cycles: [
                                ["clear", "twilight", "night", "night", "autumnSunrise"],
                                ["autumnRain", "twilight", "night", "night", "autumnSunrise"],
                            ],
                            grass: Li,
                            forest: Ri,
                            gravel: xi,
                            foliage: { trees: [Ni, ji], treesb: [Oi, zi], grass: Ti, bush: Pi, grassColouration: [60 / 255, 25 / 255, 45 / 255, 0], treeColouration: [0.1, -0.05, 0, 0] },
                        },
                        winter: {
                            name: "winter",
                            weathers: ["winterSunrise", "clearSnow", "snow", "winterSunset", "nightSnow"],
                            cycles: [
                                ["snow", "winterSunset", "night", "night", "winterSunrise"],
                                ["clearSnow", "winterSunset", "night", "night", "winterSunrise"],
                            ],
                            grass: Yi,
                            gravel: Yi,
                            forest: Vi,
                            heather: Vi,
                            sand: Vi,
                            road: Ui,
                            roadBase: Xi,
                            rock: $i,
                            water: 12110031,
                            foliage: { trees: [qi, Ji], treesb: [_i, Ki], grass: null, bush: es, grassColouration: [0, 0, 0, 0], treeColouration: [0.15, 0.15, 0.15, 0] },
                            friction: { road: 1.1, side: 0.8, grass: 0.6 },
                            walls: { drystone: ss, fence: as },
                        },
                    },
                    time: { noon: {} },
                },
                As = (e, t) => {
                    (Ss = Is[e]),
                        (Ds = Ms[e]),
                        (Cs = ks[e]),
                        (Ns = js[e]),
                        (Rs = Ls[t]),
                        (Ts = Rs / 20),
                        (Bs = t > 1),
                        0 == t ? (Ws = 2) : 1 == t ? (Ws = Math.floor(Mt / 100)) : 2 == t ? (Ws = Math.floor(At / 50)) : 3 == t && (Ws = Math.floor(At / 25)),
                        Es(t);
                },
                ys = new r.F({ map: et(mi, 0), displacementMap: et(xs, 4) }),
                Is = [700, 2e3, 3500, 6e3, 8e3];
            let Ss = 3500;
            const Ms = [200, 400, 600, 800, 900];
            let Ds = 400;
            const ks = [20, 50, 100, 150, 200];
            let Cs = 100;
            const js = [15, 20, 25, 30, 40];
            let Ns = 10;
            const zs = et(vs),
                Os = [
                    _e(null, 0.75, 4, null, { TREES: "", AUTO_NORMAL: "" }, { noiseMap: zs, mapb: null, highDef: !0, colouration: [0, 0, 0, 0] }),
                    _e(null, 0.75, 4, null, { TREES: "", AUTO_NORMAL: "" }, { noiseMap: zs, mapb: null, highDef: !0, colouration: [0, 0, 0, 0] }),
                ],
                Ls = [5e3, 1e4, 2e4, 3e4, 4e4];
            let Rs = 5e3,
                Ts = Rs / 20;
            const Ps = [_e(null, 0.75, 4, null, { GRASS: "", AUTO_NORMAL: "" }, { noiseMap: zs, colouration: [0, 0, 0, 0] }), _e(null, 0.75, 4, null, { BUSH: "", AUTO_NORMAL: "" }, { noiseMap: zs, colouration: [0, 0, 0, 0] })];
            (ys.userData.grassMap = { value: null }),
                (ys.userData.sandMap = { value: null }),
                (ys.userData.rockMap = { value: et(xs, 4) }),
                (ys.userData.rockBumpMap = { value: null }),
                (ys.userData.gravelMap = { value: null }),
                (ys.userData.heatherMap = { value: null }),
                (ys.userData.forestMap = { value: null }),
                (ys.userData.roadBaseMap = { value: null }),
                (ys.userData.fadeRockMap = { value: et(vs, 4) }),
                (ys.userData.fadeFiner = { value: et(fs, 4) }),
                (ys.userData.colouration = { value: [0.18, 0.08, 0.1, 0] }),
                (ys.onBeforeCompile = (e) => (
                    (e.uniforms.grassMap = ys.userData.grassMap),
                    (e.uniforms.sandMap = ys.userData.sandMap),
                    (e.uniforms.rockMap = ys.userData.rockMap),
                    (e.uniforms.rockBumpMap = ys.userData.rockBumpMap),
                    (e.uniforms.gravelMap = ys.userData.gravelMap),
                    (e.uniforms.heatherMap = ys.userData.heatherMap),
                    (e.uniforms.forestMap = ys.userData.forestMap),
                    (e.uniforms.roadBaseMap = ys.userData.roadBaseMap),
                    (e.uniforms.fadeRockMap = ys.userData.fadeRockMap),
                    (e.uniforms.fadeFiner = ys.userData.fadeFiner),
                    (e.uniforms.colouration = ys.userData.colouration),
                    (e.vertexShader = e.vertexShader.replace(
                        "#include <displacementmap_pars_vertex>",
                        "\n\nattribute float heightOffset;\nattribute float roadProximity;\nattribute float treeMask;\nattribute float curvature;\nattribute float grass;\n\nvarying float height;\nvarying float steepness;\nvarying float roadProx;\nvarying float vTreeMask;\nvarying vec2 vWv;\nvarying vec2 vWWv;\nvarying float vCurvature;\nvarying float vGrass;\nvarying float vLightGrass;\nvarying float vDarkGrass;\nvarying float vHeather;\n\nfloat wuvSize = 800.0;\n\nuniform sampler2D displacementMap;\nuniform sampler2D fadeRockMap;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec3 upvec = vec3(0.0,1.0,0.0);\n\n"
                    )),
                    (e.vertexShader = e.vertexShader.replace(
                        "#include <displacementmap_vertex>",
                        "\n\n  vec4 wPos = modelMatrix * vec4( position, 1.0 );\n\n  height = wPos.y + heightOffset;\n\n  // Unclear if worthwhile...\n  // if(abs(wPos.x) > 14000.0) {\n  //   wPos.x = mod(wPos.x, 14000.0);\n  // }\n  // if(abs(wPos.z) > 14000.0) {\n  //   wPos.z = mod(wPos.z, 14000.0);\n  // }\n\n  // Set UVs from world pos\n  vUv.x = wPos.x / 10.0;\n  vUv.y = wPos.z / 10.0;\n\n\n  // 0 is perfectly flat, 1 is 90 degrees\n  steepness = 1.0 - dot(normal, upvec);\n  steepness = clamp(steepness * 2.0, 0.0, 1.0);\n\n  // Anything up to 0.8 is 1\n  // 0.8 down to 0.6\n  // 0.6 and under is 0\n\n  // steepness = 1.0 - clamp((steepness - 0.6) / 0.2, 0.0, 1.0);\n  // steepness = 1.0 - map(steepness, 0.2, 0.7, 0.0, 1.0);\n\n  // steepness = 1.0 - steepness;//clamp((steepness * 2.0), 0.0, 1.0);\n  // steepness = map(steepness, 0.0, 1.0, 0.3, 0.7);\n\n  vWv.x = wPos.x / wuvSize;\n  vWv.y = wPos.z / wuvSize;\n\n  vWWv.x = vWv.x / 8.0;\n  vWWv.y = vWv.y / 8.0;\n\n  // MAGIC NUMBERS TO BE TWEAKED BASED ON HEIGHT PARAMETERS\n  if(curvature > 0.0) {\n    vCurvature = max(-1.0, curvature * -4.0);\n  } else {\n    vCurvature = min(1.0, curvature * -4.0);\n  }\n\n  //// GET FADES\n\n  float fade0 = texture2D(fadeRockMap, vWv).r;\n  float fade1 = texture2D(fadeRockMap, vWWv).r;\n  float fade2 = (texture2D(fadeRockMap,\n    vec2(\n      vWWv.x = wPos.x / 1200.0,\n      vWWv.y = wPos.z / 1200.0\n    )\n  ).r / 2.0) + 0.5;\n\n  //// HEATHER\n\n  vHeather = smoothstep(0.47, 0.53, min(1.0,height / 170.0) * fade1 * fade2);\n\n  //// GRASSES\n\n  // Focus contrast on middle range for sharper edges\n\n  fade0 = min(max(0.0,(fade0 - 0.25) * 2.0), 1.0);\n  fade1 = min(max(0.0,(fade1 - 0.25) * 2.0), 1.0);\n\n  float heightVal = min(1.0, height/100.0);\n  vLightGrass = min(1.0, max(0.0, fade1 * heightVal * (fade0 + heightVal)));\n  if(roadProximity > 0.0 && roadProximity < 2.0) {\n    vLightGrass *= roadProximity / 4.0 + 0.5;\n    vHeather *= roadProximity / 2.0;\n  }\n  vDarkGrass = 1.0;// 1.1 - (fade1 * 0.1);\n\n\n  //// ROAD PROX\n\n  roadProx = roadProximity;\n\n  //// TREE MASK\n\n  vTreeMask = treeMask;\n\n  //// GRASS  FIDDLING\n\n  // if(vCurvature > 0.0) {\n  //   vGrass = grass * vCurvature;\n  // } else {\n  //   vGrass = 0.0;\n  // }\n  // vGrass = grass * min(1.0, height / 100.0);\n\n  vGrass = grass;\n\n  vWWv.x = wPos.x / 400.0;\n  vWWv.y = wPos.z / 400.0;\n\n  transformed += vec3(0.0, heightOffset, 0.0);\n\n  // Experimenting with displacement map\n  transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * steepness * 1.25 );\n\n"
                    )),
                    (e.fragmentShader = e.fragmentShader.replace(
                        "#include <map_pars_fragment>",
                        "\n\n  varying float height;\n  varying float steepness;\n  varying float roadProx;\n  varying float vTreeMask;\n  varying float vCurvature;\n  varying float vGrass;\n  varying vec2 vWv;\n  varying vec2 vWWv;\n  varying float vLightGrass;\n  varying float vDarkGrass;\n  varying float vHeather;\n\n  uniform sampler2D grassMap;\n  uniform sampler2D sandMap;\n  uniform sampler2D rockMap;\n  uniform sampler2D rockMapBump;\n  uniform sampler2D gravelMap;\n  uniform sampler2D forestMap;\n  uniform sampler2D heatherMap;\n  uniform sampler2D fadeRockMap;\n  uniform sampler2D fadeFiner;\n\n  uniform vec4 colouration;\n\n  vec4 rockTex;\n\n  vec4 terrainBlend(vec4 tx1, float w1, vec4 tx2, float w2, float depth) {\n    // Perform the blending\n    float ma = max(tx1.a + w1, tx2.a + w2) - depth;\n    float b1 = max(tx1.a + w1 - ma, 0.0);\n    float b2 = max(tx2.a + w2 - ma, 0.0);\n\n    return ((tx1 * b1) + (tx2 * b2)) / (b1 + b2);\n  }\n\n  vec4 roadCol = vec4(0.45, 0.45, 0.474, 1.0);\n\n\n"
                    )),
                    (e.fragmentShader = e.fragmentShader.replace(
                        "#include <map_fragment>",
                        "\n\n  float fade = texture2D(fadeRockMap, vUv).r;\n  float fade1 = texture2D(fadeRockMap, vWv).r;\n  float fade2 = (texture2D(fadeRockMap, vWWv).r / 2.0) + 0.5;\n\n  float heightVal = min(1.0, (height/ 150.0));\n\n  vec4 darkGrass = texture2D(heatherMap, vUv);\n  darkGrass.a = darkGrass.g;\n\n  //// GRASS 1\n\n  vec4 texelColor = texture2D( grassMap, vUv );\n\n  //// LIGHT GRASS\n\n  texelColor += colouration * vLightGrass;\n\n  //// HEATHER\n\n  texelColor = mix(texelColor, darkGrass, vHeather * smoothstep(0.3, 0.7, fade1));\n\n  //// TREE MASK\n\n  texelColor = mix(texelColor, texture2D(forestMap, vUv), vTreeMask);\n  // texelColor.a = 1.0;\n  // vec4 forestCol = texture2D(forestMap, vUv);\n  // forestCol.a = 1.0 + fade * 0.1;//forestCol.r;// - fade * 0.5;\n  // texelColor = terrainBlend(\n  //   texelColor,\n  //   1.0-vTreeMask,\n  //   forestCol,\n  //   vTreeMask + fade * 0.25,\n  //   0.25\n  // );\n  // texelColor.a = 1.0;\n\n  //// DARK GRASS\n\n  texelColor *= vDarkGrass;\n\n  //// SAND BLEND\n\n  if(height < 4.0) {\n    float dark = 1.0 - vTreeMask * 0.3;\n    if(height < 0.0) {\n      texelColor = texture2D(sandMap, vUv) * 0.8333;\n    } else {\n      if(height < 2.0) {\n        dark = min(dark, 1.0 - (2.0 - height) / 12.0);\n      }\n      texelColor = mix(texture2D(sandMap, vUv) * dark, texelColor, height / 4.0);\n    }\n  }\n\n  //// ROADSIDE GRAVEL\n\n  if(roadProx < -0.2) {\n    texelColor = roadCol; // TODO pass in different colour as tex?\n  } else if(roadProx != 0.0 && roadProx < 0.7) {\n\n    float rp = roadProx / 0.7;\n\n    texelColor = mix(\n      texture2D(gravelMap, vUv),\n      texelColor,\n      smoothstep(\n        rp + 0.15,\n        rp - 0.15,\n        fade\n      )\n    );\n    // // Texture blend mode, not worth it\n    // vec4 gravelTex = texture2D(gravelMap, vUv);\n    // // float rp = roadProx / 1.25;\n    // gravelTex.a = gravelTex.r * gravelTex.r;\n    // texelColor.a = fade;\n    //\n    // texelColor = terrainBlend(\n      //   texelColor,\n      //   rp,\n      //   gravelTex,\n      //   1.0-rp,\n      //   0.1\n      // );\n\n\n\n\n  }\n\n  //// STEEPNESS CLIFF\n\n\n  if(roadProx == 0.0) {\n    rockTex = texture2D(rockMap, vWv) * (1.0 - vTreeMask * 0.5);\n    rockTex.a = 1.0 - texture2D(rockMapBump, vWv).r;\n  } else {\n    rockTex = texture2D(rockMap, vUv) * (1.0 - vTreeMask * 0.5);\n    rockTex.a = texture2D(rockMapBump, vUv).r;\n  }\n\n  texelColor.a = 0.2 + fade1 * 0.2;\n  texelColor = terrainBlend(texelColor,0.7, rockTex, steepness, 0.06);\n  texelColor.a = 1.0;\n\n  //// FINAL COMPOSITION\n\n  diffuseColor *= texelColor;\n\n"
                    )),
                    e
                ));
            let Gs = null,
                Bs = !1,
                Ws = 50;
            const Es = (e) => {
                var t;
                null === (t = Gs) || void 0 === t || t.dispose();
                let i = {};
                e > 0 && ((i.WATER_WAVES = ""), e > 1 && (i.WATER_DEPTH = "")),
                    (Gs = new r.C({ wireframe: !1 })),
                    (Gs.defines = i),
                    (Gs.userData.camPos = { value: new r.W() }),
                    (Gs.userData.skyCol = { value: [1, 1, 1, 1] }),
                    (Gs.userData.waves = { value: et(ws, 4) }),
                    (Gs.userData.sunCol = { value: [1, 1, 1, 1] }),
                    (Gs.userData.time = { value: 0 }),
                    (Gs.onBeforeCompile = (e) => (
                        (e.uniforms.camPos = Gs.userData.camPos),
                        (e.uniforms.skyCol = Gs.userData.skyCol),
                        (e.uniforms.waves = Gs.userData.waves),
                        (e.uniforms.sunCol = Gs.userData.sunCol),
                        (e.uniforms.time = Gs.userData.time),
                        (e.vertexShader = e.vertexShader.replace(
                            "#include <color_pars_vertex>",
                            "#include <color_pars_vertex>\n\n\n  #ifdef WATER_DEPTH\n\n    attribute float depth;\n\n  #endif\n\n  #ifdef WATER_WAVES\n\n    uniform float time;\n\n    varying vec2 vUw;\n    varying vec2 vUUw;\n    varying vec2 vUUUw;\n\n  #endif\n\n  varying vec4 wPos;\n\n  #ifdef WATER_DEPTH\n\n    varying float vDepth;\n\n  #endif\n\n"
                        )),
                        (e.vertexShader = e.vertexShader.replace(
                            "#include <color_vertex>",
                            "#include <color_vertex>\n\n\n  wPos = modelMatrix * vec4( position, 1.0 );\n\n  #ifdef WATER_WAVES\n\n    // 50 and 200 for normal map\n\n\n    vUw.x = (time + wPos.x) / 200.0;\n    vUw.y = (time + wPos.z) / 200.0;\n\n    vUUw.x = (wPos.x - time) / 800.0;\n    vUUw.y = (wPos.z - time) / 800.0;\n\n    vUUUw.x = (wPos.x - time) / 300.0;\n    vUUUw.y = (wPos.z - time) / 300.0;\n  #endif\n\n  #ifdef WATER_DEPTH\n    vDepth = depth;\n  #endif\n\n"
                        )),
                        (e.fragmentShader = e.fragmentShader.replace(
                            "#include <map_pars_fragment>",
                            "#include <map_pars_fragment>\n\n\n\nuniform vec3 camPos;\nuniform vec4 skyCol;\nuniform vec4 sunCol;\n\n#ifdef WATER_WAVES\n  uniform sampler2D waves;\n\n  varying vec2 vUw;\n  varying vec2 vUUw;\n  varying vec2 vUUUw;\n\n#endif\n\nvarying vec4 wPos;\n\n#ifdef WATER_DEPTH\n  varying float vDepth;\n#endif\n\nvec3 upvec = vec3(0.0,1.0,0.0);\n\n\n"
                        )),
                        (e.fragmentShader = e.fragmentShader.replace(
                            "#include <map_fragment>",
                            "#include <map_fragment>\n\n\n  #ifdef WATER_DEPTH\n    // Abandon water rendering if it's well under ground\n    if(vDepth > 10.0) {\n      discard;\n    }\n  #endif\n  \n  vec3 camNorm = normalize(vec3(\n    camPos.x - wPos.x,\n    camPos.y - wPos.y,\n    camPos.z - wPos.z\n  ));\n\n  float seaDot = dot(camNorm, upvec);\n\n  #if defined(WATER_WAVES) || defined(WATER_DEPTH)\n\n\n    // Add lightness\n    float wave1 = texture2D(waves, vUw).r + 0.1;\n    float wave2 = texture2D(waves, vUUw).r + 0.1;\n\n    // Add darkness?\n    float wave4 = (texture2D(waves, vUUUw).r + 0.1);\n    float wave5 = (texture2D(waves, vUUw - vUw).r + 0.1);\n\n    //// WAVE RIPPLES\n\n    float darkReflect = 0.0;\n\n    #ifdef WATER_DEPTH\n\n      if(vDepth > -2.0) {\n        if(vDepth > -1.0) {\n          darkReflect = 1.0;\n        } else {\n          darkReflect = (2.0 + vDepth);\n        }\n      }\n\n    #endif\n\n    // Extra dark ripples by sea edge\n    seaDot += wave4 * wave5 * (0.5 + darkReflect / 4.0);\n    // No ripples by sea edge\n    seaDot -= wave1 * wave2 * (1.0 - darkReflect);\n\n    //// EDGE HIGHLIGHT\n\n    #ifdef WATER_DEPTH\n\n      if(vDepth < 0.0) {\n        if(vDepth > -2.0) {\n          seaDot -= (2.0 + vDepth) * 0.05 * (1.0 - wave2);\n        }\n      } else {\n        seaDot -= 0.1 * (1.0 - wave2);\n      }\n    #endif\n\n    //// CLAMP SEADOT\n\n    seaDot = min(max(0.0, seaDot), 1.0);\n\n    //// BLEND SKY WITH DARK BY SEADOT\n\n    float seaDotMix = 1.0 - seaDot;\n    diffuseColor = mix(diffuseColor, skyCol, seaDotMix * seaDotMix);\n\n    //// DARKEN DEPTHS\n\n    #ifdef WATER_DEPTH\n\n      if(vDepth < 0.0) {\n        diffuseColor *= 1.0 - min(1.0, vDepth / -15.0) * 0.2;\n      }\n\n    #endif\n\n    //// HIGHLIGHTS ON SHALLOW ANGLES\n\n    float sunDotMix = 0.0;\n    if(seaDot < 0.125) {\n      sunDotMix = 1.0 - seaDot * 8.0;\n    }\n    diffuseColor = mix(diffuseColor, sunCol, sunDotMix * sunDotMix);\n\n  #else\n    float seaDotMix = 1.0 - seaDot;\n    diffuseColor = mix(diffuseColor, skyCol, seaDotMix * seaDotMix);\n  #endif\n\n  //// FINALISE\n\n  diffuseColor.a = 1.0;\n\n"
                        )),
                        e
                    ));
            };
            As(st, nt);
            var Fs = bs;
            const Zs = new r.I(It, 1, 0.35, Mt);
            Zs.fwd = new r.W(0, 0, 1);
            var Hs = Zs,
                Qs = new l();
            const Ys = [0, 180, 480, 900];
            var Vs = new (class extends l {
                constructor(...e) {
                    super(...e), (this.default = 0), (this.value = 0), (this.cycleLength = Ys[0]);
                }
                set(e) {
                    (this.cycleLength = Ys[e]), super.set(e);
                }
            })();
            const Us = "1.1.0";
            let Xs = localStorage.getItem("seen-version");
            const Js = null !== Xs && Xs !== Us;
            if (!J.value && Js) {
                let e = Object.keys(localStorage);
                for (let t in e) 0 == t.indexOf("config") && localStorage.removeItem(t);
            }
            const qs = [
                    "Controller support added",
                    "Input remapping added",
                    "Input settings added for sensitivity, toggle-boost etc.",
                    "Basic in-vehicle first-person view (Roadster only)",
                    "Snow effects",
                    "Straight/casual modes added",
                    "Ultra+ view distance for those with powerful PCs",
                    "Speed limit control added alongside cruise control",
                    "Minor bugs fixed and QoL tweaks made",
                ],
                Ks = {
                    targetDate: "31st January",
                    changes: [
                        "One new location (TBD)",
                        "Improved & textured in-vehicle first-person views",
                        "Expanded control panel with extra settings for physics/audio",
                        "Improved environmental detail and weather effects",
                        "Further bug fixes, including audio issues and environment generation bugs",
                    ],
                };
            window.localStorage.setItem("seen-version", Us), window.localStorage.removeItem("undefined");
            const _s = (e) => {
                let t = { major: 0, minor: 0, patch: 0, release: 10, releaseVersion: 10 },
                    i = e,
                    s = null;
                if ((e.indexOf("-") > 0 && ((i = (e = e.split("-"))[0]), (s = e[1])), (i = i.split(".")), (t.major = parseInt(i[0])), (t.minor = parseInt(i[1])), (t.patch = parseInt(i[2])), s)) {
                    s = s.split(".");
                    let e = s[0];
                    (t.release = "alpha" == e ? 0 : "beta" == e ? 1 : 2), (t.releaseVersion = parseInt(s[1]));
                }
                return t;
            };
            var $s = Us;
            var en = { version: $s, seed: Be, "draw-calls": 0, "heightmap-cache": 0, "roadside-objects": 0, farcells: 0, "farcells-staged": 0, "nearcell-staged": 0 },
                tn = i(10);
            class sn extends r.G {
                constructor(...e) {
                    super(...e), (this.geoSource = null), (this.materials = {}), (this.objectType = "root"), (this.worldPosition = new r.W()), (this.variant = 0), (this.variantMaterials = []);
                }
                initialiseGeometry(e) {
                    this.geoSource &&
                        sn.loader.load(this.geoSource, (t) => {
                            t.traverse((e) => {
                                e.isMesh && ((e.userData.matName = e.name.split("_")[1]), e.userData.matName in this.materials ? (e.material = this.materials[e.userData.matName]) : (e.material = this.materials.default));
                            }),
                                this.add(t),
                                e(this);
                        });
                }
                destroy() {
                    this.traverse((e) => {
                        e.isMesh && e.geometry.dispose();
                    });
                }
                updatePosition() {
                    this.position.subVectors(this.worldPosition, this.parent.position);
                }
                updateRetireIndex(e) {
                    this.retireIndex = e + 5;
                }
                setVariant(e) {
                    e < 0 || e >= this.variantMaterials.length
                        ? console.warn("No variant index " + e + " found for object type " + this.objectType)
                        : ((this.variantIndex = e),
                          this.traverse((e) => {
                              e.isMesh && e.userData.matName in this.variantMaterials[this.variantIndex] && (e.material = this.variantMaterials[this.variantIndex][e.userData.matName]);
                          }));
                }
            }
            sn.loader = new tn.a();
            var nn = sn,
                an = i.p + "static/media/sign.c5b548a5.obj",
                on =
                    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTAxVDE2OjI4OjE1WiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wMi0wMVQxNjoyODoxNVoiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTAyLTAxVDE2OjI4OjE1WiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpmMThkYjE2OS1mMjY5LTI3NGYtYWMwNC1mYzhmZGIwMmY5M2QiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo0MGQyNWZiNi04NDU4LTFjNGUtYjJjNS0wMTExOGEzYzRjMGQiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDplZjM0ZDlmZi04MWQ5LTdlNGItOGYxMS0zZTFiY2UzMDJjNzUiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDplZjM0ZDlmZi04MWQ5LTdlNGItOGYxMS0zZTFiY2UzMDJjNzUiIHN0RXZ0OndoZW49IjIwMjItMDItMDFUMTY6Mjg6MTVaIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmYxOGRiMTY5LWYyNjktMjc0Zi1hYzA0LWZjOGZkYjAyZjkzZCIgc3RFdnQ6d2hlbj0iMjAyMi0wMi0wMVQxNjoyODoxNVoiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4VqR/6AAAADElEQVQIHWOo598OAAJWAUbmdvdzAAAAAElFTkSuQmCC";
            const rn = 0,
                hn = 1,
                ln = 2,
                dn = 3,
                cn = 5,
                pn = 6,
                un = 8,
                gn = 9,
                mn = 10,
                xn = 11,
                vn = [
                    {
                        sign: _e(
                            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTAxVDE4OjU5OjA5WiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wMi0wMVQxODo1OTowOVoiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTAyLTAxVDE4OjU5OjA5WiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3YzM5YjcwZC00NGU0LTUzNDYtOTEwOS0xMjU3MjhiZjg3OGUiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpmNDc1ZTE1MS02MmZhLTE4NDItOWM0Mi0yMjdkNzRjOTk4NzQi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",
                            0.75,
                            0,
                            on
                        ),
                    },
                    {
                        sign: _e(
                            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTAxVDE4OjU4OjI0WiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wMi0wMVQxODo1ODoyNFoiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTAyLTAxVDE4OjU4OjI0WiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2OTlkMTg2MC02NjVlLTZiNGItODIxMS00YTJmODZjMDY5NTkiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDplOWM1MThkMy1jOWM1LTBkNDAtODZjYS1mNTI3M2QwYjQzODgi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",
                            0.75,
                            0,
                            on
                        ),
                    },
                    {
                        sign: _e(
                            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTAxVDE4OjU0OjEwWiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wMi0wMVQxODo1NDoxMFoiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTAyLTAxVDE4OjU0OjEwWiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDphNTNlOTZlZC0wNzg5LTc2NDQtYmU3Yi05YjZkYTVjZTk5ZTAiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDoxNzlkMmIyNi01ZTcwLWJiNGEtODAyMS1jMjE1Y2ZmMmY3ZDgi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",
                            0.75,
                            0,
                            on
                        ),
                    },
                    {
                        sign: _e(
                            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTAxVDE4OjU0OjM4WiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wMi0wMVQxODo1NDozOFoiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTAyLTAxVDE4OjU0OjM4WiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyOTg4MjdkYy01Y2Y1LWIyNGItOGE2ZS03Njk4OTJiYThkZmUiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDozNTQwZGNiOS04NTBhLWFkNGEtODQyYS0xNzIxMjA4NzA0N2Ii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",
                            0.75,
                            0,
                            on
                        ),
                    },
                    {
                        sign: _e(
                            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGNmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTAxVDIwOjI3OjMzWiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wMi0wMVQyMDoyNzozM1oiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTAyLTAxVDIwOjI3OjMzWiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxZWNhNDY1ZC1jOTQyLTBjNDMtOWJkZS1iMzg2YTNkNWU1OGUiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo2ZDAyZjIxMi00NDRkLTEzNGUtYmU4Yy0xOWI1ZTg4ODFkOGEiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0NTZjZGY2YS01OTc2LTU3NDQtYjJhMS1jYmIyOTgwNjc1NzUiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo0NTZjZGY2YS01OTc2LTU3NDQtYjJhMS1jYmIyOTgwNjc1NzUiIHN0RXZ0OndoZW49IjIwMjItMDItMDFUMjA6Mjc6MzNaIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjFlY2E0NjVkLWM5NDItMGM0My05YmRlLWIzODZhM2Q1ZTU4ZSIgc3RFdnQ6d2hlbj0iMjAyMi0wMi0wMVQyMDoyNzozM1oiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPHBob3Rvc2hvcDpUZXh0TGF5ZXJzPiA8cmRmOkJhZz4gPHJkZjpsaSBwaG90b3Nob3A6TGF5ZXJOYW1lPSIhIiBwaG90b3Nob3A6TGF5ZXJUZXh0PSIhIi8+IDwvcmRmOkJhZz4gPC9waG90b3Nob3A6VGV4dExheWVycz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5dhtDoAAAT3klEQVR42u1dB1hU17aOJkaTm+Sq8ba85OZ9uffl3rwkNsoMZehSpDcBQVREY8MWY8t9scUYTYwxRk1ixR5jbyDNmWEGGDoiIlYsMAxNkTblzKx39qENRoR9mIEZ2Pv7fs8ZmjPn//c6a+291jovAMALBP0X5CIQAZCLQARAQARAQARAQATQN5FsxesI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",
                            0.75,
                            0,
                            on
                        ),
                    },
                    {
                        sign: _e(
                            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAHzGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTAxVDIwOjI3OjEyWiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wMi0wMlQxNDo1NDoyMloiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTAyLTAyVDE0OjU0OjIyWiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpiNTZiYjAwNS02YmRjLWY5NDMtYjY4MS02OTQ4MWE2MDY0OTgiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpiMWUxMGI5Mi03YTkzLTMwNDAtOGFjMC1hNTE1ODRkZTZlZWIiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3NzA5MDQ4Ny1jZDE3LWI3NGUtYWQ1Zi0zODU4ZjExYjc5MzAiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjc3MDkwNDg3LWNkMTctYjc0ZS1hZDVmLTM4NThmMTFiNzkzMCIgc3RFdnQ6d2hlbj0iMjAyMi0wMi0wMVQyMDoyNzoxMloiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZmRmZTJhMGQtMmM0OS0zYzQ0LWEzZjEtNGJiZmQzYWJiY2YyIiBzdEV2dDp3aGVuPSIyMDIyLTAyLTAxVDIwOjI3OjEyWiIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiNTZiYjAwNS02YmRjLWY5NDMtYjY4MS02OTQ4MWE2MDY0OTgiIHN0RXZ0OndoZW49IjIwMjItMDItMDJUMTQ6NTQ6MjJaIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDxwaG90b3Nob3A6VGV4dExheWVycz4gPHJkZjpCYWc+IDxyZGY6bGkgcGhvdG9zaG9wOkxheWVyTmFtZT0iMTUlIiBwaG90b3Nob3A6TGF5ZXJUZXh0PSIxNSUi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",
                            0.75,
                            0,
                            on
                        ),
                    },
                    {
                        sign: _e(
                            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAHzGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTAxVDIwOjI3OjEyWiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wMi0wMlQxNDo1Mzo1NloiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTAyLTAyVDE0OjUzOjU2WiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4YTExMzQzMS00MWJlLTNiNGEtODk1Yy0xODBkOTYzNzdkNmYiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpjN2VmYjY3MS0xZGRjLWJkNGYtYWE5NS0xNTU5ZGU0ODczZWMiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3NzA5MDQ4Ny1jZDE3LWI3NGUtYWQ1Zi0zODU4ZjExYjc5MzAiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjc3MDkwNDg3LWNkMTctYjc0ZS1hZDVmLTM4NThmMTFiNzkzMCIgc3RFdnQ6d2hlbj0iMjAyMi0wMi0wMVQyMDoyNzoxMloiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZmRmZTJhMGQtMmM0OS0zYzQ0LWEzZjEtNGJiZmQzYWJiY2YyIiBzdEV2dDp3aGVuPSIyMDIyLTAyLTAxVDIwOjI3OjEyWiIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo4YTExMzQzMS00MWJlLTNiNGEtODk1Yy0xODBkOTYzNzdkNmYiIHN0RXZ0OndoZW49IjIwMjItMDItMDJUMTQ6NTM6NTZaIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDxwaG90b3Nob3A6VGV4dExheWVycz4gPHJkZjpCYWc+IDxyZGY6bGkgcGhvdG9zaG9wOkxheWVyTmFtZT0iMjAlIiBwaG90b3Nob3A6TGF5ZXJUZXh0PSIyMCUi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",
                            0.75,
                            0,
                            on
                        ),
                    },
                    {
                        sign: _e(
                            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGNmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTAxVDIwOjI3OjEyWiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wMi0wMVQyMDoyNzoxMloiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTAyLTAxVDIwOjI3OjEyWiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpmZGZlMmEwZC0yYzQ5LTNjNDQtYTNmMS00YmJmZDNhYmJjZjIiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo1NzMxZDNmYy1mOWY2LTZjNDMtYmYwNy02ZjVjNWE2MjkzNGUiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3NzA5MDQ4Ny1jZDE3LWI3NGUtYWQ1Zi0zODU4ZjExYjc5MzAiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo3NzA5MDQ4Ny1jZDE3LWI3NGUtYWQ1Zi0zODU4ZjExYjc5MzAiIHN0RXZ0OndoZW49IjIwMjItMDItMDFUMjA6Mjc6MTJaIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmZkZmUyYTBkLTJjNDktM2M0NC1hM2YxLTRiYmZkM2FiYmNmMiIgc3RFdnQ6d2hlbj0iMjAyMi0wMi0wMVQyMDoyNzoxMloiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPHBob3Rvc2hvcDpUZXh0TGF5ZXJzPiA8cmRmOkJhZz4gPHJkZjpsaSBwaG90b3Nob3A6TGF5ZXJOYW1lPSIhIiBwaG90b3Nob3A6TGF5ZXJUZXh0PSIhIi8+IDwvcmRmOkJhZz4gPC9waG90b3Nob3A6VGV4dExheWVycz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz64/6jGAAAT1klEQVR42u2dB1hU17bHo4nR5Ca5arwtL7l5X+59uTcviY0yQxm6FOlNQBEV0diwxdhyX2wxRhNjjFGTWLHH2BtKc2aYAYaOiIgVCwxDk86UM7Pe2QchMyrCPszADOz9fX/PAKIzZ/3OPmutvfY6LwDAC0R9V+QkEADISSAAEBEAiAgARASA3qlkG157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",
                            0.75,
                            0,
                            on
                        ),
                    },
                    {
                        sign: _e(
                            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAHLmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTAxVDIwOjI3OjEyWiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wMi0wMlQxNDo1Mjo1NloiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTAyLTAyVDE0OjUyOjU2WiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1YjQ3ZTcyNS03MjJjLWY1NGQtOTNkNC05MWI2MDE3MzY2OTAiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo3YTRjZWRiMC0xYjkzLWMwNDMtODJkMC0yMTQ1ZmM5MDllMjciIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3NzA5MDQ4Ny1jZDE3LWI3NGUtYWQ1Zi0zODU4ZjExYjc5MzAiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjc3MDkwNDg3LWNkMTctYjc0ZS1hZDVmLTM4NThmMTFiNzkzMCIgc3RFdnQ6d2hlbj0iMjAyMi0wMi0wMVQyMDoyNzoxMloiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZmRmZTJhMGQtMmM0OS0zYzQ0LWEzZjEtNGJiZmQzYWJiY2YyIiBzdEV2dDp3aGVuPSIyMDIyLTAyLTAxVDIwOjI3OjEyWiIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo1YjQ3ZTcyNS03MjJjLWY1NGQtOTNkNC05MWI2MDE3MzY2OTAiIHN0RXZ0OndoZW49IjIwMjItMDItMDJUMTQ6NTI6NTZaIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDxwaG90b3Nob3A6VGV4dExheWVycz4gPHJkZjpCYWc+IDxyZGY6bGkgcGhvdG9zaG9wOkxheWVyTmFtZT0iMTUlIiBwaG90b3Nob3A6TGF5ZXJUZXh0PSIxNSUi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",
                            0.75,
                            0,
                            on
                        ),
                    },
                    {
                        sign: _e(
                            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAHLmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTAxVDIwOjI3OjEyWiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wMi0wMlQxNDo1MzoxN1oiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTAyLTAyVDE0OjUzOjE3WiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpiNTk0OGVkNi1mZTViLWE0NGEtYjZlMy04ZDM5ZGJjOTdjMzUiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpiZDJlYzBkOS00Yjg0LTI4NDAtYWZjOC0wOWM3OTVkMTkyMGQiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo3NzA5MDQ4Ny1jZDE3LWI3NGUtYWQ1Zi0zODU4ZjExYjc5MzAiIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjc3MDkwNDg3LWNkMTctYjc0ZS1hZDVmLTM4NThmMTFiNzkzMCIgc3RFdnQ6d2hlbj0iMjAyMi0wMi0wMVQyMDoyNzoxMloiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZmRmZTJhMGQtMmM0OS0zYzQ0LWEzZjEtNGJiZmQzYWJiY2YyIiBzdEV2dDp3aGVuPSIyMDIyLTAyLTAxVDIwOjI3OjEyWiIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiNTk0OGVkNi1mZTViLWE0NGEtYjZlMy04ZDM5ZGJjOTdjMzUiIHN0RXZ0OndoZW49IjIwMjItMDItMDJUMTQ6NTM6MTdaIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDxwaG90b3Nob3A6VGV4dExheWVycz4gPHJkZjpCYWc+IDxyZGY6bGkgcGhvdG9zaG9wOkxheWVyTmFtZT0iMjAlIiBwaG90b3Nob3A6TGF5ZXJUZXh0PSIyMCUi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",
                            0.75,
                            0,
                            on
                        ),
                    },
                    {
                        sign: _e(
                            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTAxVDIwOjM1OjE1WiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wMi0wMVQyMDozNToxNVoiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTAyLTAxVDIwOjM1OjE1WiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1YjcyNGQ1Yy0xMTE2LTZhNDktYjBlNy01YWNjZDlkZDA2M2MiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpmN2ViYTA2Ni1lYmRmLWJiNDgtYWVkYi0zODkzZDdmMDM0MTMi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",
                            0.75,
                            0,
                            on
                        ),
                    },
                    {
                        sign: _e(
                            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFuGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTAyLTAxVDIwOjM1OjQxWiIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0wMi0wMVQyMDozNTo0MVoiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTAyLTAxVDIwOjM1OjQxWiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0ODBhMzZmZS05MDViLTU0NDAtYmE4ZS1jNjNlNDc4ZWRlY2IiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo1Nzg2ZDY0Yi0xOTczLTYwNDQtYjdjOS04YmEyZTM0MWQ3MGMi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",
                            0.75,
                            0,
                            on
                        ),
                    },
                ],
                fn = new r.D({ color: 16777215 });
            var wn = class extends nn {
                    constructor(...e) {
                        super(...e), (this.geoSource = an), (this.objectType = "WarningSign"), (this.variantMaterials = vn), (this.materials = { pole: fn, sign: this.variantMaterials[0].sign });
                    }
                },
                bn = i.p + "static/media/vergemarker.f5ec7eac.obj";
            const An = {
                white: new r.D({ color: 16777215, emissive: 16777215, emissiveIntensity: 0.2 }),
                black: new r.D({ color: 3355443, flatShading: !0 }),
                reflect: new r.D({ color: 16720418, emissive: 16720418, emissiveIntensity: 0.2 }),
            };
            var yn = class extends nn {
                constructor(...e) {
                    super(...e), (this.geoSource = bn), (this.objectType = "VergeMarker"), (this.materials = An);
                }
            };
            const In = { main: new r.D({ color: 8947848 }) };
            var Sn = class extends nn {
                    constructor(...e) {
                        super(...e), (this.geoSource = null), (this.objectType = "BridgeSupport"), (this.materials = In);
                    }
                    initialiseGeometry(e) {
                        super.initialiseGeometry();
                        let t = new r.B(new r.e(2 * Ft, 20, 1), this.materials.main);
                        (t.position.y = -10.5), this.add(t), e(this);
                    }
                },
                Mn = i.p + "static/media/wallcap.aac16301.obj";
            var Dn = class {
                    constructor() {
                        (this.boundingSphere = new r.R()), (this.bounds = { maxX: 0, minX: 0, maxY: 0, minY: 0, maxZ: 0, minZ: 0 }), (this.seg = {}), (this.drawNode = null), (this.drawnNode = 0);
                    }
                    static checkMakeSegment(e) {}
                    computeBoundingSphere() {}
                    drawSegment() {}
                    drawNextNode() {}
                    postProcess() {}
                    retire() {
                        this.drawnNode = 0;
                    }
                },
                kn = i.p + "static/media/concrete_01.76bdb714.jpg";
            const Cn = 1 / 6,
                jn = 2 * Cn,
                Nn = 151,
                zn = {};
            class On extends Dn {
                constructor(e = null, t = null) {
                    super(),
                        (this.mapSource = kn),
                        (this.normSource = null),
                        (this.getHeightAt = t),
                        (this.material = new r.F({ map: null, flatShading: !0 })),
                        (this.mesh = new r.B(On.getGeo(), this.material)),
                        (this.mesh.matrixAutoUpdate = !1),
                        this.mesh.geometry.setDrawRange(0, 0),
                        (this.posAttribute = this.mesh.geometry.attributes.position),
                        (this.posArr = this.posAttribute.array),
                        (this.uvAttribute = this.mesh.geometry.attributes.uv),
                        (this.uvArr = this.uvAttribute.array),
                        e && this.drawSegment(e),
                        this.applyMaterial();
                }
                applyMaterial() {
                    this.mapSource && (this.material.map = et(this.mapSource, 4)), this.normSource && (this.material.normalMap = et(this.normSource, 4));
                }
                setMap(e) {
                    this.material.map = e;
                }
                drawSegment(e) {
                    return (
                        (this.seg = e),
                        (this.drawNode = this.seg.startNode),
                        (this.pi = 0),
                        (this.ui = 0),
                        (this.ox = this.seg.startNode.p.x),
                        (this.oz = this.seg.startNode.p.z),
                        (this.lOffset = this.seg.distance < 0 ? Cn : 0),
                        (this.uvDist = 0),
                        (this.ux2 = 0.46153846153846156),
                        (this.ux1 = 1 - this.ux2),
                        (this.ni = 0),
                        this.drawNextNode()
                    );
                }
                drawNextNode() {
                    for (
                        zn.dnp = this.drawNode.p,
                            this.ni > 0
                                ? ((this.bounds.maxX = Math.max(this.bounds.maxX, zn.dnp.x - this.ox)),
                                  (this.bounds.minX = Math.min(this.bounds.minX, zn.dnp.x - this.ox)),
                                  (this.bounds.maxY = Math.max(this.bounds.maxY, zn.dnp.y)),
                                  (this.bounds.minY = Math.min(this.bounds.minY, zn.dnp.y)),
                                  (this.bounds.maxZ = Math.max(this.bounds.maxZ, zn.dnp.z - this.oz)),
                                  (this.bounds.minZ = Math.min(this.bounds.minZ, zn.dnp.z - this.oz)))
                                : ((this.bounds.maxX = zn.dnp.x - this.ox),
                                  (this.bounds.minX = zn.dnp.x - this.ox),
                                  (this.bounds.maxY = zn.dnp.y),
                                  (this.bounds.minY = zn.dnp.y),
                                  (this.bounds.maxZ = zn.dnp.z - this.oz),
                                  (this.bounds.minZ = zn.dnp.z - this.oz)),
                            zn.j = 0;
                        zn.j < this.drawNode.ps.length;
                        zn.j += 2
                    )
                        (zn.pj = this.drawNode.ps[zn.j]),
                            (zn.nj = this.drawNode.ns[zn.j]),
                            (zn.x = zn.pj.x + zn.nj.x * (this.seg.distance - this.lOffset)),
                            (zn.xw = zn.x + zn.nj.x * Cn),
                            (zn.z = zn.pj.z + zn.nj.z * (this.seg.distance - this.lOffset)),
                            (zn.zw = zn.z + zn.nj.z * Cn),
                            (this.posArr[this.pi++] = zn.x - this.ox - zn.nj.x * jn),
                            (this.posArr[this.pi++] = zn.pj.y),
                            (this.posArr[this.pi++] = zn.z - this.oz - zn.nj.z * jn),
                            (this.posArr[this.pi++] = zn.x - this.ox),
                            (this.posArr[this.pi++] = zn.pj.y + 1),
                            (this.posArr[this.pi++] = zn.z - this.oz),
                            (this.posArr[this.pi++] = zn.xw - this.ox),
                            (this.posArr[this.pi++] = zn.pj.y + 1),
                            (this.posArr[this.pi++] = zn.zw - this.oz),
                            (this.posArr[this.pi++] = zn.xw - this.ox + zn.nj.x * jn),
                            (this.posArr[this.pi++] = zn.pj.y),
                            (this.posArr[this.pi++] = zn.zw - this.oz + zn.nj.z * jn),
                            this.seg.contiguousStart || 0 != this.ni || 0 != zn.j || ((this.posArr[this.pi - 11] -= 1), (this.posArr[this.pi - 8] -= 1), (this.posArr[this.pi - 5] -= 1), (this.posArr[this.pi - 2] -= 1)),
                            (this.uvArr[this.ui++] = 1),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = this.ux1),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = this.ux2),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = 0),
                            (this.uvArr[this.ui++] = this.uvDist),
                            this.uvDist++;
                    return (
                        this.ni++,
                        (this.drawNode = this.drawNode.next),
                        !(this.drawNode.i < this.seg.endNode.i) &&
                            ((zn.pj = this.drawNode.p),
                            (zn.nj = this.drawNode.n),
                            (zn.x = zn.pj.x + zn.nj.x * (this.seg.distance - this.lOffset)),
                            (zn.xw = zn.x + zn.nj.x * Cn),
                            (zn.z = zn.pj.z + zn.nj.z * (this.seg.distance - this.lOffset)),
                            (zn.zw = zn.z + zn.nj.z * Cn),
                            (this.posArr[this.pi++] = zn.x - this.ox - zn.nj.x * jn),
                            (this.posArr[this.pi++] = zn.pj.y),
                            (this.posArr[this.pi++] = zn.z - this.oz - zn.nj.z * jn),
                            (this.posArr[this.pi++] = zn.x - this.ox),
                            (this.posArr[this.pi++] = zn.pj.y + 1),
                            (this.posArr[this.pi++] = zn.z - this.oz),
                            (this.posArr[this.pi++] = zn.xw - this.ox),
                            (this.posArr[this.pi++] = zn.pj.y + 1),
                            (this.posArr[this.pi++] = zn.zw - this.oz),
                            (this.posArr[this.pi++] = zn.xw - this.ox + zn.nj.x * jn),
                            (this.posArr[this.pi++] = zn.pj.y),
                            (this.posArr[this.pi++] = zn.zw - this.oz + zn.nj.z * jn),
                            this.seg.contiguousEnd || ((this.posArr[this.pi - 11] -= 1), (this.posArr[this.pi - 8] -= 1), (this.posArr[this.pi - 5] -= 1), (this.posArr[this.pi - 2] -= 1)),
                            (this.uvArr[this.ui++] = 1),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = 0.55),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = 0.45),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = 0),
                            (this.uvArr[this.ui++] = this.uvDist),
                            this.mesh.geometry.setDrawRange(0, 5 * this.seg.length * 6 * 3),
                            this.computeBoundingSphere(),
                            (this.mesh.geometry.boundingSphere = this.boundingSphere),
                            this.mesh.position.set(this.ox, -0.25, this.oz),
                            (this.posAttribute.needsUpdate = !0),
                            (this.uvAttribute.needsUpdate = !0),
                            (this.mesh.visible = !0),
                            this.mesh.updateMatrix(),
                            !0)
                    );
                }
                computeBoundingSphere() {
                    (zn.minX = this.bounds.minX),
                        (zn.maxX = this.bounds.maxX),
                        (zn.minY = this.bounds.minY),
                        (zn.maxY = this.bounds.maxY),
                        (zn.minZ = this.bounds.minZ),
                        (zn.maxZ = this.bounds.maxZ),
                        (this.boundingSphere.center.x = (zn.minX + zn.maxX) / 2),
                        (this.boundingSphere.center.y = (zn.minY + zn.maxY) / 2),
                        (this.boundingSphere.center.z = (zn.minZ + zn.maxZ) / 2),
                        (this.boundingSphere.radius = Math.sqrt((zn.maxX - zn.minX) * (zn.maxX - zn.minX) + (zn.maxY - zn.minY) * (zn.maxY - zn.minY) + (zn.maxZ - zn.minZ) * (zn.maxZ - zn.minZ)) / 2 + 10);
                }
                retire() {
                    this.mesh.visible = !1;
                }
                static getNorms() {
                    let e = [];
                    for (let t = 0; t < Nn; t++) e.push(1, 0, 0, 0, 1, 0, 0, 1, 0, -1, 0, 0);
                    return e;
                }
                static getGeo() {
                    let e = new r.g();
                    return (
                        e.setIndex(On.getIndex()),
                        e.setAttribute("position", new r.o(new Float32Array(1812), 3)),
                        e.attributes.position.setUsage(r.l),
                        e.setAttribute("uv", new r.o(new Float32Array(1208), 2)),
                        e.attributes.uv.setUsage(r.l),
                        e
                    );
                }
                static getIndex() {
                    let e,
                        t,
                        i,
                        s,
                        n,
                        a,
                        o,
                        r,
                        h = [];
                    for (let l = 0; l < Nn; l++) (e = 4 * l), (t = e + 1), (i = e + 2), (s = e + 3), (n = 4 * (l + 1)), (a = n + 1), (o = n + 2), (r = n + 3), h.push(e, t, n, t, a, n, t, i, a, i, o, a, i, s, o, s, r, o);
                    return h;
                }
            }
            var Ln = On;
            var Rn = class {
                constructor(e, t, i, s) {
                    (this.startNode = e), (this.endNode = t), (this.type = i), (this.distance = s), (this.length = t.i - e.i), (this.contiguousStart = !1), (this.contiguousEnd = !1);
                }
                copy(e) {
                    (this.startNode = e.startNode),
                        (this.endNode = e.endNode),
                        (this.type = e.type),
                        (this.distance = e.distance),
                        (this.length = e.length),
                        (this.contiguousStart = e.contiguousStart),
                        (this.contiguousEnd = e.contiguousEnd);
                }
            };
            var Tn = class {
                constructor(e, t) {
                    (this.prevRight = new Rn(e, e, -1, 0)), (this.prevLeft = new Rn(e, e, -1, 0)), (this.typeID = t);
                }
                generateLeft(e) {
                    return (
                        (this.test = this.testLeft),
                        (this.prev = this.prevLeft),
                        (this.side = -1),
                        (this.seg = null),
                        e.i > this.prev.endNode.i && this.testGenLeft(e) && ((this.seg = this.generate(e)), this.seg && (this.prevLeft = this.seg)),
                        this.seg
                    );
                }
                testGenLeft(e) {
                    return !1;
                }
                generateRight(e) {
                    return (
                        (this.test = this.testRight),
                        (this.prev = this.prevRight),
                        (this.side = 1),
                        (this.seg = null),
                        e.i > this.prev.endNode.i && this.testGenRight(e) && ((this.seg = this.generate(e)), this.seg && (this.prevRight = this.seg)),
                        this.seg
                    );
                }
                testGenRight(e) {
                    return !1;
                }
                generate(e) {}
            };
            var Pn = class {
                constructor(e = 10, t = 1, i = 0) {
                    (this.rands = []), (this.index = 0), (this.rand = new window.alea(Be));
                    for (let s = 0; s < e; s++) this.rands.push(this.rand() * t - i);
                    (this.count = e), (this.index = 0);
                }
                next() {
                    return this.index >= this.count && (this.index = 0), this.rands[this.index++];
                }
            };
            const Gn = 1.2,
                Bn = 0.3,
                Wn = 0.2,
                En = new Pn(23, 0.1),
                Fn = new Pn(37, 0.2),
                Zn = new r.F({ map: et(null, 4), flatShading: !0 }),
                Hn = {};
            class Qn extends Tn {
                constructor(...e) {
                    super(...e), (this.p = new r.W());
                }
                generate(e) {
                    let t = e;
                    for (; t.prev && this.test(t.prev) && e.i - t.i < 4; ) t = t.prev;
                    for (; this.test(e.next) && e.next.i - t.i < Ut; ) e = e.next;
                    if (e.i - t.i < 1) return e.i == t.i && (this.p.copy(e.p), (this.p.x += e.n.x * (Ft + 1.1) * this.side), (this.p.z += e.n.z * (Ft + 1.1) * this.side), Xn.addObject(Un.WallCap, this.p, Math.PI - e.a, e.i)), null;
                    let i = new Rn(t, e, this.typeID, this.side < 0 ? -t.dswl : -t.dswr);
                    return this.prev.endNode.i == t.i && this.prev.type == i.type && ((this.prev.contiguousEnd = !0), (i.contiguousStart = !0), (i.distance = this.prev.distance)), i;
                }
                testGenLeft(e) {
                    return void 0 !== e.dsel || void 0 !== e.dswl;
                }
                testGenRight(e) {
                    return void 0 !== e.dser || void 0 !== e.dswr;
                }
                testGen(e) {
                    return void 0 !== e.dswl || void 0 !== e.dswr;
                }
                testLeft(e) {
                    return void 0 !== e.dswl;
                }
                testRight(e) {
                    return void 0 !== e.dswr;
                }
            }
            var Yn = class extends Ln {
                constructor(...e) {
                    super(...e), (this.p = new r.W()), (this.mesh.material = Zn);
                }
                getDistFromGradient(e) {
                    return Ft + 1;
                }
                drawSegment(e) {
                    return (
                        (this.seg = e),
                        (this.drawNode = this.seg.startNode),
                        (this.pi = 0),
                        (this.ui = 0),
                        (this.ox = this.seg.startNode.p.x),
                        (this.oz = this.seg.startNode.p.z),
                        (this.lOffset = this.seg.distance < 0 ? Bn : 0),
                        (this.uvDist = 0),
                        (this.ux2 = 0.4444444444444445),
                        (this.ux1 = 1 - this.ux2),
                        (this.ni = 0),
                        (this.side = e.distance < 0 ? -1 : 1),
                        (this.h = 0),
                        (this.d = 0),
                        this.drawNextNode()
                    );
                }
                drawNextNode() {
                    for (
                        Hn.dnp = this.drawNode.p,
                            this.ni > 0
                                ? ((this.bounds.maxX = Math.max(this.bounds.maxX, Hn.dnp.x - this.ox)),
                                  (this.bounds.minX = Math.min(this.bounds.minX, Hn.dnp.x - this.ox)),
                                  (this.bounds.maxY = Math.max(this.bounds.maxY, Hn.dnp.y)),
                                  (this.bounds.minY = Math.min(this.bounds.minY, Hn.dnp.y)),
                                  (this.bounds.maxZ = Math.max(this.bounds.maxZ, Hn.dnp.z - this.oz)),
                                  (this.bounds.minZ = Math.min(this.bounds.minZ, Hn.dnp.z - this.oz)))
                                : ((this.bounds.maxX = Hn.dnp.x - this.ox),
                                  (this.bounds.minX = Hn.dnp.x - this.ox),
                                  (this.bounds.maxY = Hn.dnp.y),
                                  (this.bounds.minY = Hn.dnp.y),
                                  (this.bounds.maxZ = Hn.dnp.z - this.oz),
                                  (this.bounds.minZ = Hn.dnp.z - this.oz)),
                            this.seg.distance = this.getDistFromGradient(this.drawNode.g) * this.side,
                            Hn.j = 0;
                        Hn.j < this.drawNode.ps.length;
                        Hn.j += 2
                    )
                        (Hn.pj = this.drawNode.ps[Hn.j]),
                            (Hn.nj = this.drawNode.ns[Hn.j]),
                            (Hn.x = Hn.pj.x + Hn.nj.x * (this.seg.distance - this.lOffset + this.d)),
                            (Hn.xw = Hn.x + Hn.nj.x * Bn),
                            (Hn.z = Hn.pj.z + Hn.nj.z * (this.seg.distance - this.lOffset + this.d)),
                            (Hn.zw = Hn.z + Hn.nj.z * Bn),
                            (Hn.y = this.drawNode.ps[Hn.j].y),
                            (this.posArr[this.pi++] = Hn.x - this.ox - Hn.nj.x * Wn),
                            (this.posArr[this.pi++] = Hn.y),
                            (this.posArr[this.pi++] = Hn.z - this.oz - Hn.nj.z * Wn),
                            (this.posArr[this.pi++] = Hn.x - this.ox),
                            (this.posArr[this.pi++] = Hn.y + Gn + this.h),
                            (this.posArr[this.pi++] = Hn.z - this.oz),
                            (this.posArr[this.pi++] = Hn.xw - this.ox),
                            (this.posArr[this.pi++] = Hn.y + Gn + this.h),
                            (this.posArr[this.pi++] = Hn.zw - this.oz),
                            (this.posArr[this.pi++] = Hn.xw - this.ox + Hn.nj.x * Wn),
                            (this.posArr[this.pi++] = Hn.y),
                            (this.posArr[this.pi++] = Hn.zw - this.oz + Hn.nj.z * Wn),
                            (this.uvArr[this.ui++] = 1),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = this.ux1),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = this.ux2),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = 0),
                            (this.uvArr[this.ui++] = this.uvDist),
                            this.uvDist++,
                            (this.h = En.next()),
                            (this.d = Fn.next());
                    return (
                        this.ni++,
                        (this.drawNode = this.drawNode.next),
                        !(this.drawNode.i < this.seg.endNode.i) &&
                            ((this.h = 0),
                            (this.d = 0),
                            (Hn.pj = this.drawNode.p),
                            (Hn.nj = this.drawNode.n),
                            (Hn.x = Hn.pj.x + Hn.nj.x * (this.seg.distance - this.lOffset + this.d)),
                            (Hn.xw = Hn.x + Hn.nj.x * Bn),
                            (Hn.z = Hn.pj.z + Hn.nj.z * (this.seg.distance - this.lOffset + this.d)),
                            (Hn.zw = Hn.z + Hn.nj.z * Bn),
                            (Hn.y = Hn.pj.y),
                            (this.posArr[this.pi++] = Hn.x - this.ox - Hn.nj.x * Wn),
                            (this.posArr[this.pi++] = Hn.y),
                            (this.posArr[this.pi++] = Hn.z - this.oz - Hn.nj.z * Wn),
                            (this.posArr[this.pi++] = Hn.x - this.ox),
                            (this.posArr[this.pi++] = Hn.y + Gn),
                            (this.posArr[this.pi++] = Hn.z - this.oz),
                            (this.posArr[this.pi++] = Hn.xw - this.ox),
                            (this.posArr[this.pi++] = Hn.y + Gn),
                            (this.posArr[this.pi++] = Hn.zw - this.oz),
                            (this.posArr[this.pi++] = Hn.xw - this.ox + Hn.nj.x * Wn),
                            (this.posArr[this.pi++] = Hn.y),
                            (this.posArr[this.pi++] = Hn.zw - this.oz + Hn.nj.z * Wn),
                            (this.uvArr[this.ui++] = 1),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = this.ux1),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = this.ux2),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = 0),
                            (this.uvArr[this.ui++] = this.uvDist),
                            this.mesh.geometry.setDrawRange(0, 5 * this.seg.length * 6 * 3),
                            this.computeBoundingSphere(),
                            (this.mesh.geometry.boundingSphere = this.boundingSphere),
                            this.mesh.position.set(this.ox, -0.35, this.oz),
                            (this.posAttribute.needsUpdate = !0),
                            (this.uvAttribute.needsUpdate = !0),
                            (this.mesh.visible = !0),
                            this.mesh.updateMatrix(),
                            this.seg.contiguousStart ||
                                ((this.p.x = (this.posArr[0] + this.posArr[9]) / 2 + this.mesh.position.x),
                                (this.p.y = this.posArr[1]),
                                (this.p.z = (this.posArr[2] + this.posArr[11]) / 2 + this.mesh.position.z),
                                Xn.addObject(Un.WallCap, this.p, Math.PI + Math.PI / 2 - this.seg.startNode.a, this.seg.startNode.i)),
                            this.seg.contiguousEnd ||
                                ((this.p.x = (this.posArr[this.pi - 3] + this.posArr[this.pi - 12]) / 2 + this.mesh.position.x),
                                (this.p.y = this.posArr[this.pi - 2]),
                                (this.p.z = (this.posArr[this.pi - 1] + this.posArr[this.pi - 10]) / 2 + this.mesh.position.z),
                                Xn.addObject(Un.WallCap, this.p, Math.PI + Math.PI / 2 - this.seg.endNode.a, this.seg.endNode.i)),
                            !0)
                    );
                }
            };
            const Vn = {
                    VergeMarker: { class: yn, geo: null },
                    WarningSign: { class: wn, geo: null },
                    BridgeSupport: { class: Sn, geo: null },
                    WallCap: {
                        class: class extends nn {
                            constructor(...e) {
                                super(...e), (this.geoSource = Mn), (this.objectType = "WallCap"), (this.materials = { default: Zn });
                            }
                        },
                        geo: null,
                    },
                },
                Un = { VergeMarker: "VergeMarker", WarningSign: "WarningSign", BridgeSupport: "BridgeSupport", WallCap: "WallCap" };
            var Xn = new (class {
                    constructor() {
                        (this.lastRepositionIndex = 0),
                            (this.pools = {}),
                            (this.active = []),
                            (this.loadingQueue = []),
                            (this.getHeightAt = () => {}),
                            (this.loadCounter = 0),
                            (this.didLoadBound = this.didLoad.bind(this)),
                            (this.addObjectBound = this.addObject.bind(this)),
                            (this.container = new r.G()),
                            (this.container.matrixAutoUpdate = !1),
                            (this.loadingQueue = []);
                    }
                    destroy() {
                        this.loadingQueue.length = 0;
                        for (let i in this.pools) {
                            var e;
                            for (let e of this.pools[i]) e.destroy();
                            null === (e = Vn[i].geo) || void 0 === e || e.destroy();
                        }
                        for (let i of this.active) {
                            var t;
                            null === (t = i.destroy) || void 0 === t || t.call(i);
                        }
                        for (
                            this.container.traverse((e) => {
                                e.isMesh && (e.geometry.dispose(), e.material.dispose());
                            }),
                                this.active.length = 0,
                                this.pools = {};
                            this.container.children.length;

                        )
                            this.container.remove(this.container.children[0]);
                    }
                    initialise(e) {
                        (this.getHeightAt = e), this.initLibrary();
                    }
                    initLibrary() {
                        for (let e in Vn) this.loadObject(e), (this.pools[e] = []);
                    }
                    loadObject(e) {
                        let t = Vn[e],
                            i = new t.class();
                        i.initialiseGeometry(() => {
                            (t.geo = i), this.didLoad();
                        });
                    }
                    didLoad() {
                        if ((this.loadCounter++, this.loadCounter >= Object.keys(Vn).length))
                            for (; this.loadingQueue.length; ) {
                                let e = this.loadingQueue.pop();
                                this.addObject(...e);
                            }
                    }
                    addCustom(e, t, i, s, n = null) {
                        if ((n || (n = 5), $t.vehicleIndex > s + n)) return;
                        let a;
                        for (
                            e.keyName = null, e.worldPosition = t.clone(), e.position.subVectors(e.worldPosition, this.container.position), e.rotation.y = i, e.visible = !0, e.retireIndex = s + n, this.container.add(e), a = 0;
                            a < this.active.length && !(this.active[a].retireIndex > e.retireIndex);
                            a++
                        );
                        this.active.splice(a, 0, e);
                    }
                    addObject(e, t, i, s, n = null) {
                        if (!(e in Vn)) return void console.error("Unrecognised roadside object type ", e);
                        if (!Vn[e].geo) return void this.loadingQueue.push([e, t, i, s, n]);
                        let a, o;
                        for (
                            this.pools[e].length ? (a = this.pools[e].pop()) : ((a = Vn[e].geo.clone()), this.container.add(a), en["roadside-objects"]++),
                                a.keyName = e,
                                a.worldPosition.copy(t),
                                a.position.subVectors(a.worldPosition, this.container.position),
                                a.rotation.y = i,
                                a.visible = !0,
                                a.retireIndex = s + 5,
                                null !== n && a.setVariant(n),
                                o = 0;
                            o < this.active.length && !(this.active[o].retireIndex > a.retireIndex);
                            o++
                        );
                        return this.active.splice(o, 0, a), a;
                    }
                    update() {
                        if (this.active.length && $t.vehicleIndex >= this.active[0].retireIndex) {
                            let e = this.active.shift();
                            (e.visible = !1), e.keyName ? this.pools[e.keyName].push(e) : this.container.remove(e);
                        }
                        if (this.active.length > 30) {
                            let e = this.active.shift();
                            (e.visible = !1), e.keyName ? this.pools[e.keyName].push(e) : this.container.remove(e);
                        }
                        if ($t.vehicleIndex - this.lastRepositionIndex > 100) {
                            (this.container.position.x = $t.vehicleNode.p.x), (this.container.position.z = $t.vehicleNode.p.z), this.container.updateMatrix();
                            for (let e of this.container.children) e.position.subVectors(e.worldPosition, this.container.position);
                            this.lastRepositionIndex = $t.vehicleIndex;
                        }
                    }
                })(),
                Jn = i.p + "static/media/wall_barrier_02.44c5c0ea.webp",
                qn = i.p + "static/media/wall_barrier_02_n.0c79c69f.webp";
            const Kn = 0.78,
                _n = 151;
            let $n = 0.55,
                ea = 0.68,
                ta = 0.88,
                ia = 0,
                sa = null;
            const na = $e(Jn, 0.75, 8, qn, null, {}),
                aa = {};
            class oa extends Dn {
                constructor(e = null) {
                    super(),
                        (this.p = new r.W()),
                        (this.mapSource = null),
                        (this.normSource = null),
                        (this.bounds = { maxX: 0, minX: 0, maxY: 0, minY: 0, maxZ: 0, minZ: 0 }),
                        (this.material = na),
                        (this.mesh = new r.B(oa.getGeo(), this.material)),
                        (this.mesh.matrixAutoUpdate = !1),
                        this.mesh.geometry.setDrawRange(0, 0),
                        (this.posAttribute = this.mesh.geometry.attributes.position),
                        (this.posArr = this.posAttribute.array),
                        (this.normAttribute = this.mesh.geometry.attributes.normal),
                        (this.normArr = this.normAttribute.array),
                        (this.uvAttribute = this.mesh.geometry.attributes.uv),
                        (this.uvArr = this.uvAttribute.array),
                        e && this.drawSegment(e),
                        this.applyMaterial();
                }
                applyMaterial() {
                    this.mapSource && (this.material.map = et(this.mapSource, 4)), this.normSource && (this.material.normalMap = et(this.normSource, 4));
                }
                setMap(e) {
                    this.material.map = e;
                }
                drawSegment(e) {
                    return (
                        (this.seg = e),
                        (this.drawNode = this.seg.startNode),
                        (this.pi = 0),
                        (this.normi = 0),
                        (this.ui = 0),
                        (this.ox = this.seg.startNode.p.x),
                        (this.oz = this.seg.startNode.p.z),
                        (this.uvDist = 0),
                        (this.side = Math.sign(e.distance)),
                        (this.ni = 0),
                        this.drawNextNode()
                    );
                }
                drawNextNode() {
                    for (
                        aa.dnp = this.drawNode.p,
                            this.ni > 0
                                ? ((this.bounds.maxX = Math.max(this.bounds.maxX, aa.dnp.x - this.ox)),
                                  (this.bounds.minX = Math.min(this.bounds.minX, aa.dnp.x - this.ox)),
                                  (this.bounds.maxY = Math.max(this.bounds.maxY, aa.dnp.y)),
                                  (this.bounds.minY = Math.min(this.bounds.minY, aa.dnp.y)),
                                  (this.bounds.maxZ = Math.max(this.bounds.maxZ, aa.dnp.z - this.oz)),
                                  (this.bounds.minZ = Math.min(this.bounds.minZ, aa.dnp.z - this.oz)))
                                : ((this.bounds.maxX = aa.dnp.x - this.ox),
                                  (this.bounds.minX = aa.dnp.x - this.ox),
                                  (this.bounds.maxY = aa.dnp.y),
                                  (this.bounds.minY = aa.dnp.y),
                                  (this.bounds.maxZ = aa.dnp.z - this.oz),
                                  (this.bounds.minZ = aa.dnp.z - this.oz)),
                            aa.j = 0;
                        aa.j < this.drawNode.ps.length;
                        aa.j += 2
                    )
                        (aa.pj = this.drawNode.ps[aa.j]),
                            (aa.nj = this.drawNode.ns[aa.j]),
                            (aa.njs = { x: aa.nj.x * -this.side, z: aa.nj.z * -this.side }),
                            (aa.x = aa.pj.x + aa.nj.x * this.seg.distance),
                            (aa.x1 = aa.x + 0.1 * aa.nj.x * this.side),
                            (aa.z = aa.pj.z + aa.nj.z * this.seg.distance),
                            (aa.z1 = aa.z + 0.1 * aa.nj.z * this.side),
                            (this.normArr[this.pi] = aa.njs.x),
                            (this.posArr[this.pi++] = aa.x1 - this.ox),
                            (this.normArr[this.pi] = 0),
                            (this.posArr[this.pi++] = aa.pj.y),
                            (this.normArr[this.pi] = aa.njs.z),
                            (this.posArr[this.pi++] = aa.z1 - this.oz),
                            nt > 2 &&
                                ((this.normArr[this.pi] = aa.njs.x),
                                (this.posArr[this.pi++] = aa.x1 - this.ox),
                                (this.normArr[this.pi] = 0),
                                (this.posArr[this.pi++] = aa.pj.y + 0.42900000000000005),
                                (this.normArr[this.pi] = aa.njs.z),
                                (this.posArr[this.pi++] = aa.z1 - this.oz)),
                            nt > 1 &&
                                ((this.normArr[this.pi] = aa.njs.x),
                                (this.posArr[this.pi++] = aa.x - this.ox),
                                (this.normArr[this.pi] = 0),
                                (this.posArr[this.pi++] = aa.pj.y + 0.5304000000000001),
                                (this.normArr[this.pi] = aa.njs.z),
                                (this.posArr[this.pi++] = aa.z - this.oz)),
                            nt > 0 &&
                                ((this.normArr[this.pi] = aa.njs.x),
                                (this.posArr[this.pi++] = aa.x - this.ox),
                                (this.normArr[this.pi] = 0),
                                (this.posArr[this.pi++] = aa.pj.y + 0.6864),
                                (this.normArr[this.pi] = aa.njs.z),
                                (this.posArr[this.pi++] = aa.z - this.oz)),
                            (this.normArr[this.pi] = aa.njs.x),
                            (this.posArr[this.pi++] = aa.x1 - this.ox),
                            (this.normArr[this.pi] = 0),
                            (this.posArr[this.pi++] = aa.pj.y + Kn),
                            (this.normArr[this.pi] = aa.njs.z),
                            (this.posArr[this.pi++] = aa.z1 - this.oz);
                    if ((this.ni++, (this.drawNode = this.drawNode.next), this.drawNode.i < this.seg.endNode.i)) return !1;
                    if (
                        ((aa.pj = this.drawNode.p),
                        (aa.nj = this.drawNode.n),
                        (aa.njs = { x: aa.nj.x * -this.side, z: aa.nj.z * -this.side }),
                        (aa.x = aa.pj.x + aa.nj.x * this.seg.distance),
                        (aa.z = aa.pj.z + aa.nj.z * this.seg.distance),
                        (aa.x1 = aa.x + 0.1 * aa.nj.x * this.side),
                        (aa.z1 = aa.z + 0.1 * aa.nj.z * this.side),
                        (this.normArr[this.pi] = aa.njs.x),
                        (this.posArr[this.pi++] = aa.x1 - this.ox),
                        (this.normArr[this.pi] = 0),
                        (this.posArr[this.pi++] = aa.pj.y),
                        (this.normArr[this.pi] = aa.njs.z),
                        (this.posArr[this.pi++] = aa.z1 - this.oz),
                        nt > 2 &&
                            ((this.normArr[this.pi] = aa.njs.x),
                            (this.posArr[this.pi++] = aa.x1 - this.ox),
                            (this.normArr[this.pi] = 0),
                            (this.posArr[this.pi++] = aa.pj.y + 0.42900000000000005),
                            (this.normArr[this.pi] = aa.njs.z),
                            (this.posArr[this.pi++] = aa.z1 - this.oz)),
                        nt > 1 &&
                            ((this.normArr[this.pi] = aa.njs.x),
                            (this.posArr[this.pi++] = aa.x - this.ox),
                            (this.normArr[this.pi] = 0),
                            (this.posArr[this.pi++] = aa.pj.y + 0.5304000000000001),
                            (this.normArr[this.pi] = aa.njs.z),
                            (this.posArr[this.pi++] = aa.z - this.oz)),
                        nt > 0 &&
                            ((this.normArr[this.pi] = aa.njs.x),
                            (this.posArr[this.pi++] = aa.x - this.ox),
                            (this.normArr[this.pi] = 0),
                            (this.posArr[this.pi++] = aa.pj.y + 0.6864),
                            (this.normArr[this.pi] = aa.njs.z),
                            (this.posArr[this.pi++] = aa.z - this.oz)),
                        (this.normArr[this.pi] = aa.njs.x),
                        (this.posArr[this.pi++] = aa.x1 - this.ox),
                        (this.normArr[this.pi] = 0),
                        (this.posArr[this.pi++] = aa.pj.y + Kn),
                        (this.normArr[this.pi] = aa.njs.z),
                        (this.posArr[this.pi++] = aa.z1 - this.oz),
                        this.mesh.geometry.setDrawRange(0, 5 * this.seg.length * (2 * (nt + 1)) * 3),
                        this.computeBoundingSphere(),
                        (this.mesh.geometry.boundingSphere = this.boundingSphere),
                        this.mesh.position.set(this.ox, -0.15, this.oz),
                        (this.posAttribute.needsUpdate = !0),
                        (this.normAttribute.needsUpdate = !0),
                        (this.mesh.visible = !0),
                        this.mesh.updateMatrix(),
                        !this.seg.contiguousStart)
                    )
                        for (
                            this.p.x = this.posArr[0] + this.mesh.position.x,
                                this.p.y = this.posArr[1],
                                this.p.z = this.posArr[2] + this.mesh.position.z,
                                Xn.addObject(Un.VergeMarker, this.p, Math.PI + Math.PI / 2 - this.seg.startNode.a, this.seg.startNode.i),
                                aa.ii = 0;
                            aa.ii < nt + 2;
                            aa.ii++
                        )
                            this.posArr[3 * aa.ii + 1] -= Kn;
                    if (!this.seg.contiguousEnd) for (aa.ii = 0; aa.ii < nt + 2; aa.ii++) this.posArr[this.pi - (3 * aa.ii + 2)] -= Kn;
                    return !0;
                }
                retire() {
                    this.mesh.visible = !1;
                }
                computeBoundingSphere() {
                    (aa.minX = this.bounds.minX),
                        (aa.maxX = this.bounds.maxX),
                        (aa.minY = this.bounds.minY),
                        (aa.maxY = this.bounds.maxY),
                        (aa.minZ = this.bounds.minZ),
                        (aa.maxZ = this.bounds.maxZ),
                        (this.boundingSphere.center.x = (aa.minX + aa.maxX) / 2),
                        (this.boundingSphere.center.y = (aa.minY + aa.maxY) / 2),
                        (this.boundingSphere.center.z = (aa.minZ + aa.maxZ) / 2),
                        (this.boundingSphere.radius = Math.sqrt((aa.maxX - aa.minX) * (aa.maxX - aa.minX) + (aa.maxY - aa.minY) * (aa.maxY - aa.minY) + (aa.maxZ - aa.minZ) * (aa.maxZ - aa.minZ)) / 2 + 10);
                }
                static getNorms() {
                    let e = [];
                    for (let t = 0; t < _n * (nt + 2); t++) e.push(0, 0, 1);
                    return e;
                }
                static getUV() {
                    let e = [];
                    for (let t = 0; t < _n; t++) 0 == nt ? e.push(t, 0, t, 1) : 1 == nt ? e.push(t, 0, t, ta, t, 1) : 2 == nt ? e.push(t, 0, t, $n, t, ta, t, 1) : e.push(t, 0, t, $n, t, ea, t, ta, t, 1);
                    return e;
                }
                static getGeo() {
                    if (null !== sa && ia == nt) return sa.clone();
                    let e = new r.g();
                    e.setIndex(oa.getIndex()), e.setAttribute("position", new r.o(new Float32Array(453 * (nt + 2)), 3)), e.attributes.position.setUsage(r.l), e.setAttribute("uv", new r.o(new Float32Array(oa.getUV()), 2));
                    let t = new Float32Array(oa.getNorms());
                    return e.setAttribute("normal", new r.o(t, 3)), e.attributes.normal.setUsage(r.l), (sa = e), (ia = nt), e;
                }
                static getIndex() {
                    let e = [];
                    if (0 == nt) {
                        let t, i, s, n;
                        for (let a = 0; a < _n; a++) (t = 2 * a), (i = t + 1), (s = 2 * (a + 1)), (n = s + 1), e.push(t, i, s), e.push(i, n, s);
                    } else if (1 == nt) {
                        let t, i, s, n, a, o;
                        for (let r = 0; r < _n; r++) (t = 3 * r), (i = t + 1), (s = t + 2), (n = 3 * (r + 1)), (a = n + 1), (o = n + 2), e.push(t, i, n, i, a, n, i, s, a, s, o, a);
                    } else if (2 == nt) {
                        let t, i, s, n, a, o, r, h;
                        for (let l = 0; l < _n; l++) (t = 4 * l), (i = t + 1), (s = t + 2), (n = t + 3), (a = 4 * (l + 1)), (o = a + 1), (r = a + 2), (h = a + 3), e.push(t, i, a, i, o, a, i, s, o, s, r, o, s, n, r, n, h, r);
                    } else {
                        let t, i, s, n, a, o, r, h, l, d;
                        for (let c = 0; c < _n; c++)
                            (t = 5 * c),
                                (i = t + 1),
                                (s = t + 2),
                                (n = t + 3),
                                (a = t + 4),
                                (o = 5 * (c + 1)),
                                (r = o + 1),
                                (h = o + 2),
                                (l = o + 3),
                                (d = o + 4),
                                e.push(t, i, o, i, r, o, i, s, r, s, h, r, s, n, h, n, l, h, n, a, l, a, d, l);
                    }
                    return e;
                }
            }
            class ra extends Tn {
                constructor(...e) {
                    super(...e), (this.fenceID = 4);
                }
                generate(e) {
                    let t = e.prev;
                    for (e = e.next; this.test(t) && t.prev && t.i > this.prev.endNode.i && e.i - t.i < 11; ) t = t.prev;
                    for (t.i - this.prev.endNode.i < 4 && (t = this.prev.endNode); this.test(e) && e.i - t.i < Ut; ) e = e.next;
                    let i = this.typeID;
                    Ih.value.detailLodIndex > 1 && (t.i % 2 == 0 || (this.prev.endNode.i == t.i && this.prev.type == this.fenceID)) && (i = this.fenceID);
                    let s = new Rn(t, e, i, (t.w + Ht) * this.side);
                    return this.prev.endNode.i == t.i && this.prev.type == s.type && ((this.prev.contiguousEnd = !0), (s.contiguousStart = !0), (s.distance = this.prev.distance)), s;
                }
                testGenLeft(e) {
                    return !e.bridge && null == e.lWallDist && e.i >= this.prevLeft.endNode.i && (e.g < -1 || (e.g < 0 && e.da > 0.2 && e.h < 0.6));
                }
                testGenRight(e) {
                    return !e.bridge && null == e.rWallDist && e.i >= this.prevRight.endNode.i && (e.g > 1 || (e.g > 0 && e.da < -0.2 && e.h < 0.6));
                }
                testLeft(e) {
                    return !e.bridge && e.p.y > 3 && (e.g < -0.5 || (e.g < 0.1 && e.da < -0.05 && e.h < 0.6));
                }
                testRight(e) {
                    return !e.bridge && e.p.y > 3 && (e.g > 0.5 || (e.g > -0.1 && e.da > 0.05 && e.h < 0.6));
                }
            }
            var ha = oa,
                la = i.p + "static/media/wall_barrier_wood_n.f554ec90.webp";
            let da = 0.52,
                ca = 0.56,
                pa = 0.8,
                ua = 0.956,
                ga = 0,
                ma = null;
            const xa = $e(null, 0.75, 8, la, null, {}),
                va = {};
            class fa extends Dn {
                constructor(e = null) {
                    super(),
                        (this.p = new r.W()),
                        (this.postIndex = []),
                        (this.fenceIndex = []),
                        (this.drawIndex = []),
                        (this.fenceIndexTemplate = []),
                        (this.mapSource = null),
                        (this.normSource = null),
                        (this.bounds = { maxX: 0, minX: 0, maxY: 0, minY: 0, maxZ: 0, minZ: 0 }),
                        (this.material = xa),
                        (this.mesh = new r.B(fa.getGeo(), this.material)),
                        (this.mesh.matrixAutoUpdate = !1),
                        this.mesh.geometry.setDrawRange(0, 0),
                        (this.posAttribute = this.mesh.geometry.attributes.position),
                        (this.posArr = this.posAttribute.array),
                        (this.normAttribute = this.mesh.geometry.attributes.normal),
                        (this.normArr = this.normAttribute.array),
                        (this.uvAttribute = this.mesh.geometry.attributes.uv),
                        (this.uvArr = this.uvAttribute.array),
                        (this.fenceIndexTemplate = fa.getFenceIndex()),
                        e && this.drawSegment(e),
                        this.applyMaterial();
                }
                applyMaterial() {
                    this.mapSource && (this.material.map = et(this.mapSource, 4)), this.normSource && (this.material.normalMap = et(this.normSource, 4));
                }
                setMap(e) {
                    this.material.map = e;
                }
                drawSegment(e) {
                    return (
                        (this.seg = e),
                        (this.drawNode = this.seg.startNode),
                        (this.pi = 0),
                        (this.ui = 0),
                        (this.normi = 0),
                        (this.postI = 6 * (2 * this.seg.length + 1) * 3),
                        (this.postUVI = 6 * (2 * this.seg.length + 1) * 2),
                        (this.postIndex.length = 0),
                        (this.ox = this.seg.startNode.p.x),
                        (this.oz = this.seg.startNode.p.z),
                        (this.uvDist = 0),
                        (this.side = Math.sign(e.distance)),
                        (this.ni = 0),
                        (this.si = 0),
                        (this.fenceDrawCount = 60 * this.seg.length),
                        (this.fenceVertCount = 0),
                        (this.fenceIndex.length = 0),
                        (this.fenceTriangleCount = 0),
                        (this.postIndexCount = 6 * (2 * this.seg.length + 1)),
                        (this.postDrawCount = 0),
                        this.drawNextNode()
                    );
                }
                updateBounds() {
                    (va.dnp = this.drawNode.p),
                        this.ni > 0
                            ? ((this.bounds.maxX = Math.max(this.bounds.maxX, va.dnp.x - this.ox)),
                              (this.bounds.minX = Math.min(this.bounds.minX, va.dnp.x - this.ox)),
                              (this.bounds.maxY = Math.max(this.bounds.maxY, va.dnp.y)),
                              (this.bounds.minY = Math.min(this.bounds.minY, va.dnp.y)),
                              (this.bounds.maxZ = Math.max(this.bounds.maxZ, va.dnp.z - this.oz)),
                              (this.bounds.minZ = Math.min(this.bounds.minZ, va.dnp.z - this.oz)))
                            : ((this.bounds.maxX = va.dnp.x - this.ox),
                              (this.bounds.minX = va.dnp.x - this.ox),
                              (this.bounds.maxY = va.dnp.y),
                              (this.bounds.minY = va.dnp.y),
                              (this.bounds.maxZ = va.dnp.z - this.oz),
                              (this.bounds.minZ = va.dnp.z - this.oz));
                }
                drawFenceVert(e, t, i, s, n = 0) {
                    (this.normArr[this.pi] = va.njs.x),
                        (this.posArr[this.pi++] = e),
                        (this.normArr[this.pi] = 0),
                        (this.posArr[this.pi++] = va.pj.y + 1 * t + n),
                        (this.normArr[this.pi] = va.njs.z),
                        (this.posArr[this.pi++] = i),
                        (this.uvArr[this.ui++] = this.si),
                        (this.uvArr[this.ui++] = 0.4 * s);
                }
                buildNextFenceIndex() {
                    for (va.fi = 3 * this.fenceTriangleCount, va.i = 0; va.i < 30; va.i++) this.fenceIndex.push(this.fenceIndexTemplate[va.fi + va.i]);
                    this.fenceTriangleCount += 10;
                }
                drawFencePost() {
                    (va.xA = va.x - 0.02 * va.nj.x * this.side + 0.06 * -va.nj.z),
                        (va.zA = va.z - 0.02 * va.nj.z * this.side + 0.06 * va.nj.x),
                        (va.xB = va.x + 0.11 * va.nj.x * this.side + 0.06 * -va.nj.z),
                        (va.zB = va.z + 0.11 * va.nj.z * this.side + 0.06 * va.nj.x),
                        (va.xC = va.x + 0.11 * va.nj.x * this.side - 0.06 * -va.nj.z),
                        (va.zC = va.z + 0.11 * va.nj.z * this.side - 0.06 * va.nj.x),
                        (va.xD = va.x - 0.02 * va.nj.x * this.side - 0.06 * -va.nj.z),
                        (va.zD = va.z - 0.02 * va.nj.z * this.side - 0.06 * va.nj.x),
                        (va.njs.x = 0),
                        (va.njs.z = 0),
                        (va.nup = 1),
                        (this.normArr[this.postI] = va.njs.x),
                        (this.posArr[this.postI++] = va.xA),
                        (this.normArr[this.postI] = va.nup),
                        (this.posArr[this.postI++] = va.pj.y),
                        (this.normArr[this.postI] = va.njs.z),
                        (this.posArr[this.postI++] = va.zA),
                        (this.normArr[this.postI] = va.njs.x),
                        (this.posArr[this.postI++] = va.xA),
                        (this.normArr[this.postI] = va.nup),
                        (this.posArr[this.postI++] = va.pj.y + 1 + 0.03),
                        (this.normArr[this.postI] = va.njs.z),
                        (this.posArr[this.postI++] = va.zA),
                        (this.normArr[this.postI] = va.njs.x),
                        (this.posArr[this.postI++] = va.xB),
                        (this.normArr[this.postI] = va.nup),
                        (this.posArr[this.postI++] = va.pj.y),
                        (this.normArr[this.postI] = va.njs.z),
                        (this.posArr[this.postI++] = va.zB),
                        (this.normArr[this.postI] = va.njs.x),
                        (this.posArr[this.postI++] = va.xB),
                        (this.normArr[this.postI] = va.nup),
                        (this.posArr[this.postI++] = va.pj.y + 1 + 0.03),
                        (this.normArr[this.postI] = va.njs.z),
                        (this.posArr[this.postI++] = va.zB),
                        (this.normArr[this.postI] = va.njs.x),
                        (this.posArr[this.postI++] = va.xC),
                        (this.normArr[this.postI] = va.nup),
                        (this.posArr[this.postI++] = va.pj.y),
                        (this.normArr[this.postI] = va.njs.z),
                        (this.posArr[this.postI++] = va.zC),
                        (this.normArr[this.postI] = va.njs.x),
                        (this.posArr[this.postI++] = va.xC),
                        (this.normArr[this.postI] = va.nup),
                        (this.posArr[this.postI++] = va.pj.y + 1 + 0.03),
                        (this.normArr[this.postI] = va.njs.z),
                        (this.posArr[this.postI++] = va.zC),
                        (this.normArr[this.postI] = va.njs.x),
                        (this.posArr[this.postI++] = va.xD),
                        (this.normArr[this.postI] = va.nup),
                        (this.posArr[this.postI++] = va.pj.y),
                        (this.normArr[this.postI] = va.njs.z),
                        (this.posArr[this.postI++] = va.zD),
                        (this.normArr[this.postI] = va.njs.x),
                        (this.posArr[this.postI++] = va.xD),
                        (this.normArr[this.postI] = va.nup),
                        (this.posArr[this.postI++] = va.pj.y + 1 + 0.03),
                        (this.normArr[this.postI] = va.njs.z),
                        (this.posArr[this.postI++] = va.zD),
                        (this.normArr[this.postI] = va.njs.x),
                        (this.posArr[this.postI++] = va.xD),
                        (this.normArr[this.postI] = va.nup),
                        (this.posArr[this.postI++] = va.pj.y + 1 + 0.03),
                        (this.normArr[this.postI] = va.njs.z),
                        (this.posArr[this.postI++] = va.zD),
                        (this.uvArr[this.postUVI++] = 0.25),
                        (this.uvArr[this.postUVI++] = 1),
                        (this.uvArr[this.postUVI++] = 0.25),
                        (this.uvArr[this.postUVI++] = 0.5),
                        (this.uvArr[this.postUVI++] = 0.5),
                        (this.uvArr[this.postUVI++] = 1),
                        (this.uvArr[this.postUVI++] = 0.5),
                        (this.uvArr[this.postUVI++] = 0.5),
                        (this.uvArr[this.postUVI++] = 0.75),
                        (this.uvArr[this.postUVI++] = 1),
                        (this.uvArr[this.postUVI++] = 0.75),
                        (this.uvArr[this.postUVI++] = 0.5),
                        (this.uvArr[this.postUVI++] = 0),
                        (this.uvArr[this.postUVI++] = 1),
                        (this.uvArr[this.postUVI++] = 0),
                        (this.uvArr[this.postUVI++] = 0.5),
                        (this.uvArr[this.postUVI++] = 0.5),
                        (this.uvArr[this.postUVI++] = 0.42),
                        this.postIndex.push(
                            this.postIndexCount,
                            this.postIndexCount + 3,
                            this.postIndexCount + 1,
                            this.postIndexCount,
                            this.postIndexCount + 2,
                            this.postIndexCount + 3,
                            this.postIndexCount + 2,
                            this.postIndexCount + 5,
                            this.postIndexCount + 3,
                            this.postIndexCount + 2,
                            this.postIndexCount + 4,
                            this.postIndexCount + 5,
                            this.postIndexCount + 4,
                            this.postIndexCount + 7,
                            this.postIndexCount + 5,
                            this.postIndexCount + 4,
                            this.postIndexCount + 6,
                            this.postIndexCount + 7,
                            this.postIndexCount + 6,
                            this.postIndexCount + 1,
                            this.postIndexCount + 7,
                            this.postIndexCount + 6,
                            this.postIndexCount,
                            this.postIndexCount + 1,
                            this.postIndexCount + 1,
                            this.postIndexCount + 3,
                            this.postIndexCount + 8,
                            this.postIndexCount + 3,
                            this.postIndexCount + 5,
                            this.postIndexCount + 8
                        ),
                        (this.postIndexCount += 9),
                        (this.postDrawCount += 30);
                }
                drawNextNode(e = !1) {
                    for (this.updateBounds(), va.j = 0; va.j < this.drawNode.ps.length; va.j += 5)
                        (va.pj = this.drawNode.ps[va.j]),
                            (va.nj = this.drawNode.ns[va.j]),
                            (va.njs = { x: va.nj.x * -this.side, z: va.nj.z * -this.side }),
                            (va.x = va.pj.x + va.nj.x * this.seg.distance - this.ox),
                            (va.x1 = va.x + 0.08 * va.nj.x * this.side),
                            (va.z = va.pj.z + va.nj.z * this.seg.distance - this.oz),
                            (va.z1 = va.z + 0.08 * va.nj.z * this.side),
                            (va.rand = 0.06 * Math.random() - 0.03),
                            (va.rand2 = 0.06 * Math.random() - 0.03),
                            this.drawFenceVert(va.x, 0, va.z, 0, va.rand),
                            this.drawFenceVert(va.x, ca, va.z, da, va.rand),
                            this.drawFenceVert(va.x1, ca, va.z1, ca, va.rand),
                            this.drawFenceVert(va.x, pa, va.z, pa, va.rand2),
                            this.drawFenceVert(va.x, 1, va.z, ua, va.rand2),
                            this.drawFenceVert(va.x1, 1, va.z1, 1, va.rand2),
                            (this.ni > 0 || 0 == va.j) && this.buildNextFenceIndex(),
                            (this.ni > 0 || this.seg.contiguousStart || va.j > 0) && this.drawFencePost(),
                            this.si++;
                    if ((this.ni++, (this.drawNode = this.drawNode.next), this.drawNode.i < this.seg.endNode.i)) return !1;
                    if (
                        (this.updateBounds(),
                        (va.pj = this.drawNode.p),
                        (va.nj = this.drawNode.n),
                        (va.njs = { x: va.nj.x * -this.side, z: va.nj.z * -this.side }),
                        (va.x = va.pj.x + va.nj.x * this.seg.distance - this.ox),
                        (va.z = va.pj.z + va.nj.z * this.seg.distance - this.oz),
                        (va.x1 = va.x + 0.1 * va.nj.x * this.side),
                        (va.z1 = va.z + 0.1 * va.nj.z * this.side),
                        this.drawFenceVert(va.x, 0, va.z, 0),
                        this.drawFenceVert(va.x, ca, va.z, da),
                        this.drawFenceVert(va.x1, ca, va.z1, ca),
                        this.drawFenceVert(va.x, pa, va.z, pa),
                        this.drawFenceVert(va.x, 1, va.z, ua),
                        this.drawFenceVert(va.x1, 1, va.z1, 1),
                        this.buildNextFenceIndex(),
                        this.seg.contiguousEnd && this.drawFencePost(),
                        this.si++,
                        this.mesh.geometry.setDrawRange(0, this.fenceDrawCount + this.postDrawCount),
                        this.computeBoundingSphere(),
                        (this.mesh.geometry.boundingSphere = this.boundingSphere),
                        (this.drawIndex = this.fenceIndex.concat(this.postIndex)),
                        this.mesh.geometry.setIndex(this.drawIndex),
                        this.mesh.position.set(this.ox, -0.15, this.oz),
                        (this.posAttribute.needsUpdate = !0),
                        (this.normAttribute.needsUpdate = !0),
                        (this.uvAttribute.needsUpdate = !0),
                        (this.mesh.visible = !0),
                        this.mesh.updateMatrix(),
                        !this.seg.contiguousStart)
                    )
                        for (
                            this.p.x = this.posArr[0] + this.mesh.position.x,
                                this.p.y = this.posArr[1],
                                this.p.z = this.posArr[2] + this.mesh.position.z,
                                Xn.addObject(Un.VergeMarker, this.p, Math.PI + Math.PI / 2 - this.seg.startNode.a, this.seg.startNode.i),
                                va.ii = 0;
                            va.ii < 6;
                            va.ii++
                        )
                            this.posArr[3 * va.ii + 1] -= 1;
                    if (!this.seg.contiguousEnd) for (va.ii = 0; va.ii < 6; va.ii++) this.posArr[this.pi - (3 * va.ii + 2)] -= 1;
                    return !0;
                }
                retire() {
                    this.mesh.visible = !1;
                }
                computeBoundingSphere() {
                    (va.minX = this.bounds.minX),
                        (va.maxX = this.bounds.maxX),
                        (va.minY = this.bounds.minY),
                        (va.maxY = this.bounds.maxY),
                        (va.minZ = this.bounds.minZ),
                        (va.maxZ = this.bounds.maxZ),
                        (this.boundingSphere.center.x = (va.minX + va.maxX) / 2),
                        (this.boundingSphere.center.y = (va.minY + va.maxY) / 2),
                        (this.boundingSphere.center.z = (va.minZ + va.maxZ) / 2),
                        (this.boundingSphere.radius = Math.sqrt((va.maxX - va.minX) * (va.maxX - va.minX) + (va.maxY - va.minY) * (va.maxY - va.minY) + (va.maxZ - va.minZ) * (va.maxZ - va.minZ)) / 2 + 10);
                }
                static getNorms() {
                    let e = [];
                    for (let t = 0; t < 366; t++) e.push(0, 0, 1);
                    return e;
                }
                static getUV() {
                    let e = [];
                    for (let t = 0; t < 61; t++) e.push(t, 0, t, da, t, ca, t, pa, t, ua, t, 1);
                    return e;
                }
                static getGeo() {
                    if (null !== ma && ga == nt) return ma.clone();
                    let e = new r.g();
                    return (
                        e.setAttribute("position", new r.o(new Float32Array(5490), 3)),
                        e.attributes.position.setUsage(r.l),
                        e.setAttribute("uv", new r.o(new Float32Array(3660), 2)),
                        e.attributes.uv.setUsage(r.l),
                        e.setAttribute("normal", new r.o(new Float32Array(5490), 3)),
                        e.attributes.normal.setUsage(r.l),
                        (ma = e),
                        (ga = nt),
                        e
                    );
                }
                static getFenceIndex() {
                    let e,
                        t,
                        i,
                        s,
                        n,
                        a,
                        o,
                        r,
                        h,
                        l,
                        d,
                        c,
                        p = [];
                    for (let u = 0; u < 61; u++)
                        (e = 6 * u),
                            (t = e + 1),
                            (i = e + 2),
                            (s = e + 3),
                            (n = e + 4),
                            (a = e + 5),
                            (o = 6 * (u + 1)),
                            (r = o + 1),
                            (h = o + 2),
                            (l = o + 3),
                            (d = o + 4),
                            (c = o + 5),
                            p.push(e, t, o, t, r, o, t, i, r, i, h, r, i, s, h, s, l, h, s, n, l, n, d, l, n, a, d, a, c, d);
                    return p;
                }
            }
            var wa = fa;
            const ba = 2.3,
                Aa = 0.3833333333333333,
                ya = 0.19166666666666665,
                Ia = new r.F({ map: null, flatShading: !0 }),
                Sa = {};
            class Ma extends Tn {
                generate(e) {
                    let t = e.prev;
                    for (e = e.next; this.testGen(t) && t.prev && e.i - t.i < 4; ) t = t.prev;
                    for (t.i - this.prev.endNode.i < 4 && (t = this.prev.endNode); this.testGen(e) && e.i - t.i < Ut; ) e = e.next;
                    let i = new Rn(t, e, this.typeID, (t.w + 0) * this.side);
                    return this.prev.endNode.i == t.i && this.prev.type == i.type && ((this.prev.contiguousEnd = !0), (i.contiguousStart = !0), (i.distance = this.prev.distance)), i;
                }
                testGenLeft(e) {
                    return e.bridge && e.i >= this.prev.endNode.i;
                }
                testGenRight(e) {
                    return e.bridge && e.i >= this.prev.endNode.i;
                }
                testGen(e) {
                    return e.bridge && e.i >= this.prev.endNode.i;
                }
                testLeft(e) {
                    return e.bridge;
                }
                testRight(e) {
                    return e.bridge;
                }
            }
            var Da = class extends Ln {
                constructor(...e) {
                    super(...e), (this.mapSource = Fs.skins.default.walls.sea), (this.p = new r.W()), (this.mesh.material = Ia);
                }
                drawSegment(e) {
                    return (
                        (this.seg = e),
                        (this.drawNode = this.seg.startNode),
                        (this.pi = 0),
                        (this.ui = 0),
                        (this.ox = this.seg.startNode.p.x),
                        (this.oz = this.seg.startNode.p.z),
                        (this.lOffset = this.seg.distance < 0 ? Aa : 0),
                        (this.uvDist = 0),
                        (this.ux1 = 1.15),
                        (this.ux2 = 1.3416666666666666),
                        (this.ux3 = 2.4916666666666663),
                        (this.ni = 0),
                        this.drawNextNode()
                    );
                }
                drawNextNode() {
                    for (
                        Sa.dnp = this.drawNode.p,
                            this.ni > 0
                                ? ((this.bounds.maxX = Math.max(this.bounds.maxX, Sa.dnp.x - this.ox)),
                                  (this.bounds.minX = Math.min(this.bounds.minX, Sa.dnp.x - this.ox)),
                                  (this.bounds.maxY = Math.max(this.bounds.maxY, Sa.dnp.y)),
                                  (this.bounds.minY = Math.min(this.bounds.minY, Sa.dnp.y)),
                                  (this.bounds.maxZ = Math.max(this.bounds.maxZ, Sa.dnp.z - this.oz)),
                                  (this.bounds.minZ = Math.min(this.bounds.minZ, Sa.dnp.z - this.oz)))
                                : ((this.bounds.maxX = Sa.dnp.x - this.ox),
                                  (this.bounds.minX = Sa.dnp.x - this.ox),
                                  (this.bounds.maxY = Sa.dnp.y),
                                  (this.bounds.minY = Sa.dnp.y),
                                  (this.bounds.maxZ = Sa.dnp.z - this.oz),
                                  (this.bounds.minZ = Sa.dnp.z - this.oz)),
                            Sa.j = 0;
                        Sa.j < this.drawNode.ps.length;
                        Sa.j += 2
                    )
                        (Sa.pj = this.drawNode.ps[Sa.j]),
                            (Sa.nj = this.drawNode.ns[Sa.j]),
                            (Sa.x = Sa.pj.x + Sa.nj.x * (this.seg.distance - this.lOffset)),
                            (Sa.xw = Sa.x + Sa.nj.x * Aa),
                            (Sa.z = Sa.pj.z + Sa.nj.z * (this.seg.distance - this.lOffset)),
                            (Sa.zw = Sa.z + Sa.nj.z * Aa),
                            (this.posArr[this.pi++] = Sa.x - this.ox - Sa.nj.x * ya),
                            (this.posArr[this.pi++] = Sa.pj.y),
                            (this.posArr[this.pi++] = Sa.z - this.oz - Sa.nj.z * ya),
                            (this.posArr[this.pi++] = Sa.x - this.ox),
                            (this.posArr[this.pi++] = Sa.pj.y + ba),
                            (this.posArr[this.pi++] = Sa.z - this.oz),
                            (this.posArr[this.pi++] = Sa.xw - this.ox),
                            (this.posArr[this.pi++] = Sa.pj.y + ba),
                            (this.posArr[this.pi++] = Sa.zw - this.oz),
                            (this.posArr[this.pi++] = Sa.xw - this.ox + Sa.nj.x * ya),
                            (this.posArr[this.pi++] = Sa.pj.y),
                            (this.posArr[this.pi++] = Sa.zw - this.oz + Sa.nj.z * ya),
                            this.seg.contiguousStart || 0 != this.ni || 0 != Sa.j || ((this.posArr[this.pi - 11] -= 1.15), (this.posArr[this.pi - 8] -= 1.15), (this.posArr[this.pi - 5] -= 1.15), (this.posArr[this.pi - 2] -= 1.15)),
                            (this.uvArr[this.ui++] = 0),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = this.ux1),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = this.ux2),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = this.ux3),
                            (this.uvArr[this.ui++] = this.uvDist),
                            this.uvDist++;
                    return (
                        this.ni++,
                        (this.drawNode = this.drawNode.next),
                        !(this.drawNode.i < this.seg.endNode.i) &&
                            ((Sa.pj = this.drawNode.p),
                            (Sa.nj = this.drawNode.n),
                            (Sa.x = Sa.pj.x + Sa.nj.x * (this.seg.distance - this.lOffset)),
                            (Sa.xw = Sa.x + Sa.nj.x * Aa),
                            (Sa.z = Sa.pj.z + Sa.nj.z * (this.seg.distance - this.lOffset)),
                            (Sa.zw = Sa.z + Sa.nj.z * Aa),
                            (this.posArr[this.pi++] = Sa.x - this.ox - Sa.nj.x * ya),
                            (this.posArr[this.pi++] = Sa.pj.y),
                            (this.posArr[this.pi++] = Sa.z - this.oz - Sa.nj.z * ya),
                            (this.posArr[this.pi++] = Sa.x - this.ox),
                            (this.posArr[this.pi++] = Sa.pj.y + ba),
                            (this.posArr[this.pi++] = Sa.z - this.oz),
                            (this.posArr[this.pi++] = Sa.xw - this.ox),
                            (this.posArr[this.pi++] = Sa.pj.y + ba),
                            (this.posArr[this.pi++] = Sa.zw - this.oz),
                            (this.posArr[this.pi++] = Sa.xw - this.ox + Sa.nj.x * ya),
                            (this.posArr[this.pi++] = Sa.pj.y),
                            (this.posArr[this.pi++] = Sa.zw - this.oz + Sa.nj.z * ya),
                            this.seg.contiguousEnd || ((this.posArr[this.pi - 11] -= ba), (this.posArr[this.pi - 8] -= ba), (this.posArr[this.pi - 5] -= ba), (this.posArr[this.pi - 2] -= ba)),
                            (this.uvArr[this.ui++] = 1),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = 0.55),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = 0.45),
                            (this.uvArr[this.ui++] = this.uvDist),
                            (this.uvArr[this.ui++] = 0),
                            (this.uvArr[this.ui++] = this.uvDist),
                            this.mesh.geometry.setDrawRange(0, 5 * this.seg.length * 6 * 3),
                            this.computeBoundingSphere(),
                            (this.mesh.geometry.boundingSphere = this.boundingSphere),
                            this.mesh.position.set(this.ox, -1.5, this.oz),
                            (this.posAttribute.needsUpdate = !0),
                            (this.uvAttribute.needsUpdate = !0),
                            (this.mesh.visible = !0),
                            this.mesh.updateMatrix(),
                            this.seg.contiguousStart ||
                                ((this.p.x = (this.posArr[0] + this.posArr[9]) / 2 + this.mesh.position.x),
                                (this.p.y = this.posArr[7] - 1.15),
                                (this.p.z = (this.posArr[2] + this.posArr[11]) / 2 + this.mesh.position.z),
                                Xn.addObject(Un.VergeMarker, this.p, Math.PI + Math.PI / 2 - this.seg.startNode.a, this.seg.startNode.i)),
                            !0)
                    );
                }
            };
            const ka = new r.F({ map: null, flatShading: !0 });
            class Ca extends Ln {
                constructor(...e) {
                    super(...e), (this.mapSource = Fs.skins.default.walls.sea), (this.mesh.material = ka);
                }
            }
            (Ca.waterHeight = 2.5), (Ca.waterThreshold = 3);
            class ja extends Tn {
                constructor(...e) {
                    super(...e), (this.drystoneID = 2);
                }
                generate(e) {
                    let t = e.prev;
                    for (e = e.next; this.test(t) && t.prev && e.i - t.i < 4 && t.i > this.prev.endNode.i && e.i - t.i < Ut; ) t = t.prev;
                    for (t.i - this.prev.endNode.i < 4 && (t = this.prev.endNode); this.test(e) && e.i - t.i < Ut; ) e = e.next;
                    let i = this.typeID;
                    (t.i % 2 == 0 || (this.prev.endNode.i == t.i && this.prev.type == this.drystoneID)) && (i = this.drystoneID);
                    let s = new Rn(t, e, i, (t.w + 1) * this.side);
                    return this.prev.endNode.i >= t.i && this.prev.type == s.type && ((this.prev.contiguousEnd = !0), (s.contiguousStart = !0), (s.distance = this.prev.distance)), s;
                }
                testGenLeft(e) {
                    return e.i >= this.prev.endNode.i && this.testGen(e) && this.testLeft(e);
                }
                testGenRight(e) {
                    return e.i >= this.prev.endNode.i && this.testGen(e) && this.testRight(e);
                }
                testGen(e) {
                    return !e.bridge && (e.p.y <= Ca.waterHeight || (e.i == this.prev.endNode.i && e.p.y < Ca.waterThreshold));
                }
                testLeft(e) {
                    return !e.bridge && (e.g < 0.15 || (e.p.y < Ca.waterThreshold && e.h < -0.5));
                }
                testRight(e) {
                    return !e.bridge && (e.g > 0.15 || (e.p.y < Ca.waterThreshold && e.h < -0.5));
                }
            }
            const Na = { Barrier: 0, SeaWall: 1, Drystone: 2, Bridge: 3, Fence: 4 },
                za = [ha, Ca, Yn, Da, wa];
            var Oa = class {
                constructor(e) {
                    (this.activeSegments = []),
                        (this.prevSegmentsLeft = []),
                        (this.prevSegmentsRight = []),
                        (this.stagedSegments = []),
                        (this.count = 0),
                        (this.prevWasContiguous = !1),
                        (this.getHeightAt = e),
                        (this.container = new r.G()),
                        (this.segments = []),
                        this.initPools();
                }
                destroy() {
                    for (
                        this.container.traverse((e) => {
                            e.isMesh && e.geometry.dispose();
                        });
                        this.container.children.length;

                    )
                        this.container.remove(this.container.children[0]);
                }
                initialise() {
                    (this.renderIndex = $t.vehicleIndex),
                        (this.genNode = $t.vehicleNode),
                        (this.genIndex = $t.vehicleIndex),
                        (this.genNodeLeft = $t.vehicleNode),
                        (this.genNodeRight = $t.vehicleNode),
                        (this.bridgeWallGenerator = new Ma($t.vehicleNode, Na.Bridge)),
                        (this.seaWallGenerator = new ja($t.vehicleNode, Na.SeaWall)),
                        (this.seaWallGenerator.drystoneID = Na.Drystone),
                        (this.drystoneGenerator = new Qn($t.vehicleNode, Na.Drystone, this.getHeightAt)),
                        (this.barrierGenerator = new ra($t.vehicleNode, Na.Barrier));
                    do {
                        this.updateGeneration();
                    } while (this.genIndex < $t.vehicleIndex + Yt);
                    for (; this.segments.length > 0 && $t.vehicleIndex + Vt >= this.segments[0].startNode.i; ) this.drawNextSegment();
                    do {
                        this.updateStaged();
                    } while (this.stagedSegments.length);
                }
                initPools() {
                    this.pools = [];
                    let e,
                        t,
                        i = Object.keys(Na).length;
                    for (e = 0; e < i; e++) (t = new za[e](null, this.getHeightAt)), this.container.add(t.mesh), this.pools.push([t]);
                }
                setSkin(e) {}
                handleMidlineReset() {
                    ($t.tail.i < this.genNodeLeft.i || $t.tail.i < this.genNodeRight.i) &&
                        (console.error("Wall controller must handle reset gracefully"), (this.genNodeLeft = $t.tail), (this.genNodeRight = $t.tail), (this.renderIndex = $t.tail.i));
                }
                updateGeneration() {
                    this.genIndex < $t.vehicleIndex + Yt && this.genIndex++,
                        this.genNodeLeft.i < this.genIndex && ((this.genNodeLeft = this.genNodeLeft.next), this.checkGenerateLeftSegment()),
                        this.genNodeRight.i < this.genIndex && ((this.genNodeRight = this.genNodeRight.next), this.checkGenerateRightSegment());
                }
                update() {
                    for (this.updateGeneration(); this.segments.length > 0 && $t.vehicleIndex + Vt >= this.segments[0].startNode.i; ) this.drawNextSegment();
                    if (this.activeSegments.length) for (; $t.vehicleIndex > this.activeSegments[0].endNode.i + 10 && (this.retireSegment(this.activeSegments.shift()), 0 != this.activeSegments.length); );
                }
                updateStaged() {
                    this.stagedSegments.length && this.stagedSegments[0].drawNextNode() && (this.stagedSegments.shift(), (en.walls = this.activeSegments.length + " (" + this.stagedSegments.length + ")"));
                }
                checkGenerateLeftSegment() {
                    this.addLeftSegment(this.bridgeWallGenerator.generateLeft(this.genNodeLeft)),
                        this.addLeftSegment(this.seaWallGenerator.generateLeft(this.genNodeLeft)),
                        this.addLeftSegment(this.drystoneGenerator.generateLeft(this.genNodeLeft)),
                        this.addLeftSegment(this.barrierGenerator.generateLeft(this.genNodeLeft));
                }
                checkGenerateRightSegment() {
                    this.addRightSegment(this.bridgeWallGenerator.generateRight(this.genNodeRight)),
                        this.addRightSegment(this.seaWallGenerator.generateRight(this.genNodeRight)),
                        this.addRightSegment(this.drystoneGenerator.generateRight(this.genNodeRight)),
                        this.addRightSegment(this.barrierGenerator.generateRight(this.genNodeRight));
                }
                addRightSegment(e) {
                    if (!e) return;
                    let t = e.startNode;
                    for (; t.i < e.endNode.i; ) (!t.rWallDist || t.rWallDist > e.distance) && ((t.rWallDist = e.distance), (t.wallSide = -1)), (t = t.next);
                    this.segments.push(e);
                }
                addLeftSegment(e) {
                    if (!e) return;
                    let t = e.startNode;
                    for (; t.i < e.endNode.i; ) (!t.lWallDist || t.lWallDist > -e.distance) && ((t.lWallDist = -e.distance), (t.wallSide = 1)), (t = t.next);
                    this.segments.push(e);
                }
                getSegmentObject(e) {
                    let t;
                    if (this.pools[e].length) t = this.pools[e].pop();
                    else {
                        (t = new (0, za[e])(null, this.getHeightAt)), this.container.add(t.mesh);
                    }
                    return t;
                }
                drawNextSegment() {
                    let e = this.segments.shift(),
                        t = this.getSegmentObject(e.type);
                    t.drawSegment(e) || this.stagedSegments.push(t), (e.obj = t), this.activeSegments.push(e), (en.walls = this.activeSegments.length + " (" + this.stagedSegments.length + ")");
                }
                retireSegment(e) {
                    e.obj.retire(), (en.walls = this.activeSegments.length + " (" + this.stagedSegments.length + ")"), this.pools[e.type].push(e.obj);
                }
            };
            const La = 1.5 * Math.PI;
            var Ra = class {
                constructor() {
                    (this.root = null),
                        (this.turnTail = null),
                        (this.gradTail = null),
                        (this.chevTail = null),
                        (this.placementNode = null),
                        (this.placementPos = new r.W()),
                        (this.lastSignIndex = 0),
                        (this.lastSignPos = new r.W()),
                        (this.lastSignRot = 0),
                        (this.dA = 0),
                        (this.lastTurnIndex = -10),
                        (this.lastTurnType = null),
                        (this.lastTurnGeo = null),
                        (this.turnDir = 0),
                        (this.dH = 0),
                        (this.lastGradIndex = -16),
                        (this.lastGradGeo = null),
                        (this.taildH = 0),
                        (this.curHillDir = 0),
                        (this.onHill = !1),
                        (this.steepness = 0),
                        (this.curHillSteepness = 0),
                        (this.cA = 0),
                        (this.lastChevIndex = 0),
                        (this.chevDir = 0);
                }
                initialise() {
                    for (
                        this.root = $t.vehicleNode.next.next.next, this.turnTail = this.root, this.dA = this.root.da, this.gradTail = this.root, this.chevTail = this.root, this.cA = Math.abs(this.root.da);
                        this.turnTail.i < this.root.i + 5;

                    )
                        (this.turnTail = this.turnTail.next), (this.dA += this.turnTail.da);
                    for (; this.gradTail.i < this.root.i + 8; ) this.gradTail = this.gradTail.next;
                    for (; this.chevTail.i < this.root.i + 4; ) (this.chevTail = this.chevTail.next), (this.cA += Math.abs(this.chevTail.da));
                    for (; this.root.i < $t.vehicleNode.i + 25; ) this.update();
                }
                destroy() {
                    for (
                        this.container.traverse((e) => {
                            e.isMesh && e.geometry.dispose();
                        });
                        this.container.children.length;

                    )
                        this.container.remove(this.container.children[0]);
                }
                handleMidlineReset() {
                    console.warn("No midline reset handling for SignController");
                }
                update() {
                    this.checkPlaceTurnSign(), this.checkPlaceGradientSign(), this.checkPlaceChevron(), (this.root = this.root.next);
                }
                checkPlaceTurnSign() {
                    if (((this.dA -= this.root.da), (this.turnTail = this.turnTail.next), (this.dA += this.turnTail.da), (this.turnDir = this.dA < 0 ? 1 : -1), Math.abs(this.dA) > 0.9))
                        if (this.turnTail.i - this.lastTurnIndex > 10) {
                            if (((this.placementNode = this.root.prev.prev.prev), this.placementNode.bridge)) return;
                            let s;
                            var e, t, i;
                            if (this.placementNode.da < -0.1)
                                (s = La - (null === (e = this.placementNode.prev) || void 0 === e || null === (t = e.prev) || void 0 === t || null === (i = t.prev) || void 0 === i ? void 0 : i.a) || this.placementNode.a),
                                    this.placementPos.set(this.placementNode.p.x + this.placementNode.n.x * (this.placementNode.w + 1), this.placementNode.p.y, this.placementNode.p.z + this.placementNode.n.z * (this.placementNode.w + 1));
                            else
                                (s = La - this.placementNode.a),
                                    this.placementPos.set(this.placementNode.p.x - this.placementNode.n.x * (this.placementNode.w + 1), this.placementNode.p.y, this.placementNode.p.z - this.placementNode.n.z * (this.placementNode.w + 1));
                            this.turnTail.i >= this.lastSignIndex && this.turnTail.i - this.lastSignIndex < 5 && this.combineWithLastGradSign(this.turnTail.i, s),
                                (this.lastTurnType = this.turnDir < 0 ? rn : hn),
                                (this.lastTurnIndex = this.turnTail.i),
                                (this.lastTurnGeo = Xn.addObject(Un.WarningSign, this.placementPos, s, this.placementNode.i, this.lastTurnType)),
                                (this.lastSignIndex = this.turnTail.i),
                                this.lastSignPos.copy(this.placementPos),
                                (this.lastSignRot = s);
                        } else
                            this.lastTurnGeo &&
                                (this.turnDir > 0 && this.lastTurnType == rn
                                    ? ((this.lastTurnIndex = this.turnTail.i), (this.lastTurnType = ln), this.lastTurnGeo.setVariant(ln))
                                    : this.turnDir < 0 && this.lastTurnType == hn && ((this.lastTurnIndex = this.turnTail.i), (this.lastTurnType = dn), this.lastTurnGeo.setVariant(dn)));
                }
                combineWithLastGradSign(e, t) {
                    this.lastGradGeo &&
                        (this.lastGradGeo.worldPosition.copy(this.placementPos), (this.lastGradGeo.worldPosition.y -= 0.65), this.lastGradGeo.updatePosition(), this.lastGradGeo.updateRetireIndex(e), (this.lastGradGeo.rotation.y = t));
                }
                checkPlaceGradientSign() {
                    var e;
                    if (
                        ((this.gradTail = this.gradTail.next),
                        (this.dH = this.gradTail.p.y - this.root.p.y),
                        (this.climbing = this.dH > 0),
                        (this.dH = Math.abs(this.dH)),
                        (this.steepness = this.dH > 12 ? (this.dH > 16 ? 2 : 1) : 0),
                        (this.taildH = this.gradTail.p.y - this.gradTail.prev.p.y),
                        this.onHill)
                    )
                        (this.curHillDir > 0 && this.taildH < 0) || (this.curHillDir < 0 && this.taildH > 0)
                            ? (this.onHill = !1)
                            : this.steepness > this.curHillSteepness && (null === (e = this.lastGradGeo) || void 0 === e || e.setVariant(this.curHillDir > 0 ? pn : gn));
                    else if (this.steepness > 0 && this.gradTail.i - this.lastGradIndex > 16) {
                        let e, n;
                        if (((this.onHill = !0), (this.curHillDir = this.climbing ? 1 : -1), (this.curHillSteepness = this.steepness), this.gradTail.i - 3 - this.lastSignIndex < 5))
                            (this.lastGradIndex = this.lastSignIndex), this.placementPos.copy(this.lastSignPos), (this.placementPos.y -= 0.65), (e = this.lastSignRot);
                        else {
                            if (((this.lastGradIndex = this.gradTail.i), (this.placementNode = this.root.prev.prev.prev), this.placementNode.bridge)) return;
                            var t, i, s;
                            if (((e = La - this.placementNode.a), this.placementNode.da < -0.1))
                                this.placementPos.set(this.placementNode.p.x + this.placementNode.n.x * (this.placementNode.w + 1), this.placementNode.p.y, this.placementNode.p.z + this.placementNode.n.z * (this.placementNode.w + 1)),
                                    (e = La - (null === (t = this.placementNode.prev) || void 0 === t || null === (i = t.prev) || void 0 === i || null === (s = i.prev) || void 0 === s ? void 0 : s.a) || this.placementNode.a);
                            else this.placementPos.set(this.placementNode.p.x - this.placementNode.n.x * (this.placementNode.w + 1), this.placementNode.p.y, this.placementNode.p.z - this.placementNode.n.z * (this.placementNode.w + 1));
                            (this.lastSignIndex = this.gradTail.i), this.lastSignPos.copy(this.placementPos), (this.lastSignRot = e);
                        }
                        (n = this.climbing ? (this.steepness > 1 ? pn : cn) : this.steepness > 1 ? gn : un), (this.lastGradGeo = Xn.addObject(Un.WarningSign, this.placementPos, e, this.placementNode.i, n));
                    }
                }
                checkPlaceChevron() {
                    if (((this.chevTail = this.chevTail.next), this.chevTail.i - this.lastChevIndex < 8)) return (this.cA -= Math.abs(this.root.da)), void (this.cA += Math.abs(this.chevTail.da));
                    if (((this.chevDir = this.chevTail.da < 0 ? 1 : -1), Math.abs(this.chevTail.da) > 0.6 && this.cA < 0.6)) {
                        var e, t;
                        (this.placementNode = this.chevTail), Math.abs(this.placementNode.prev.da) > 0.25 && (this.placementNode = this.placementNode.prev), (this.lastChevIndex = this.chevTail.i);
                        let i = La - ((null === (e = this.placementNode.prev) || void 0 === e || null === (t = e.prev) || void 0 === t ? void 0 : t.a) || this.placementNode.a);
                        this.placementPos.set(
                            this.placementNode.p.x - this.placementNode.n.x * (this.placementNode.w + 0.7) * this.chevDir,
                            this.placementNode.p.y - 0.6,
                            this.placementNode.p.z - this.placementNode.n.z * (this.placementNode.w + 0.7) * this.chevDir
                        ),
                            Xn.addObject(Un.WarningSign, this.placementPos, i, this.placementNode.i, this.chevDir < 0 ? mn : xn),
                            this.placementNode.ps
                                ? (this.placementPos.set(
                                      this.placementNode.ps[4].x - this.placementNode.ns[4].x * (this.placementNode.w + 0.7) * this.chevDir,
                                      this.placementNode.ps[4].y - 0.6,
                                      this.placementNode.ps[4].z - this.placementNode.ns[4].z * (this.placementNode.w + 0.7) * this.chevDir
                                  ),
                                  Xn.addObject(Un.WarningSign, this.placementPos, i, this.placementNode.i, this.chevDir < 0 ? mn : xn),
                                  (this.placementNode = this.placementNode.prev),
                                  this.placementPos.set(
                                      this.placementNode.ps[6].x - this.placementNode.ns[6].x * (this.placementNode.w + 0.7) * this.chevDir,
                                      this.placementNode.ps[6].y - 0.6,
                                      this.placementNode.ps[6].z - this.placementNode.ns[6].z * (this.placementNode.w + 0.7) * this.chevDir
                                  ),
                                  Xn.addObject(Un.WarningSign, this.placementPos, i, this.placementNode.i, this.chevDir < 0 ? mn : xn))
                                : console.warn("Attempting to place chevron without fine points");
                    }
                    (this.cA -= Math.abs(this.root.da)), (this.cA += Math.abs(this.chevTail.da));
                }
            };
            const Ta = 1.5 * Math.PI;
            class Pa extends r.G {
                constructor() {
                    super(), (this.shadowMat = new r.C({ transparent: !0, opacity: 0.33, color: 0 })), (this.waterOffset = 0.03), (this.p = new r.W()), (this.originPos = new r.W());
                    (this.geo = new r.g()),
                        this.geo.setIndex(this.getIndex(26)),
                        this.geo.setAttribute("position", new r.o(new Float32Array(156), 3)),
                        (this.verts = this.geo.attributes.position.array),
                        this.geo.attributes.position.setUsage(r.l);
                    let e = new r.B(this.geo, this.shadowMat);
                    this.add(e);
                }
                drawBridge(e) {
                    this.originPos.copy(e.p);
                    let t,
                        i,
                        s,
                        n = 0,
                        a = e;
                    for (
                        n = 0;
                        n < 25 &&
                        (this.p.copy(a.p).sub(this.originPos),
                        (i = a.n),
                        (s = a.w + 0.6),
                        (t = 6 * n),
                        (this.verts[t] = this.p.x + i.x * s),
                        (this.verts[t + 1] = -this.originPos.y + this.waterOffset),
                        (this.verts[t + 2] = this.p.z + i.z * s),
                        (this.verts[t + 3] = this.p.x - i.x * s),
                        (this.verts[t + 4] = -this.originPos.y + this.waterOffset),
                        (this.verts[t + 5] = this.p.z - i.z * s),
                        a.bridge);
                        n++
                    )
                        a = a.next;
                    this.geo.setDrawRange(0, 6 * (n - 1)), (this.geo.attributes.position.needsUpdate = !0), this.geo.computeBoundingSphere();
                }
                getIndex(e) {
                    let t,
                        i,
                        s,
                        n,
                        a = [];
                    for (let o = 0; o < e - 1; o++) (t = 2 * o), (i = t + 1), (s = 2 * (o + 1)), (n = s + 1), a.push(t, s, i), a.push(i, s, n);
                    return a;
                }
            }
            class Ga extends r.G {
                constructor() {
                    super(), (this.waterOffset = 0.03), (this.wallMaterial = new r.F({ color: 12303291, side: r.k, flatShading: !0 })), (this.p = new r.W()), (this.originPos = new r.W());
                    (this.geo = new r.g()),
                        this.geo.setIndex(this.getIndex(25)),
                        this.geo.setAttribute("position", new r.o(new Float32Array(312), 3)),
                        (this.verts = this.geo.attributes.position.array),
                        this.geo.attributes.position.setUsage(r.l);
                    let e = new r.B(this.geo, this.wallMaterial);
                    this.add(e);
                }
                drawBridge(e) {
                    this.originPos.copy(e.p);
                    let t,
                        i,
                        s,
                        n = 0,
                        a = e;
                    for (
                        n = 0;
                        n < 25 &&
                        (this.p.copy(a.p).sub(this.originPos),
                        (i = a.n),
                        (s = a.w + 0.6),
                        (t = 12 * n),
                        (this.verts[t] = this.p.x + i.x * s),
                        (this.verts[t + 1] = this.p.y + 1),
                        (this.verts[t + 2] = this.p.z + i.z * s),
                        (this.verts[t + 3] = this.p.x + i.x * s),
                        (this.verts[t + 4] = this.p.y - 1),
                        (this.verts[t + 5] = this.p.z + i.z * s),
                        (this.verts[t + 6] = this.p.x - i.x * s),
                        (this.verts[t + 7] = this.p.y - 1),
                        (this.verts[t + 8] = this.p.z - i.z * s),
                        (this.verts[t + 9] = this.p.x - i.x * s),
                        (this.verts[t + 10] = this.p.y + 1),
                        (this.verts[t + 11] = this.p.z - i.z * s),
                        a.bridge);
                        n++
                    )
                        a = a.next;
                    this.geo.setDrawRange(0, 18 * (n - 1)), (this.geo.attributes.position.needsUpdate = !0), this.geo.computeBoundingSphere();
                }
                getIndex(e) {
                    let t,
                        i,
                        s,
                        n,
                        a,
                        o,
                        r,
                        h,
                        l = [];
                    for (let d = 0; d < e; d++) (t = 4 * d), (i = t + 1), (s = t + 2), (n = t + 3), (a = 4 * (d + 1)), (o = a + 1), (r = a + 2), (h = a + 3), l.push(t, i, a, i, o, a, i, s, o, s, r, o, s, n, r, n, h, r);
                    return l;
                }
            }
            var Ba = class {
                constructor() {
                    (this.root = null), (this.tail = null), (this.shadowPool = []), (this.wallPool = []);
                }
                initialise() {
                    for (this.root = $t.vehicleNode; this.root.i < $t.vehicleNode.i + 100; ) this.update();
                }
                getShadowObject() {
                    if (this.shadowPool.length && !this.shadowPool[0].visible) return this.shadowPool.shift();
                    {
                        let e = new Pa();
                        return this.shadowPool.push(e), e;
                    }
                }
                getWallObject() {
                    if (this.wallPool.length && !this.wallPool[0].visible) return this.wallPool.shift();
                    {
                        let e = new Ga();
                        return this.wallPool.push(e), e;
                    }
                }
                update() {
                    if (this.root.bridge) {
                        let e = this.root.next;
                        for (; e.bridge; ) e = e.next;
                        let t = e.i - this.root.i,
                            i = this.getWallObject();
                        i.drawBridge(this.root), Xn.addCustom(i, this.root.p, 0, this.root.i, -(Vt - 10));
                        let s = this.getShadowObject();
                        s.drawBridge(this.root), Xn.addCustom(s, this.root.p, 0, e.i, 50);
                        let n = (t + 1) % 2;
                        for (; this.root.bridge; ) n % 2 == 0 && Xn.addObject(Un.BridgeSupport, this.root.p, Ta - this.root.a, this.root.i), (this.root = this.root.next), n++;
                    }
                    this.root = this.root.next;
                }
            };
            const Wa = 0.04,
                Ea = new r.L({ color: 16777215, fog: !1, size: 0.04, transparent: !0, opacity: 0 });
            (Ea.userData.headlightPos = { value: new r.W() }),
                (Ea.userData.headlightDir = { value: new r.W() }),
                (Ea.onBeforeCompile = (e) => {
                    (e.uniforms.headlightPos = Ea.userData.headlightPos),
                        (e.uniforms.headlightDir = Ea.userData.headlightDir),
                        (e.vertexShader = e.vertexShader.replace(
                            "#include <clipping_planes_pars_vertex>",
                            "#include <clipping_planes_pars_vertex>\n\n  uniform vec3 headlightPos;\n  uniform vec3 headlightDir;\n\n  varying float vBrightness;\n"
                        )),
                        (e.vertexShader = e.vertexShader.replace(
                            "#include <project_vertex>",
                            "#include <project_vertex>\n\n\n  vec4 wPos = modelMatrix * vec4(position, 1.0);\n\n  vec3 carDir = headlightPos - wPos.xyz;\n\n  // Distance to catseyes,\n  float carDist = length(carDir);\n\n  if(carDist < 150.0) {\n    // View distance of 150m\n    float distBrightnessFactor = 1.0 - (carDist - 50.0) / 100.0;\n\n    // Check if car is aiming at the light close enough\n    float angleBrightnessFactor = max(0.0, dot(normal, headlightDir));\n\n    // Check\n    float coneBrightnessFactor = dot(headlightDir, normalize(carDir));\n    coneBrightnessFactor = (coneBrightnessFactor - 0.8) / 0.2;\n\n    // NOTE: Could set the road colour here to save on transparency rendering\n    vBrightness = distBrightnessFactor * angleBrightnessFactor * coneBrightnessFactor;\n  } else {\n    vBrightness = 0.0;\n  }\n\n"
                        )),
                        (e.fragmentShader = e.fragmentShader.replace("#include <clipping_planes_pars_fragment>", "#include <clipping_planes_pars_fragment>\n\n\n  varying float vBrightness;\n\n")),
                        (e.fragmentShader = e.fragmentShader.replace("#include <alphatest_fragment>", "#include <alphatest_fragment>\n\n\n  diffuseColor.a = vBrightness;\n\n"));
                });
            const Fa = {};
            var Za = class {
                constructor() {
                    (this.container = new r.G()), (this.instances = []), (this.eyeOffset = 0), (this.genNode = null), (this.seenIndex = 0);
                }
                initInstances() {
                    for (let e = 0; e < 2; e++) this.instances.push(this.getInstance());
                }
                getInstance() {
                    let e = new r.g();
                    e.setAttribute("position", new r.o(new Float32Array(3 * this.pointsCount), 3)),
                        e.attributes.position.setUsage(r.l),
                        e.setAttribute("normal", new r.o(new Float32Array(3 * this.pointsCount), 3)),
                        e.attributes.normal.setUsage(r.l);
                    let t = new r.K(e, Ea);
                    return (t.visible = !0), (t.frustumCulled = !1), (t.matrixAutoUpdate = !1), this.container.add(t), t;
                }
                initialise() {
                    for (
                        this.eyeSpacing = 6.25,
                            this.pointsCount = 2 * Math.ceil(400 / this.eyeSpacing),
                            this.eyeOffset = 0.25 * this.eyeSpacing,
                            this.genNode = $t.head,
                            this.seenIndex = $t.head.i,
                            this.initInstances(),
                            this.prepNextInstance();
                        this.seenIndex < $t.vehicleIndex + 56;

                    )
                        this.update();
                }
                update() {
                    this.seenIndex < $t.vehicleIndex + 56 &&
                        (this.drawNextNode(), (this.genNode = this.genNode.next), (this.seenIndex = this.genNode.i), this.curInstance.userData.retireIndex <= $t.vehicleIndex && (this.curInstance.visible = !1)),
                        Ea.userData.headlightDir.value.copy(fe.fwd).negate(),
                        Ea.userData.headlightPos.value.copy(fe.frontAxlePosition),
                        (Ea.uniformsNeedUpdate = !0);
                }
                drawNextNode() {
                    this.eyeOffset >= 0 &&
                        this.eyeOffset < 10 &&
                        ((Fa.placementDist = this.eyeOffset),
                        (Fa.psA = Math.max(0, Math.floor(Fa.placementDist))),
                        (Fa.pa = this.genNode.ps[Fa.psA]),
                        Fa.psA < 9 ? (Fa.pb = this.genNode.ps[Fa.psA + 1]) : (Fa.pb = this.genNode.next.ps[0]),
                        (Fa.pLerp = Fa.placementDist - Fa.psA),
                        (Fa.p = { x: Fa.pa.x * (1 - Fa.pLerp) + Fa.pb.x * Fa.pLerp, y: Fa.pa.y * (1 - Fa.pLerp) + Fa.pb.y * Fa.pLerp, z: Fa.pa.z * (1 - Fa.pLerp) + Fa.pb.z * Fa.pLerp }),
                        (Fa.n = this.genNode.ns[Fa.psA]),
                        (Fa.nn = { x: Fa.n.x, z: Fa.n.z }),
                        (this.curNormArr[this.curIndex] = -Fa.n.z),
                        (this.curPosArr[this.curIndex++] = Fa.p.x + Fa.nn.x * Wa - this.curInstanceOffset.x),
                        (this.curNormArr[this.curIndex] = 0),
                        (this.curPosArr[this.curIndex++] = Fa.p.y + 0.03 - this.curInstanceOffset.y),
                        (this.curNormArr[this.curIndex] = Fa.n.x),
                        (this.curPosArr[this.curIndex++] = Fa.p.z + Fa.nn.z * Wa - this.curInstanceOffset.z),
                        (this.curNormArr[this.curIndex] = -Fa.n.z),
                        (this.curPosArr[this.curIndex++] = Fa.p.x - Fa.nn.x * Wa - this.curInstanceOffset.x),
                        (this.curNormArr[this.curIndex] = 0),
                        (this.curPosArr[this.curIndex++] = Fa.p.y + 0.03 - this.curInstanceOffset.y),
                        (this.curNormArr[this.curIndex] = Fa.n.x),
                        (this.curPosArr[this.curIndex++] = Fa.p.z - Fa.nn.z * Wa - this.curInstanceOffset.z),
                        this.curIndex > this.maxIndex - 6 && this.cycleInstances(),
                        (this.eyeOffset = Fa.placementDist)),
                        (this.eyeOffset = this.eyeOffset + this.eyeSpacing),
                        this.eyeOffset < 10 ? this.drawNextNode() : (this.eyeOffset -= 10);
                }
                cycleInstances() {
                    (this.curInstance.geometry.attributes.position.needsUpdate = !0),
                        (this.curInstance.geometry.attributes.normal.needsUpdate = !0),
                        this.curInstance.updateMatrix(),
                        (this.curInstance.visible = !0),
                        (this.curInstance.userData.retireIndex = this.genNode.i + 3),
                        this.instances.push(this.instances.shift()),
                        this.prepNextInstance();
                }
                prepNextInstance() {
                    (this.curInstance = this.instances[0]),
                        (this.curPosArr = this.curInstance.geometry.attributes.position.array),
                        (this.curNormArr = this.curInstance.geometry.attributes.normal.array),
                        (this.curInstanceOffset = { x: 0, y: 0, z: 0 }),
                        this.genNode && (this.curInstanceOffset = this.genNode.p),
                        this.curInstance.position.copy(this.curInstanceOffset),
                        (this.curIndex = 0),
                        (this.maxIndex = 3 * this.pointsCount);
                }
            };
            var Ha = i.p + "static/media/flake.d6a06041.webp";
            const Qa = new r.L({ size: 0.02, map: et(Ha, 4), alphaTest: 0.455 });
            (Qa.userData.time = { value: 0 }),
                (Qa.userData.speed = { value: 1.25 }),
                (Qa.userData.noise = { value: et(fs, 4) }),
                (Qa.userData.offset = { value: new r.W() }),
                (Qa.userData.boxWidth = { value: 30 }),
                (Qa.userData.boxHeight = { value: 30 }),
                (Qa.userData.headlightOn = { value: !0 }),
                (Qa.userData.headlightPos = { value: new r.W() }),
                (Qa.userData.headlightDir = { value: new r.W() }),
                (Qa.userData.snowCol = { value: new r.i(16777215) }),
                (Qa.userData.minDist = { value: 0 }),
                (Qa.onBeforeCompile = (e) => (
                    (e.uniforms.time = Qa.userData.time),
                    (e.uniforms.speed = Qa.userData.speed),
                    (e.uniforms.noise = Qa.userData.noise),
                    (e.uniforms.offset = Qa.userData.offset),
                    (e.uniforms.boxWidth = Qa.userData.boxWidth),
                    (e.uniforms.boxHeight = Qa.userData.boxHeight),
                    (e.uniforms.headlightOn = Qa.userData.headlightOn),
                    (e.uniforms.headlightPos = Qa.userData.headlightPos),
                    (e.uniforms.headlightDir = Qa.userData.headlightDir),
                    (e.uniforms.snowCol = Qa.userData.snowCol),
                    (e.uniforms.minDist = Qa.userData.minDist),
                    (e.vertexShader = e.vertexShader.replace(
                        "#include <fog_pars_vertex>",
                        "#include <fog_pars_vertex>\n\n\n  uniform float time;\n  uniform sampler2D noise;\n  uniform vec3 offset;\n  uniform float boxWidth;\n  uniform float boxHeight;\n  uniform float minDist;\n  uniform float speed;\n\n  uniform bool headlightOn;\n  uniform vec3 headlightPos;\n  uniform vec3 headlightDir;\n\n  varying float vBrightness;\n  varying float skip;\n\n  float SPEED = 1.0;\n\n"
                    )),
                    (e.vertexShader = e.vertexShader.replace(
                        "#include <project_vertex>",
                        "\n\n  // divide x/z by turbulence factor/scale factor\n  // divide time by wind speed factr\n\n  vec4 wPos = modelMatrix * vec4( position, 1.0 );\n\n  vec2 wuv = vec2(\n    transformed.x/50. + time/200.,\n    transformed.z/50. + time/200.\n  );\n\n\n  float noise = texture2D(noise, wuv).r;\n\n  // fall speed\n  transformed.y = mod(mod(transformed.y - offset.y, boxWidth) - time * speed, boxHeight);\n  transformed.x = mod(transformed.x - offset.x, boxWidth);\n  transformed.z = mod(transformed.z - offset.z, boxWidth);\n\n  transformed.x += noise * 2.;\n  transformed.z += cos(noise);\n\n  //// PROJECT VERTEX\n\n  vec4 mvPosition = vec4( transformed, 1.0 );\n\n  #ifdef USE_INSTANCING\n\n    mvPosition = instanceMatrix * mvPosition;\n\n  #endif\n\n  mvPosition = modelViewMatrix * mvPosition;\n\n  gl_Position = projectionMatrix * mvPosition;\n\n  //// EXCLUSION BY CAM DIST\n\n  skip = 0.0;\n  if(-mvPosition.z < minDist) {\n    skip = 1.0;\n  }\n\n  //// BRIGHTNESS\n\n  vBrightness = 0.0;\n\n  if(headlightOn) {\n      wPos = modelMatrix * vec4( transformed, 1.0 );\n\n      vec3 carDir = headlightPos - wPos.xyz;\n\n      // Distance to catseyes,\n      float carDist = length(carDir);\n\n      if(carDist < 100.0) {\n        // View distance of 150m\n        float distBrightnessFactor = 1.0 - (carDist - 25.0) / 75.0;\n\n        // Check\n        carDir.y *= 1.75;\n        float coneBrightnessFactor = dot(headlightDir, normalize(carDir));\n        coneBrightnessFactor = (coneBrightnessFactor - 0.8) / 0.2;\n\n\n        // NOTE: Could set the road colour here to save on transparency rendering\n        vBrightness = distBrightnessFactor * coneBrightnessFactor;\n      }\n  }\n\n  vBrightness = max(0., vBrightness);\n\n"
                    )),
                    (e.vertexShader = e.vertexShader.replace(
                        "#include <logdepthbuf_vertex>",
                        "\n\n  gl_PointSize = (0.02 + noise*0.025) * ( scale / - mvPosition.z );//0.0;//10. + mvPosition.z;// / 10.0;\n\n\n#include <logdepthbuf_vertex>"
                    )),
                    (e.fragmentShader = e.fragmentShader.replace("#include <clipping_planes_pars_fragment>", "#include <clipping_planes_pars_fragment>\n\n\n  uniform vec3 snowCol;\n  varying float vBrightness;\n  varying float skip;\n\n")),
                    (e.fragmentShader = e.fragmentShader.replace(
                        "#include <alphatest_fragment>",
                        "#include <alphatest_fragment>\n\n\n  if(skip > 0.5) {\n    discard;\n  }\n\n  diffuseColor.rgb = snowCol + vec3(vBrightness);//vBrightness;\n\n"
                    )),
                    e
                ));
            var Ya = class {
                constructor() {
                    (this.density = 200),
                        (this.boxWidth = 30),
                        (this.boxHeight = 30),
                        (this.boxWidthHalf = this.boxWidth / 2),
                        (this.container = new r.G()),
                        (this.onFirstPersonBound = this.onFirstPerson.bind(this)),
                        (this.tVec = new r.W()),
                        (this.camFwd = new r.W()),
                        (this.speed = 1.25),
                        (this.weatherDisabled = !1);
                    let e,
                        t,
                        i = [],
                        s = [];
                    for (let n = 0; n <= this.density; n++)
                        for (let a = 0; a <= this.density; a++)
                            (e = n / this.density),
                                (t = a / this.density),
                                i.push(e * this.boxWidth, Math.random() * this.boxHeight, t * this.boxWidth),
                                n % 3 == 0 && a % 3 == 0 && s.push(e * this.boxWidth, Math.random() * this.boxHeight, t * this.boxWidth);
                    (this.halfGeo = new r.g()),
                        this.halfGeo.setAttribute("position", new r.o(s, 3)),
                        (this.fullGeo = new r.g()),
                        this.fullGeo.setAttribute("position", new r.o(i, 3)),
                        (this.points = new r.K(this.halfGeo, Qa)),
                        (this.points.position.x -= this.boxWidthHalf),
                        (this.points.position.y -= this.boxHeight / 2),
                        (this.points.position.z -= this.boxWidthHalf),
                        this.container.add(this.points),
                        Qs.addListener(this.onFirstPersonBound);
                }
                destroy() {
                    Qs.removeListener(this.onFirstPersonBound);
                }
                onFirstPerson(e) {
                    Qa.userData.minDist.value = e ? 0.85 : 0;
                }
                update() {
                    this.points.visible &&
                        (Hs.parent ? this.tVec.copy(Hs.parent.position) : this.tVec.copy(Hs.position),
                        Hs.getWorldDirection(this.camFwd),
                        (this.camFwd.y = 0),
                        Hs.fwd.copy(this.camFwd).normalize(),
                        this.tVec.add(Hs.fwd.multiplyScalar(this.boxWidthHalf)),
                        this.container.position.copy(this.tVec),
                        (Qa.userData.time.value = oe.appTime),
                        Qa.userData.offset.value.copy(this.container.position),
                        (Qa.userData.headlightOn.value = fe.headlights),
                        Qa.userData.headlightDir.value.copy(fe.fwd).negate(),
                        Qa.userData.headlightPos.value.copy(fe.frontAxlePosition),
                        (Qa.uniformsNeedUpdate = !0));
                }
                onWeatherCycleChanged(e) {
                    (this.weatherDisabled = e), (this.points.visible = this.points.visible && !this.weatherDisabled);
                }
                setWeather(e) {
                    e
                        ? ((this.points.visible = !0),
                          e.half ? (this.points.geometry = this.halfGeo) : (this.points.geometry = this.fullGeo),
                          (Qa.userData.speed.value = e.speed || 1.25),
                          Qa.userData.snowCol.value.setHex(e.colour),
                          (Qa.uniformsNeedUpdate = !0))
                        : (this.points.visible = !1);
                }
            };
            const Va = {},
                Ua = 2 * Math.PI;
            var Xa = class extends li {
                constructor(...e) {
                    super(...e),
                        (this.gradients = []),
                        (this.heightOffset = 150),
                        (this.heightInitial = 1),
                        (this.resolution = 2),
                        (this.depth = 3),
                        (this.upscale = 5),
                        (this.cache = {}),
                        (this.cacheAccess = {}),
                        (this.cacheCount = 0),
                        (this.maxCached = 12),
                        (this.cellScaleMetres = 1500),
                        (this.cellScaleWorld = 1500),
                        (this.squared = !1),
                        (this.compound = !1),
                        (this.useQuick = !1),
                        (this.resolutions = []),
                        (this.smooth = !1);
                    let t = e[1] || {};
                    if (
                        ((this.seed = e[0] || "foliage"),
                        (this.heightScale = t.heightScale || 1),
                        (this.heightInitial = "heightInitial" in t ? t.heightInitial : 1),
                        (this.resolution = t.resolution || 5),
                        (this.depth = t.depth || 3),
                        (this.upscale = t.upscale || 3),
                        (this.heightOffset = t.heightOffset || 0),
                        (this.upscaleFactor = t.upscaleFactor || 2),
                        (this.squared = t.squared || !1),
                        (this.squareLayers = t.squareLayers || this.depth),
                        (this.compound = t.compound || !1),
                        (this.threshold = t.threshold || 0.7),
                        (this.threshold2 = t.threshold2 || 0.8),
                        (this.threshold3 = t.threshold3 || 0.9),
                        (this.smooth = !!t.smooth),
                        (this.gap1 = this.threshold2 - this.threshold),
                        (this.gap2 = this.threshold3 - this.threshold2),
                        (this.gap3 = 1 - this.threshold3),
                        null != t.resolutions)
                    )
                        (this.resolutions = t.resolutions), (this.resolution = this.resolutions[0]), (this.depth = this.resolutions.length);
                    else {
                        this.resolutions = [this.resolution];
                        for (let e = 0; e < this.depth - 1; e++) this.resolutions.push(this.calculateNextDepthResolution(this.resolutions[e], e));
                    }
                    this.cellScaleWorld = this.cellScaleMetres;
                }
                generateCell(e, t) {
                    let i,
                        s,
                        n,
                        a,
                        o = new window.alea(this.seed + e + t),
                        r = this.resolution,
                        h = [],
                        l = [];
                    for (i = 0; i < this.depth; i++) {
                        for (l = [], s = 0; s < r; s++) for (l.push([]), n = 0; n < r; n++) (a = o() * Ua), l[s].push({ x: Math.cos(a), y: Math.sin(a) });
                        h.push(l), (r = this.getNextDepthResolution(r, i));
                    }
                    return h;
                }
                calculateNextDepthResolution(e, t) {
                    return Math.round(e * this.upscaleFactor);
                }
                getNextDepthResolution(e, t) {
                    return this.resolutions[t + 1];
                }
                dotGridGradient(e, t, i, s, n) {
                    return (this.grad = e[t][i]), (s - t) * this.grad.x + (n - i) * this.grad.y;
                }
                sharpLerp(e, t, i) {
                    return (t - e) * i + e;
                }
                smoothLerp(e, t, i) {
                    return (t - e) * (3 - 2 * i) * i * i + e;
                }
                smootherLerp(e, t, i) {
                    return (i * (6 * i - 15) + 10) * i * i * i * (t - e) + e;
                }
                getXZ(e, t, i) {
                    for (Va.layer of ((Va.d = 0),
                    (Va.h = 0),
                    (Va.sq = this.resolution),
                    (Va.sqb = Va.sq - 1),
                    (Va.wx = e / this.cellScaleWorld),
                    (Va.wz = t / this.cellScaleWorld),
                    (Va.ox = Math.floor(Va.wx)),
                    (Va.oz = Math.floor(Va.wz)),
                    (Va.px = Va.wx - Va.ox),
                    (Va.pz = Va.wz - Va.oz),
                    (Va.cell = this.getCell(Va.ox, Va.oz)),
                    (i = i || this.depth),
                    (Va.depth = 0),
                    (Va.h = this.heightInitial),
                    (Va.heightFactor = 1),
                    (Va.ch = 0),
                    Va.cell)) {
                        if (Va.depth == i) break;
                        (Va.sx = Va.px * Va.sq),
                            (Va.sz = Va.pz * Va.sq),
                            (Va.ix = Math.floor(Va.sx)),
                            (Va.ix1 = Va.ix + 1),
                            (Va.iz = Math.floor(Va.sz)),
                            (Va.iz1 = Va.iz + 1),
                            (Va.qx = Va.sx - Va.ix),
                            (Va.qz = Va.sz - Va.iz),
                            (Va.n0 = this.dotGridGradient(Va.layer, Va.ix, Va.iz, Va.sx, Va.sz)),
                            Va.ix1 < Va.sq ? (Va.n1 = this.dotGridGradient(Va.layer, Va.ix1, Va.iz, Va.sx, Va.sz)) : (Va.n1 = this.dotGridGradient(this.getCell(Va.ox + 1, Va.oz)[Va.depth], 0, Va.iz, Va.sx - Va.sq, Va.sz)),
                            (Va.int0 = this.sharpLerp(Va.n0, Va.n1, Va.qx)),
                            Va.iz1 < Va.sq
                                ? ((Va.n0 = this.dotGridGradient(Va.layer, Va.ix, Va.iz1, Va.sx, Va.sz)),
                                  Va.ix1 < Va.sq ? (Va.n1 = this.dotGridGradient(Va.layer, Va.ix1, Va.iz1, Va.sx, Va.sz)) : (Va.n1 = this.dotGridGradient(this.getCell(Va.ox + 1, Va.oz)[Va.depth], 0, Va.iz1, Va.sx - Va.sq, Va.sz)))
                                : ((Va.n0 = this.dotGridGradient(this.getCell(Va.ox, Va.oz + 1)[Va.depth], Va.ix, 0, Va.sx, Va.sz - Va.sq)),
                                  Va.ix1 < Va.sq
                                      ? (Va.n1 = this.dotGridGradient(this.getCell(Va.ox, Va.oz + 1)[Va.depth], Va.ix1, 0, Va.sx, Va.sz - Va.sq))
                                      : (Va.n1 = this.dotGridGradient(this.getCell(Va.ox + 1, Va.oz + 1)[Va.depth], 0, 0, Va.sx - Va.sq, Va.sz - Va.sq))),
                            (Va.int1 = this.sharpLerp(Va.n0, Va.n1, Va.qx)),
                            (Va.heightFactor = 1 / (Va.depth + 1)),
                            (Va.h += this.sharpLerp(Va.int0, Va.int1, Va.qz) * Va.heightFactor),
                            (Va.sq = this.getNextDepthResolution(Va.sq, Va.depth)),
                            Va.depth++;
                    }
                    return (
                        this.squared && (Va.h < 0 ? (Va.h *= -Va.h * (1 + Va.h) * 4) : (Va.h *= Va.h * (1 - Va.h) * 4)),
                        (Va.h = Va.h * this.heightScale + this.heightOffset),
                        this.smooth
                            ? Va.h > this.threshold
                                ? Va.h > this.threshold3
                                    ? 2 + (Va.h - this.threshold3) / this.gap3
                                    : Va.h > this.threshold2
                                    ? 1 + (Va.h - this.threshold2) / this.gap2
                                    : (Va.h - this.threshold) / this.gap1
                                : (Va.h, 0)
                            : Va.h > this.threshold
                            ? Va.h > this.threshold3
                                ? 3
                                : Va.h > this.threshold2
                                ? 2
                                : 1
                            : 0
                    );
                }
                getXZLayer(e, t, i) {
                    for (Va.layer of ((Va.d = 0),
                    (Va.h = 0),
                    (Va.sq = this.resolution),
                    (Va.sqb = Va.sq - 1),
                    (Va.wx = e / this.cellScaleWorld),
                    (Va.wz = t / this.cellScaleWorld),
                    (Va.ox = Math.floor(Va.wx)),
                    (Va.oz = Math.floor(Va.wz)),
                    (Va.px = Va.wx - Va.ox),
                    (Va.pz = Va.wz - Va.oz),
                    (Va.cell = this.getCell(Va.ox, Va.oz)),
                    (Va.depth = 0),
                    (Va.h = this.heightInitial),
                    (Va.heightFactor = 1),
                    (Va.ch = 0),
                    Va.cell))
                        if (Va.depth < i) (Va.sq = this.getNextDepthResolution(Va.sq, Va.depth)), Va.depth++;
                        else {
                            if (Va.depth == this.depth || Va.depth > i) break;
                            (Va.sx = Va.px * Va.sq),
                                (Va.sz = Va.pz * Va.sq),
                                (Va.ix = Math.floor(Va.sx)),
                                (Va.ix1 = Va.ix + 1),
                                (Va.iz = Math.floor(Va.sz)),
                                (Va.iz1 = Va.iz + 1),
                                (Va.qx = Va.sx - Va.ix),
                                (Va.qz = Va.sz - Va.iz),
                                (Va.n0 = this.dotGridGradient(Va.layer, Va.ix, Va.iz, Va.sx, Va.sz)),
                                Va.ix1 < Va.sq ? (Va.n1 = this.dotGridGradient(Va.layer, Va.ix1, Va.iz, Va.sx, Va.sz)) : (Va.n1 = this.dotGridGradient(this.getCell(Va.ox + 1, Va.oz)[Va.depth], 0, Va.iz, Va.sx - Va.sq, Va.sz)),
                                (Va.int0 = this.smootherLerp(Va.n0, Va.n1, Va.qx)),
                                Va.iz1 < Va.sq
                                    ? ((Va.n0 = this.dotGridGradient(Va.layer, Va.ix, Va.iz1, Va.sx, Va.sz)),
                                      Va.ix1 < Va.sq ? (Va.n1 = this.dotGridGradient(Va.layer, Va.ix1, Va.iz1, Va.sx, Va.sz)) : (Va.n1 = this.dotGridGradient(this.getCell(Va.ox + 1, Va.oz)[Va.depth], 0, Va.iz1, Va.sx - Va.sq, Va.sz)))
                                    : ((Va.n0 = this.dotGridGradient(this.getCell(Va.ox, Va.oz + 1)[Va.depth], Va.ix, 0, Va.sx, Va.sz - Va.sq)),
                                      Va.ix1 < Va.sq
                                          ? (Va.n1 = this.dotGridGradient(this.getCell(Va.ox, Va.oz + 1)[Va.depth], Va.ix1, 0, Va.sx, Va.sz - Va.sq))
                                          : (Va.n1 = this.dotGridGradient(this.getCell(Va.ox + 1, Va.oz + 1)[Va.depth], 0, 0, Va.sx - Va.sq, Va.sz - Va.sq))),
                                (Va.int1 = this.smootherLerp(Va.n0, Va.n1, Va.qx)),
                                (Va.heightFactor = this.resolution / Va.sq),
                                this.compound && (Va.heightFactor *= Va.h),
                                (Va.h += this.smootherLerp(Va.int0, Va.int1, Va.qz) * Va.heightFactor),
                                (Va.sq = this.getNextDepthResolution(Va.sq, Va.depth)),
                                Va.depth++;
                        }
                    return this.squared && (Va.h *= Va.h), (Va.h += Va.ch), Va.h * this.heightScale + this.heightOffset;
                }
                smootherLerpW(e) {
                    return (e * (6 * e - 15) + 10) * e * e * e * -1 + 1;
                }
                sharpLerpW(e) {
                    return 1 - e;
                }
                smoothLerpW(e) {
                    return -1 * (3 - 2 * e) * e * e + 1;
                }
            };
            const Ja = { layer: 0, d: 0, h: 0, sq: 0, sqb: 0, wx: 0, wz: 0, ox: 0, oz: 0, px: 0, pz: 0, cell: null, ix: 0, iz: 0, depth: 0 },
                qa = { ...Ja };
            var Ka = class extends li {
                constructor(...e) {
                    super(...e),
                        (this.resolution = 5),
                        (this.depth = 3),
                        (this.upscale = 2),
                        (this.heightScale = 1),
                        (this.heightOffset = 0),
                        (this.upscaleType = 0),
                        (this.controls = []),
                        (this.cache = {}),
                        (this.cacheAccess = {}),
                        (this.cacheCount = 0),
                        (this.maxCached = 9),
                        (this.qCache = {}),
                        (this.smoothingFunc = () => {}),
                        (this.useQuick = !1);
                    let t = e[1] || {};
                    switch (
                        (null !== t.heightScale && (this.heightScale = t.heightScale),
                        null !== t.resolution && (this.resolution = t.resolution),
                        (this.seed = e[0] || di),
                        (this.depth = t.depth || 3),
                        (this.radiusType = null == t.radiusType ? 1 : t.radiusType),
                        (this.upscale = t.upscale || 2),
                        (this.upscaleType = null == t.upscaleType ? 0 : t.upscaleType),
                        (this.upscaleFactor = null == t.upscaleFactor ? 2 : t.upscaleFactor),
                        (this.threshold = t.threshold),
                        (this.threshold2 = t.threshold2),
                        (this.threshold3 = t.threshold3),
                        (this.squared = t.squared || !1),
                        (this.compound = t.compound || !1),
                        (this.depthHeightFactor = t.depthHeightFactor || 1),
                        (this.smoothLerpIndex = null == t.smoothLerp ? 2 : t.smoothLerp),
                        this.smoothLerpIndex)
                    ) {
                        case 2:
                            this.smoothingFunc = this.smootherLerp;
                            break;
                        case 1:
                            this.smoothingFunc = this.smoothLerp;
                            break;
                        case 0:
                        default:
                            this.smoothingFunc = this.sharpLerp;
                    }
                    if (null != t.resolutions) (this.resolutions = t.resolutions), (this.resolution = this.resolutions[0]), (this.depth = this.resolutions.length);
                    else {
                        this.resolutions = [this.resolution];
                        for (let e = 0; e < this.depth - 1; e++) this.resolutions.push(this.calculateNextDepthResolution(this.resolutions[e], e));
                    }
                    (this.controls = []), (this.cellScaleMetres = 1e3), (this.cellScaleWorld = 3e3), (this.heightOffset = t.heightOffset);
                }
                cosLerp(e) {
                    return Math.cos(3.1415 * e) + 1;
                }
                sharpLerp(e) {
                    return 1 - e;
                }
                smoothLerp(e) {
                    return -1 * (3 - 2 * e) * e * e + 1;
                }
                smootherLerp(e) {
                    return (e * (6 * e - 15) + 10) * e * e * e * -1 + 1;
                }
                sharpLerpAB(e, t, i) {
                    return (t - e) * i + e;
                }
                smootherLerpAB(e, t, i) {
                    return (i * (6 * i - 15) + 10) * i * i * i * (t - e) + e;
                }
                lerpHeight(e, t, i, s) {
                    return (e = (s.x - t) * (s.x - t) + (s.z - i) * (s.z - i)) < s.r2 ? this.sharpLerp(e / s.r2) * s.y : 0;
                }
                clearCache() {
                    if (this.cacheCount <= this.maxCached) return;
                    let e, t;
                    for (e in this.cache) {
                        for (t in this.cache[e])
                            if (this.cacheAccess[e][t]) this.cacheAccess[e][t] = !1;
                            else if ((delete this.cache[e][t], delete this.cacheAccess[e][t], this.cacheCount--, this.cacheCount <= this.maxCached)) break;
                        if (this.cacheCount <= this.maxCached) break;
                    }
                }
                cacheCell(e, t) {
                    let i;
                    this.cacheCount++, this.clearCache();
                    let s = [],
                        n = 1,
                        a = new window.alea(this.seed + e + t),
                        o = this.resolution,
                        r = [],
                        h = this.depthHeightFactor;
                    for (i = 0; i < this.depth; i++) {
                        let e, t, l, d, c;
                        for (o = this.resolutions[i], n = (this.resolution / o) * h, h *= this.depthHeightFactor, r = [], c = 1 / o, t = 0; t < o; t++) {
                            for (e = [], l = 0; l < o; l++)
                                (d = 2 * a() - 1), this.squared && (d *= d < 0 ? -d * (1 + d) * 4 : d * (1 - d) * 4), (d *= n), e.push({ x: (t + 0.5) / o, y: d * this.heightScale, z: (l + 0.5) / o, r: c, r2: c * c });
                            r.push(e);
                        }
                        s.push(r);
                    }
                    e in this.cache || (this.cache[e] = {}), (this.cache[e][t] = s);
                }
                calculateNextDepthResolution(e, t) {
                    switch (this.upscaleType) {
                        case 5:
                            let i,
                                s = this.resolution,
                                n = this.resolution;
                            for (let e = 0; e < t + 1; e++) (i = s + n), (n = s), (s = i);
                            return i;
                        case 4:
                            return e * this.upscaleFactor + (t + 1);
                        case 3:
                            return Math.round(e * this.upscaleFactor);
                        case 2:
                            return Math.pow(this.resolution, t + 2);
                        case 1:
                            return this.resolution + Math.pow(this.upscale, t + 1);
                        case 0:
                        default:
                            return e + this.upscale * (t + 1);
                    }
                }
                getNextDepthResolution(e, t) {
                    return this.resolutions[t + 1];
                }
                getResolution(e, t) {
                    return this.resolutions[t];
                }
                getNode(e, t, i, s) {}
                getCell(e, t) {
                    return (
                        e in this.cacheAccess || (this.cacheAccess[e] = {}),
                        (this.cacheAccess[e][t] = !0),
                        (this.cache[e] && this.cache[e][t]) || this.cacheCell(e, t),
                        e in this.cacheAccess || (this.cacheAccess[e] = {}),
                        (this.cacheAccess[e][t] = !0),
                        this.cache[e][t]
                    );
                }
                getQuickCell(e, t) {
                    return (
                        (this.cache[e] && this.cache[e][t]) || this.cacheCell(e, t),
                        e in this.cacheAccess || (this.cacheAccess[e] = {}),
                        (this.cacheAccess[e][t] = !0),
                        (this.qCache[e] && this.qCache[e][t]) || this.quickCache(e, t, this.cache[e][t][this.depth - 1]),
                        this.qCache[e][t]
                    );
                }
                quickCache(e, t, i) {
                    if (e in this.qCache) {
                        if (t in this.qCache[e]) return;
                    } else this.qCache[e] = {};
                    let s = [];
                    this.useQuick = !1;
                    for (let n of i) {
                        let i = [];
                        for (let s of n) i.push({ x: s.x, y: this.getXZ((e + s.x) * this.cellScaleWorld, (t + s.z) * this.cellScaleWorld), z: s.z, r: s.r, r2: s.r2 });
                        s.push(i);
                    }
                    (this.useQuick = !0), (this.qCache[e][t] = s);
                }
                getXZQuick(e, t) {
                    let i, s, n, a, o, r;
                    return (
                        (qa.d = 0),
                        (qa.h = 0),
                        (qa.wx = e / this.cellScaleWorld),
                        (qa.wz = t / this.cellScaleWorld),
                        (qa.ox = Math.floor(qa.wx)),
                        (qa.oz = Math.floor(qa.wz)),
                        (qa.px = qa.wx - qa.ox),
                        (qa.pz = qa.wz - qa.oz),
                        (qa.layer = this.getQuickCell(qa.ox, qa.oz)),
                        (qa.sq = this.getResolution(this.resolution, this.depth - 1)),
                        (qa.sqb = qa.sq - 1),
                        (qa.ssq = qa.sq),
                        (qa.ssqb = qa.sqb),
                        (i = qa.px * qa.sq - 0.5),
                        (qa.ix = Math.floor(qa.px * qa.sq - 0.5)),
                        (s = qa.pz * qa.sq - 0.5),
                        (qa.iz = Math.floor(qa.pz * qa.sq - 0.5)),
                        (i -= qa.ix),
                        (s -= qa.iz),
                        qa.ix >= 0
                            ? ((n = qa.iz >= 0 ? qa.layer[qa.ix][qa.iz].y : this.getQuickCell(qa.ox, qa.oz - 1)[qa.ix][qa.sqb].y), (a = qa.iz < qa.ssqb ? qa.layer[qa.ix][qa.iz + 1].y : this.getQuickCell(qa.ox, qa.oz + 1)[qa.ix][0].y))
                            : ((n = qa.iz >= 0 ? this.getQuickCell(qa.ox - 1, qa.oz)[qa.sqb][qa.iz].y : this.getQuickCell(qa.ox - 1, qa.oz - 1)[qa.sqb][qa.sqb].y),
                              (a = qa.iz < qa.ssqb ? this.getQuickCell(qa.ox - 1, qa.oz)[qa.sqb][qa.iz + 1].y : this.getQuickCell(qa.ox - 1, qa.oz + 1)[qa.sqb][0].y)),
                        qa.ix < qa.ssqb
                            ? ((o = qa.iz >= 0 ? qa.layer[qa.ix + 1][qa.iz].y : this.getQuickCell(qa.ox, qa.oz - 1)[qa.ix + 1][qa.sqb].y),
                              (r = qa.iz < qa.ssqb ? qa.layer[qa.ix + 1][qa.iz + 1].y : this.getQuickCell(qa.ox, qa.oz + 1)[qa.ix + 1][0].y))
                            : ((o = qa.iz >= 0 ? this.getQuickCell(qa.ox + 1, qa.oz)[0][qa.iz].y : this.getQuickCell(qa.ox + 1, qa.oz - 1)[0][qa.sqb].y),
                              (r = qa.iz < qa.ssqb ? this.getQuickCell(qa.ox + 1, qa.oz)[0][qa.iz + 1].y : this.getQuickCell(qa.ox + 1, qa.oz + 1)[0][0].y)),
                        (n = this.sharpLerpAB(n, a, s)),
                        (o = this.sharpLerpAB(o, r, s)),
                        this.sharpLerpAB(n, o, i)
                    );
                }
                getXZLayer(e, t, i) {
                    (Ja.layer = 0),
                        (Ja.d = 0),
                        (Ja.h = 0),
                        (Ja.sq = this.resolution),
                        (Ja.sqb = Ja.sq - 1),
                        (Ja.wx = e / this.cellScaleWorld),
                        (Ja.wz = t / this.cellScaleWorld),
                        (Ja.ox = Math.floor(Ja.wx)),
                        (Ja.oz = Math.floor(Ja.wz)),
                        (Ja.px = Ja.wx - Ja.ox),
                        (Ja.pz = Ja.wz - Ja.oz),
                        (Ja.cell = this.getCell(Ja.ox, Ja.oz));
                    let s = this.depth;
                    Ja.depth = 0;
                    let n = 0;
                    for (Ja.layer of Ja.cell)
                        if (n++ === i) {
                            if (Ja.depth == s) break;
                            (Ja.ix = Math.floor(Ja.px * Ja.sq - 0.5)),
                                (Ja.iz = Math.floor(Ja.pz * Ja.sq - 0.5)),
                                (Ja.th = 0),
                                Ja.ix >= 0
                                    ? (Ja.iz >= 0 ? (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz, Ja.layer[Ja.ix][Ja.iz])) : (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz + 1, this.getCell(Ja.ox, Ja.oz - 1)[Ja.depth][Ja.ix][Ja.sqb])),
                                      Ja.iz < Ja.sqb ? (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz, Ja.layer[Ja.ix][Ja.iz + 1])) : (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz - 1, this.getCell(Ja.ox, Ja.oz + 1)[Ja.depth][Ja.ix][0])))
                                    : (Ja.iz >= 0
                                          ? (Ja.th += this.lerpHeight(Ja.d, Ja.px + 1, Ja.pz, this.getCell(Ja.ox - 1, Ja.oz)[Ja.depth][Ja.sqb][Ja.iz]))
                                          : (Ja.th += this.lerpHeight(Ja.d, Ja.px + 1, Ja.pz + 1, this.getCell(Ja.ox - 1, Ja.oz - 1)[Ja.depth][Ja.sqb][Ja.sqb])),
                                      Ja.iz < Ja.sqb
                                          ? (Ja.th += this.lerpHeight(Ja.d, Ja.px + 1, Ja.pz, this.getCell(Ja.ox - 1, Ja.oz)[Ja.depth][Ja.sqb][Ja.iz + 1]))
                                          : (Ja.th += this.lerpHeight(Ja.d, Ja.px + 1, Ja.pz - 1, this.getCell(Ja.ox - 1, Ja.oz + 1)[Ja.depth][Ja.sqb][0]))),
                                Ja.ix < Ja.sqb
                                    ? (Ja.iz >= 0
                                          ? (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz, Ja.layer[Ja.ix + 1][Ja.iz]))
                                          : (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz + 1, this.getCell(Ja.ox, Ja.oz - 1)[Ja.depth][Ja.ix + 1][Ja.sqb])),
                                      Ja.iz < Ja.sqb
                                          ? (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz, Ja.layer[Ja.ix + 1][Ja.iz + 1]))
                                          : (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz - 1, this.getCell(Ja.ox, Ja.oz + 1)[Ja.depth][Ja.ix + 1][0])))
                                    : (Ja.iz >= 0
                                          ? (Ja.th += this.lerpHeight(Ja.d, Ja.px - 1, Ja.pz, this.getCell(Ja.ox + 1, Ja.oz)[Ja.depth][0][Ja.iz]))
                                          : (Ja.th += this.lerpHeight(Ja.d, Ja.px - 1, Ja.pz + 1, this.getCell(Ja.ox + 1, Ja.oz - 1)[Ja.depth][0][Ja.sqb])),
                                      Ja.iz < Ja.sqb
                                          ? (Ja.th += this.lerpHeight(Ja.d, Ja.px - 1, Ja.pz, this.getCell(Ja.ox + 1, Ja.oz)[Ja.depth][0][Ja.iz + 1]))
                                          : (Ja.th += this.lerpHeight(Ja.d, Ja.px - 1, Ja.pz - 1, this.getCell(Ja.ox + 1, Ja.oz + 1)[Ja.depth][0][0]))),
                                (Ja.h += Ja.th),
                                Ja.depth++,
                                (Ja.sq = this.resolutions[Ja.depth]),
                                (Ja.sqb = Ja.sq - 1);
                        } else Ja.depth++, (Ja.sq = this.resolutions[Ja.depth]), (Ja.sqb = Ja.sq - 1);
                    return Ja.h + this.heightOffset;
                }
                getXZ(e, t, i) {
                    for (Ja.layer of ((Ja.d = 0),
                    (Ja.h = 0),
                    (Ja.heightFactor = 1),
                    (Ja.sq = this.resolution),
                    (Ja.sqb = Ja.sq - 1),
                    (Ja.wx = e / this.cellScaleWorld),
                    (Ja.wz = t / this.cellScaleWorld),
                    (Ja.ox = Math.floor(Ja.wx)),
                    (Ja.oz = Math.floor(Ja.wz)),
                    (Ja.px = Ja.wx - Ja.ox),
                    (Ja.pz = Ja.wz - Ja.oz),
                    (Ja.cell = this.getCell(Ja.ox, Ja.oz)),
                    (i = i || this.depth),
                    (Ja.depth = 0),
                    Ja.cell)) {
                        if (Ja.depth == i) break;
                        (Ja.ix = Math.floor(Ja.px * Ja.sq - 0.5)),
                            (Ja.iz = Math.floor(Ja.pz * Ja.sq - 0.5)),
                            (Ja.th = 0),
                            Ja.ix >= 0
                                ? (Ja.iz >= 0 ? (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz, Ja.layer[Ja.ix][Ja.iz])) : (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz + 1, this.getCell(Ja.ox, Ja.oz - 1)[Ja.depth][Ja.ix][Ja.sqb])),
                                  Ja.iz < Ja.sqb ? (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz, Ja.layer[Ja.ix][Ja.iz + 1])) : (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz - 1, this.getCell(Ja.ox, Ja.oz + 1)[Ja.depth][Ja.ix][0])))
                                : (Ja.iz >= 0
                                      ? (Ja.th += this.lerpHeight(Ja.d, Ja.px + 1, Ja.pz, this.getCell(Ja.ox - 1, Ja.oz)[Ja.depth][Ja.sqb][Ja.iz]))
                                      : (Ja.th += this.lerpHeight(Ja.d, Ja.px + 1, Ja.pz + 1, this.getCell(Ja.ox - 1, Ja.oz - 1)[Ja.depth][Ja.sqb][Ja.sqb])),
                                  Ja.iz < Ja.sqb
                                      ? (Ja.th += this.lerpHeight(Ja.d, Ja.px + 1, Ja.pz, this.getCell(Ja.ox - 1, Ja.oz)[Ja.depth][Ja.sqb][Ja.iz + 1]))
                                      : (Ja.th += this.lerpHeight(Ja.d, Ja.px + 1, Ja.pz - 1, this.getCell(Ja.ox - 1, Ja.oz + 1)[Ja.depth][Ja.sqb][0]))),
                            Ja.ix < Ja.sqb
                                ? (Ja.iz >= 0 ? (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz, Ja.layer[Ja.ix + 1][Ja.iz])) : (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz + 1, this.getCell(Ja.ox, Ja.oz - 1)[Ja.depth][Ja.ix + 1][Ja.sqb])),
                                  Ja.iz < Ja.sqb ? (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz, Ja.layer[Ja.ix + 1][Ja.iz + 1])) : (Ja.th += this.lerpHeight(Ja.d, Ja.px, Ja.pz - 1, this.getCell(Ja.ox, Ja.oz + 1)[Ja.depth][Ja.ix + 1][0])))
                                : (Ja.iz >= 0
                                      ? (Ja.th += this.lerpHeight(Ja.d, Ja.px - 1, Ja.pz, this.getCell(Ja.ox + 1, Ja.oz)[Ja.depth][0][Ja.iz]))
                                      : (Ja.th += this.lerpHeight(Ja.d, Ja.px - 1, Ja.pz + 1, this.getCell(Ja.ox + 1, Ja.oz - 1)[Ja.depth][0][Ja.sqb])),
                                  Ja.iz < Ja.sqb
                                      ? (Ja.th += this.lerpHeight(Ja.d, Ja.px - 1, Ja.pz, this.getCell(Ja.ox + 1, Ja.oz)[Ja.depth][0][Ja.iz + 1]))
                                      : (Ja.th += this.lerpHeight(Ja.d, Ja.px - 1, Ja.pz - 1, this.getCell(Ja.ox + 1, Ja.oz + 1)[Ja.depth][0][0]))),
                            (Ja.h += Ja.th),
                            Ja.depth++,
                            (Ja.sq = this.resolutions[Ja.depth]),
                            (Ja.sqb = Ja.sq - 1);
                    }
                    return (Ja.h += this.heightOffset), Ja.h > this.threshold ? (Ja.h > this.threshold3 ? ((Ja.th *= Ja.th), Ja.th > 0.11 ? (Ja.th > 0.13 ? 2 : 1) : 0) : Ja.h > this.threshold2 ? 1 : 2) : 3;
                }
            };
            var _a = new (class {
                constructor() {
                    (this.lib = { trees: {}, brush: {} }),
                        (this.randMaps = { trees: [[], [], []], brush: [] }),
                        (this.stagedTiles = { trees: {}, brush: {} }),
                        (this.hasTrees = !0),
                        (this.hasGrass = !0),
                        (this.rand = new window.alea(Be)),
                        (this.rands = []),
                        (this.randIndex = 0),
                        (this.farTreeInstancePool = []),
                        this.buildLibrary(),
                        this.buildRandMaps(),
                        this.buildRands();
                }
                buildMap(e) {
                    (this.treeMap = new Ka(Be, e)), (this.grassMap = new Xa(Be, { heightScale: 2, heightOffset: 0.5, heightInitial: 0, resolutions: [5], threshold: 0.05, threshold2: 0.25, threshold3: 0.5, smooth: !0 }));
                }
                buildRandMaps() {
                    let e, t, i;
                    for (e = 1; e <= 8; e++)
                        for (i = 0; i < this.randMaps.trees.length; i++) {
                            let e = [],
                                s = Math.ceil(1.4 * (i + this.rand())),
                                n = 0.05,
                                a = 1 - 2 * n;
                            for (t = 0; t < s; t++) e.push(n + this.rand() * a, n + this.rand() * a);
                            this.randMaps.trees[i].push(e);
                        }
                }
                buildRands() {
                    for (let e = 0; e < 101; e++) this.rands.push(this.rand());
                }
                getRand() {
                    return this.randIndex >= this.rands.length && (this.randIndex = 0), this.rands[this.randIndex++];
                }
                getTreesAt(e, t) {
                    return (this.t = this.treeMap.getXZ(e, t)), this.t ? this.getSeededTreeMap(this.t, (e + t) / 10) : null;
                }
                getSeededTreeMap(e, t) {
                    return this.randMaps.trees[e - 1][7 & t];
                }
                getTreeMap(e) {
                    return this.randMaps.trees[e - 1][Math.floor(8 * this.getRand())];
                }
                buildLibrary() {
                    let e = new r.g(),
                        t = new Float32Array([-0.5, 0, 0, -0.5, 1, 0, 0.5, 1, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 1, 0.5, 0, 1, -0.5, 0, 0, -0.5]);
                    e.setAttribute("position", new r.o(t, 3));
                    let i = new Float32Array([0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]);
                    e.setAttribute("normal", new r.o(i, 3));
                    let s = new Float32Array([0, 0, 0, 0.49, 0.5, 0.49, 0.5, 0, 0, 0, 0, 0.49, 0.5, 0.49, 0.5, 0]);
                    e.setAttribute("uv", new r.o(s, 2));
                    e.setIndex([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7]), (this.baseGeo = e);
                    let n = e.clone();
                    n.scale(8, 8, 8), (this.lib.trees.far = { geo: n, mat: Os[0] });
                    let a = e.clone(),
                        o = new Float32Array([0, 0, 0, 0.49, 0.25, 0.49, 0.25, 0, 0.25, 0, 0.25, 0.49, 0.5, 0.49, 0.5, 0]);
                    a.setAttribute("uv", new r.o(o, 2));
                    let h = a.clone();
                    h.scale(8, 8, 8), (this.lib.trees.near = { geo: h, mat: Os[1] });
                    let l = e.clone();
                    l.scale(1.6, 1.6, 1.6), (this.lib.brush.grass = { geo: l, mat: Ps[0] });
                    let d = a.clone();
                    d.scale(1.6, 1.6, 1.6), (this.lib.brush.bush = { geo: d, mat: Ps[1] });
                }
                getGrassInstance(e) {
                    let t = new r.u(this.lib.brush.grass.geo.clone(), this.lib.brush.grass.mat, e);
                    return (
                        (t.matrixAutoUpdate = !1),
                        t.geometry.setAttribute("variant", new r.t(new Float32Array(e), 1)),
                        (t.instanceVariant = t.geometry.attributes.variant),
                        t.instanceVariant.setUsage(r.l),
                        t.geometry.setAttribute("shadow", new r.t(new Float32Array(e), 1)),
                        (t.instanceShadow = t.geometry.attributes.shadow),
                        t.instanceShadow.setUsage(r.l),
                        (t.position.y = -0.1),
                        t.instanceMatrix.setUsage(r.l),
                        t
                    );
                }
                getBushInstance(e) {
                    let t = new r.u(this.lib.brush.bush.geo.clone(), this.lib.brush.bush.mat, e);
                    return (
                        (t.matrixAutoUpdate = !1),
                        t.geometry.setAttribute("variant", new r.t(new Float32Array(e), 1)),
                        (t.instanceVariant = t.geometry.attributes.variant),
                        t.instanceVariant.setUsage(r.l),
                        t.geometry.setAttribute("shadow", new r.t(new Float32Array(e), 1)),
                        (t.instanceShadow = t.geometry.attributes.shadow),
                        t.instanceShadow.setUsage(r.l),
                        (t.position.y = -0.1),
                        t.instanceMatrix.setUsage(r.l),
                        t
                    );
                }
                prepareTreeInstance(e, t, i = !0) {
                    e.geometry.setAttribute("variant", new r.t(new Float32Array(t), 1)),
                        (e.instanceVariant = e.geometry.attributes.variant),
                        e.instanceVariant.setUsage(r.l),
                        i && (e.geometry.setAttribute("shadow", new r.t(new Float32Array(t), 1)), (e.instanceShadow = e.geometry.attributes.shadow), e.instanceShadow.setUsage(r.l)),
                        (e.position.y = -0.5),
                        e.instanceMatrix.setUsage(r.l);
                }
                getNearTreeDetailInstance(e) {
                    let t = new r.u(this.lib.trees.detail.geo.clone(), this.lib.trees.detail.mat, e);
                    return (t.matrixAutoUpdate = !1), (t.frustumCulled = !0), this.prepareTreeInstance(t, e, !1), t;
                }
                getNearTreeInstance(e) {
                    let t = new r.u(this.lib.trees.near.geo.clone(), this.lib.trees.near.mat, e);
                    return (t.matrixAutoUpdate = !1), this.prepareTreeInstance(t, e, !1), t;
                }
                returnFarTreeInstance(e) {
                    (e.visible = !1), (e.count = 0), this.farTreeInstancePool.push(e);
                }
                getFarTreeInstance(e) {
                    if (this.farTreeInstancePool.length) return this.farTreeInstancePool.pop();
                    let t = new r.u(this.lib.trees.far.geo.clone(), this.lib.trees.far.mat, e);
                    return (t.matrixAutoUpdate = !1), (t.frustumCulled = !0), this.prepareTreeInstance(t, e, !1), t;
                }
            })();
            const $a = new r.A();
            class eo {
                constructor() {
                    (this.initNodeIndex = 0), (this.retireNodeIndex = -1), (this.showNodeIndex = 0);
                }
            }
            var to = class {
                constructor(e, t, i = 50, s = null) {
                    (this.lodInstances = [[], []]),
                        (this.stagedInstances = [[], []]),
                        (this.activeInstances = [[], []]),
                        (this.currentInstances = []),
                        (this.minRenderDist = 50),
                        (this.maxInstanceRange = 50),
                        (this.debug = !1),
                        (this.skipLod = null),
                        (this.instanceCounter = 0),
                        (this.container = new r.G()),
                        (this.instanceType = e),
                        (this.skipLod = s),
                        (this.instanceCount = t),
                        (this.minRenderDist = i),
                        (this.maxInstanceRange = i);
                }
                revert(e, t) {
                    (this.instanceCount = e || this.instanceCount),
                        (this.minRenderDist = t || this.minRenderDist),
                        (this.maxInstanceRange = this.minRenderDist),
                        this.destroy(),
                        (this.lodInstances[0].length = 0),
                        (this.lodInstances[1].length = 0),
                        (this.stagedInstances[0].length = 0),
                        (this.stagedInstances[1].length = 0),
                        (this.activeInstances[0].length = 0),
                        (this.activeInstances[1].length = 0),
                        this.initialise();
                }
                reset() {
                    for (let e of this.currentInstances) null != e && ((e.index = 0), (e.showNodeIndex = 0), (e.retireNodeIndex = 0), (e.initNodeIndex = 0), (e.mesh.count = 0), (e.mesh.visible = !1));
                    (this.lodInstances[0].length = 0),
                        (this.lodInstances[1].length = 0),
                        (this.stagedInstances[0].length = 0),
                        (this.stagedInstances[1].length = 0),
                        (this.activeInstances[0].length = 0),
                        (this.activeInstances[1].length = 0);
                }
                destroy() {
                    this.container.traverse((e) => {
                        e.isMesh && e.geometry.dispose();
                    }),
                        this.container.clear();
                }
                initialise() {
                    0 !== this.skipLod && ((en["instance-" + this.instanceType.typeName + "-0"] = 1), (this.currentInstances[0] = this.getInstance($t.head.p))),
                        1 !== this.skipLod && ((en["instance-" + this.instanceType.typeName + "-1"] = 1), (this.currentInstances[1] = this.getInstance($t.head.p)));
                }
                initInstance(e) {}
                getInstance(e = null) {
                    let t = new this.instanceType();
                    return (t.mesh.matrixAutoUpdate = !1), e && (t.mesh.position.copy(e), t.mesh.updateMatrix()), (t.mesh.visible = !1), (t.iid = this.instanceCounter++), this.container.add(t.mesh), t;
                }
                addInstance(e, t, i, s, n, a = null, o = 0) {
                    let r = this.currentInstances[e];
                    0 == r.index ? this.stageInstance(e, r, s, n) : (r.retireNodeIndex = s + 3),
                        $a.makeTranslation(-r.mesh.position.x, -r.mesh.position.y, -r.mesh.position.z),
                        t.premultiply($a),
                        r.mesh.setMatrixAt(r.index, t),
                        r.index++,
                        r.index >= this.instanceCount && this.cycleInstances(e);
                }
                stageInstance(e, t, i, s) {
                    (t.initNodeIndex = i), (t.showNodeIndex = i - this.minRenderDist), (t.retireNodeIndex = i + this.maxInstanceRange + 3), t.mesh.position.copy(s), t.mesh.updateMatrix(), this.stagedInstances[e].push(t);
                }
                updateInstanceState(e) {
                    (e.mesh.instanceMatrix.needsUpdate = !0), (e.mesh.count = Math.min(this.instanceCount, Math.max(0, e.index)));
                }
                updateCurrentInstance(e) {
                    let t = this.currentInstances[e];
                    $t.vehicleIndex >= t.showNodeIndex && this.updateInstanceState(t);
                }
                initialiseVisible() {
                    let e, t;
                    do {
                        (e = this.stagedInstances[0].length), (t = this.stagedInstances[1].length), this.updateVisible();
                    } while (e != this.stagedInstances[0].length || t !== this.stagedInstances[1].length);
                }
                updateVisible() {
                    0 !== this.skipLod &&
                        ((this.t = this.stagedInstances[0]),
                        this.t.length && $t.vehicleIndex >= this.t[0].showNodeIndex && (this.updateInstanceState(this.t[0]), (this.t[0].mesh.visible = !0), this.activeInstances[0].push(this.t.shift())),
                        (this.t = this.activeInstances[0]),
                        this.t.length && this.t[0].retireNodeIndex <= $t.vehicleIndex && ((this.t[0].mesh.visible = !1), this.lodInstances[0].push(this.activeInstances[0].shift())),
                        this.currentInstances[0].index && $t.vehicleIndex >= this.currentInstances[0].initNodeIndex && this.cycleInstances(0),
                        (en["instance-" + this.instanceType.typeName + "-0"] = this.activeInstances[0].length + "(" + this.stagedInstances[0].length + ")")),
                        1 !== this.skipLod &&
                            ((this.t = this.stagedInstances[1]),
                            this.t.length && $t.vehicleIndex >= this.t[0].showNodeIndex && (this.updateInstanceState(this.t[0]), (this.t[0].mesh.visible = !0), this.activeInstances[1].push(this.t.shift())),
                            (this.t = this.activeInstances[1]),
                            this.t.length && this.t[0].retireNodeIndex <= $t.vehicleIndex && ((this.t[0].mesh.visible = !1), this.lodInstances[1].push(this.activeInstances[1].shift())),
                            this.currentInstances[1].index && $t.vehicleIndex >= this.currentInstances[1].initNodeIndex && this.cycleInstances(1),
                            (en["instance-" + this.instanceType.typeName + "-1"] = this.activeInstances[1].length + "(" + this.stagedInstances[1].length + ")"));
                }
                cycleInstances(e) {
                    let t = this.currentInstances[e];
                    t.mesh.count != t.index && this.updateInstanceState(t),
                        this.lodInstances[e].length
                            ? (t = this.lodInstances[e].pop())
                            : ((t = this.getInstance()), (en["instance-" + this.instanceType.typeName + "-" + e] = this.activeInstances[e].length + "(" + (this.stagedInstances[e].length + 1) + ")")),
                        (t.index = 0),
                        (t.mesh.count = 0),
                        (t.mesh.visible = !1),
                        (this.currentInstances[e] = t);
                }
            };
            const io = new r.A();
            var so = class extends to {
                addInstance(e, t, i, s, n, a = null, o = null) {
                    (this.temp = this.currentInstances[e]),
                        0 == this.temp.index ? this.stageInstance(e, this.temp, s, n) : s > this.temp.retireNodeIndex && (this.temp.retireNodeIndex = s),
                        io.makeTranslation(-this.temp.mesh.position.x, -this.temp.mesh.position.y, -this.temp.mesh.position.z),
                        t.premultiply(io),
                        this.temp.mesh.setMatrixAt(this.temp.index, t),
                        (this.temp.mesh.instanceVariant.array[this.temp.index] = i),
                        null !== o && (this.temp.mesh.instanceShadow.array[this.temp.index] = o),
                        this.temp.index++,
                        this.temp.index >= this.instanceCount && this.cycleInstances(e, s, n);
                }
                updateInstanceState(e) {
                    (e.mesh.instanceMatrix.needsUpdate = !0), (e.mesh.instanceVariant.needsUpdate = !0), e.mesh.instanceShadow && (e.mesh.instanceShadow.needsUpdate = !0), (e.mesh.count = Math.min(this.instanceCount, Math.max(0, e.index)));
                }
                updateCurrentInstance(e) {
                    let t = this.currentInstances[e];
                    $t.vehicleIndex >= t.showNodeIndex && t.mesh.count < t.index && this.updateInstanceState(t);
                }
                cycleInstances(e) {
                    let t = this.currentInstances[e];
                    (t.retireNodeIndex += 5),
                        t.mesh.count != t.index && this.updateInstanceState(t),
                        this.lodInstances[e].length
                            ? (t = this.lodInstances[e].pop())
                            : ((t = this.getInstance()), (en["instance-" + this.instanceType.typeName + "-" + e] = this.activeInstances[e].length + "(" + this.stagedInstances[e].length + ")")),
                        (t.index = 0),
                        (t.mesh.count = 0),
                        (t.mesh.visible = !1),
                        (this.currentInstances[e] = t);
                }
            };
            class no extends eo {
                constructor() {
                    super(), (this.index = 0), (this.mesh = _a.getNearTreeInstance(Ds)), (this.retireNodeIndex = -1), (this.showNodeIndex = 0);
                }
            }
            no.typeName = "trees";
            var ao = new so(no, Ds, Cs, 1);
            class oo extends eo {
                constructor() {
                    super(), (this.index = 0), (this.mesh = _a.getGrassInstance(Rs)), (this.mesh.receiveShadow = Ih.value.detailLodIndex > 0), (this.retireNodeIndex = -1), (this.showNodeIndex = 0);
                }
            }
            oo.typeName = "grass";
            var ro = new so(oo, Rs, Ns);
            class ho extends eo {
                constructor() {
                    super(), (this.index = 0), (this.mesh = _a.getBushInstance(Ts)), (this.mesh.receiveShadow = Ih.value.detailLodIndex > 1), (this.retireNodeIndex = -1), (this.showNodeIndex = 0);
                }
            }
            ho.typeName = "bush";
            var lo = new so(ho, Ts, Ns, 0);
            const co = {},
                po = new r.G(),
                uo = new Pn(157),
                go = new Pn(157, 1, 0.5),
                mo = new Pn(103, 6.28),
                xo = new Pn(101, 4),
                vo = new Pn(101, 0.4),
                fo = {};
            class wo extends si {
                constructor(...e) {
                    super(...e), (this.treeDensity = !1), (this.forceTrees = !1), (this.trees = []), (this.treeMaskCorners = []), (this.treeDensity = 0), (this.renderFoliage = !0);
                }
                display(...e) {
                    super.display(...e), 1 == this.lod && this.tileset.mesh.visible && (ro.updateCurrentInstance(1), lo.updateCurrentInstance(1));
                }
                preInitialise(e) {
                    var t;
                    if (((this.forceTrees = e), (this.trees.length = 0), (this.renderFoliage = Ih.value.detailLodIndex > 0), (fo.treeMask = null === (t = co[this.farCell.x]) || void 0 === t ? void 0 : t[this.farCell.z]), !fo.treeMask))
                        return !1;
                    (fo.res1 = yt + 1),
                        (fo.treeIndex = this.tileCoords.x * fo.res1 + this.tileCoords.z),
                        (this.treeMaskCorners[0] = fo.treeMask[fo.treeIndex]),
                        (this.treeMaskCorners[1] = fo.treeMask[fo.treeIndex + fo.res1]),
                        (this.treeMaskCorners[2] = fo.treeMask[fo.treeIndex + 1]),
                        (this.treeMaskCorners[3] = fo.treeMask[fo.treeIndex + 1 + fo.res1]),
                        (this.treeDensity = this.treeMaskCorners.reduce((e, t) => e + t, 0) / 4);
                    let i = _a.getTreesAt(this.originPos.x, this.originPos.z);
                    if (i) {
                        let e, t, s;
                        for (t = 0; t < i.length; t += 2)
                            (s = mo.next()),
                                (e = { position: [i[t], i[t + 1]], rotation: s, type: Math.round(s / 2) }),
                                (s = _t(e.position[0] * zt + this.originPos.x, e.position[1] * zt + this.originPos.z, this.originNode, !1)),
                                (s.e = Ht + Math.abs(s.da)),
                                s.d - (s.w + s.e) > 2 && this.trees.push(e);
                    } else if (this.originNode.dswl || this.originNode.dswr) {
                        let e = _t(this.originPos.x + 5, this.originPos.z + 5, this.originNode);
                        if (e.d < e.w + 4 && ((e.s > 0 && this.originNode.dswl) || (e.s < 0 && this.originNode.dswr))) {
                            let t = (e.w + 2 - e.d) / 10;
                            t > 0 && t < 0.2 && this.trees.push({ position: [0.5 - t * this.originNode.n.x * e.s, 0.5 - t * this.originNode.n.z * e.s], rotation: 15 * t, type: Math.floor(12 * t) });
                        }
                    }
                    return !0;
                }
                postProcessRow(e) {
                    this.placeGrassRow(e);
                }
                postProcessCell() {
                    if (0 == this.lod || this.forceTrees) {
                        let e, t, i;
                        for (let s of this.trees)
                            (e = Math.floor(s.position[0] * this.res)),
                                (t = Math.floor(s.position[1] * this.res)),
                                (i = e * this.res1 + t),
                                this.grads[i] < 0.2 &&
                                    this.heights[i] > 1 &&
                                    (po.position.set((this.coords.x + s.position[0]) * zt, this.heights[i] - (0.5 + this.grads[i]), (this.coords.z + s.position[1]) * zt),
                                    (fo.tms = 0.15 * (3 * this.treeDensity - 1) + 1),
                                    (fo.hb = fo.tms + (vo.next() - 0.2) * fo.tms),
                                    po.scale.set(fo.hb, fo.hb, fo.hb),
                                    (po.rotation.y = s.rotation),
                                    po.updateMatrix(),
                                    ao.addInstance(0, po.matrix, s.type, this.originIndex, po.position));
                    }
                }
                nearestTreeDist(e, t) {
                    let i,
                        s = -1;
                    for (let n of this.trees) (i = (n.position[0] - e) * (n.position[0] - e) + (n.position[1] - t) * (n.position[1] - t)), (i < s || s < 0) && (s = i);
                    return s;
                }
                placeGrassRow(e) {
                    for (fo.j = 0; fo.j <= this.res; fo.j++)
                        if (
                            ((fo.ind = e * this.res1 + fo.j),
                            (fo.h = this.heights[fo.ind]),
                            (fo.r = this.signedRoadProx[fo.ind]),
                            (fo.n = [this.norms[3 * fo.ind], this.norms[3 * fo.ind + 1], this.norms[3 * fo.ind + 2]]),
                            (fo.az = e / this.res),
                            (fo.ax = fo.j / this.res),
                            (fo.ma = this.treeMaskCorners[2] * fo.ax + this.treeMaskCorners[0] * (1 - fo.ax)),
                            (fo.mb = this.treeMaskCorners[3] * fo.ax + this.treeMaskCorners[1] * (1 - fo.ax)),
                            (fo.tm = fo.mb * fo.az + fo.ma * (1 - fo.az)),
                            fo.r < 2 && (fo.tm *= fo.r / 2),
                            (this.treeMask[fo.ind] = fo.tm),
                            this.renderFoliage && ((fo.grassProb = fo.j < this.res1 && fo.r > 0.2 && fo.r < 20 ? (fo.h > 2 ? (this.grads[fo.ind] < 0.2 ? 1 : 0.4 - this.grads[fo.ind]) : fo.h - 1) : 0), fo.grassProb > uo.next()))
                        ) {
                            if (
                                (fo.r < Ht ? (fo.h -= Ht - fo.r) : (fo.h -= fo.r / 20),
                                po.position.set((this.coords.x + fo.az) * zt + go.next(), fo.h - this.grads[fo.ind] / 2 + 0.2 * go.next(), (this.coords.z + fo.ax) * zt + go.next()),
                                (po.rotation.y = mo.next()),
                                (fo.treeProx = this.nearestTreeDist(fo.az, fo.ax)),
                                fo.treeProx < 0 ? (fo.treeProx = 0) : ((fo.treeProx = 0.25 - Math.min(0.25, fo.treeProx / 0.25)), fo.r < 4 && (fo.treeProx *= fo.r / 4)),
                                (this.treeMask[fo.ind] = Math.max(this.treeMask[fo.ind], 4 * fo.treeProx)),
                                (fo.treeProx = this.treeMask[fo.ind] / 2 + Math.abs(this.grads[fo.ind] / 2)),
                                (fo.bushProb = this.treeDensity + 0.008),
                                fo.bushProb < 0.5 &&
                                    (this.originNode.dswl || this.originNode.dswr) &&
                                    fo.r > 1 &&
                                    fo.r < 1.6 &&
                                    ((fo.side = -this.originNode.n.z * (this.originPos.z + 10 * fo.az - this.originNode.p.z) - this.originNode.n.x * (this.originPos.x + 10 * fo.ax - this.originNode.p.x)),
                                    ((this.originNode.dswl && fo.side > 0) || (this.originNode.dswr && fo.side < 0)) && (fo.bushProb += 0.33),
                                    fo.bushProb > 1 && (fo.bushProb = 1)),
                                fo.r < 0.5 || fo.r > 4 ? (fo.bushProb = 0) : fo.r < 1 ? (fo.bushProb *= 4 * (fo.r - 0.5)) : fo.r < 2 ? (fo.bushProb *= 2) : fo.r < 4 && (fo.bushProb *= 4 - fo.r),
                                (fo.bushProb *= 0.25),
                                1 == this.lod && fo.bushProb > Math.random())
                            ) {
                                (po.scale.x = po.scale.y = po.scale.z = Math.min(fo.r, 1 + this.treeDensity * vo.next())),
                                    (po.rotation.y = mo.next()),
                                    po.updateMatrix(),
                                    lo.addInstance(1, po.matrix, Math.floor(xo.next()), this.originIndex, po.position, fo.n, fo.treeProx);
                                continue;
                            }
                            (po.scale.y = 1),
                                fo.r > 1 ? (fo.r > 2 ? (po.scale.y += 0.5 * this.treeDensity) : (po.scale.y += (fo.r - 1) * this.treeDensity * 0.5)) : (po.scale.y = Math.max(0.75, fo.r)),
                                (po.scale.x = po.scale.z = po.scale.y),
                                po.updateMatrix(),
                                ro.addInstance(this.lod, po.matrix, fo.r, this.originIndex, po.position, fo.n, fo.treeProx);
                        }
                }
            }
            wo.paved = !0;
            var bo = wo;
            const Ao = {
                size: 1e3,
                nodes: [
                    [0, 0],
                    [200, 0],
                    [400, 0],
                    [600, 0],
                    [750, 0],
                    [1e3, 0],
                    [0, 200],
                    [200, 100],
                    [400, 100],
                    [550, 200],
                    [750, 200],
                    [1e3, 150],
                    [0, 300],
                    [200, 300],
                    [300, 300],
                    [500, 300],
                    [800, 350],
                    [1e3, 350],
                    [0, 500],
                    [150, 500],
                    [300, 450],
                    [500, 450],
                    [600, 450],
                    [800, 450],
                    [1e3, 500],
                    [0, 700],
                    [150, 700],
                    [300, 700],
                    [300, 650],
                    [400, 650],
                    [600, 650],
                    [700, 650],
                    [800, 650],
                    [1e3, 650],
                    [0, 850],
                    [200, 850],
                    [300, 850],
                    [400, 850],
                    [500, 850],
                    [700, 800],
                    [850, 800],
                    [1e3, 800],
                    [0, 1e3],
                    [200, 1e3],
                    [300, 1e3],
                    [500, 1e3],
                    [700, 1e3],
                    [850, 1e3],
                    [1e3, 1e3],
                ],
                fields: [
                    { nodes: [0, 1, 7, 6], center: [100, 75], radius2: 25625, radius: 160.0781059358212, walls: [0, 1, 2, 3] },
                    { nodes: [1, 2, 8, 7], center: [300, 50], radius2: 12500, walls: [4, 5, 6, 1], radius: 111.80339887498948 },
                    { nodes: [2, 3, 9, 8], center: [487.5, 75], radius2: 19531.25, walls: [7, 8, 9, 5], radius: 139.75424859373686 },
                    { nodes: [3, 4, 10, 9], center: [662.5, 100], radius2: 22656.25, walls: [10, 11, 12, 8], radius: 150.5199322349037 },
                    { nodes: [4, 5, 11, 10], center: [875, 87.5], radius2: 28281.25, walls: [13, 14, 15, 11], radius: 168.17030058842138 },
                    { nodes: [6, 7, 13, 12], center: [100, 225], radius2: 25625, walls: [2, 16, 17, 18], radius: 160.0781059358212 },
                    { nodes: [7, 8, 14, 13], center: [275, 200], radius2: 25625, walls: [6, 19, 20, 16], radius: 160.0781059358212 },
                    { nodes: [8, 9, 15, 14], center: [437.5, 225], radius2: 24531.25, walls: [9, 21, 22, 19], radius: 156.62455107677084 },
                    { nodes: [9, 10, 16, 15], center: [650, 262.5], radius2: 30156.25, walls: [12, 23, 24, 21], radius: 173.65554986812256 },
                    { nodes: [10, 11, 17, 16], center: [887.5, 262.5], radius2: 25312.5, walls: [15, 25, 26, 23], radius: 159.0990257669732 },
                    { nodes: [12, 13, 19, 18], center: [87.5, 400], radius2: 22656.25, walls: [17, 27, 28, 29], radius: 150.5199322349037 },
                    { nodes: [13, 14, 20, 19], center: [237.5, 387.5], radius2: 20312.5, walls: [20, 30, 31, 27], radius: 142.52192813739225 },
                    { nodes: [14, 15, 21, 20], center: [400, 375], radius2: 15625, walls: [22, 32, 33, 30], radius: 125 },
                    { nodes: [15, 16, 23, 22, 21], center: [640, 400], radius2: 29600, walls: [24, 34, 35, 36, 32], radius: 172.04650534085255 },
                    { nodes: [16, 17, 24, 23], center: [900, 412.5], radius2: 17656.25, walls: [26, 37, 38, 34], radius: 132.87682265918312 },
                    { nodes: [18, 19, 26, 25], center: [75, 600], radius2: 15625, walls: [28, 39, 40, 41], radius: 125 },
                    { nodes: [19, 20, 28, 27, 26], center: [240, 600], radius2: 26100, walls: [31, 42, 43, 44, 39], radius: 161.55494421403512 },
                    { nodes: [20, 21, 29, 28], center: [375, 550], radius2: 25625, walls: [33, 45, 46, 42], radius: 160.0781059358212 },
                    { nodes: [21, 22, 30, 29], center: [525, 550], radius2: 25625, walls: [36, 47, 48, 45], radius: 160.0781059358212 },
                    { nodes: [22, 23, 32, 31, 30], center: [700, 570], radius2: 24400, walls: [35, 49, 50, 51, 47], radius: 156.20499351813308 },
                    { nodes: [23, 24, 33, 32], center: [900, 562.5], radius2: 22656.25, walls: [38, 52, 53, 49], radius: 150.5199322349037 },
                    { nodes: [25, 26, 35, 34], center: [87.5, 775], radius2: 18281.25, walls: [40, 54, 55, 56], radius: 135.2081728298996 },
                    { nodes: [26, 27, 36, 35], center: [237.5, 775], radius2: 13281.25, walls: [44, 57, 58, 54], radius: 115.2443057161611 },
                    { nodes: [27, 28, 29, 37, 36], center: [340, 740], radius2: 15700, walls: [43, 46, 59, 60, 57], radius: 125.29964086141668 },
                    { nodes: [29, 30, 38, 37], center: [475, 750], radius2: 25625, walls: [48, 61, 62, 59], radius: 160.0781059358212 },
                    { nodes: [30, 31, 39, 38], center: [625, 737.5], radius2: 28281.25, walls: [51, 63, 64, 61], radius: 168.17030058842138 },
                    { nodes: [31, 32, 40, 39], center: [762.5, 725], radius2: 13281.25, walls: [50, 65, 66, 63], radius: 115.2443057161611 },
                    { nodes: [32, 33, 41, 40], center: [912.5, 725], radius2: 18281.25, walls: [53, 67, 68, 65], radius: 135.2081728298996 },
                    { nodes: [34, 35, 43, 42], center: [100, 925], radius2: 15625, walls: [55, 69, 70, 71], radius: 125 },
                    { nodes: [35, 36, 37, 44, 43], center: [280, 910], radius2: 18e3, walls: [58, 60, 72, 73, 69], radius: 134.16407864998737 },
                    { nodes: [37, 38, 45, 44], center: [425, 925], radius2: 21250, walls: [62, 74, 75, 72], radius: 145.7737973711325 },
                    { nodes: [38, 39, 46, 45], center: [600, 912.5], radius2: 22656.25, walls: [64, 76, 77, 74], radius: 150.5199322349037 },
                    { nodes: [39, 40, 47, 46], center: [775, 900], radius2: 15625, walls: [66, 78, 79, 76], radius: 125 },
                    { nodes: [40, 41, 48, 47], center: [925, 900], radius2: 15625, walls: [68, 80, 81, 78], radius: 125 },
                ],
                walls: [
                    [0, 0, 200, 0],
                    [200, 0, 200, 100],
                    [200, 100, 0, 200],
                    [0, 200, 0, 0],
                    [200, 0, 400, 0],
                    [400, 0, 400, 100],
                    [400, 100, 200, 100],
                    [400, 0, 600, 0],
                    [600, 0, 550, 200],
                    [550, 200, 400, 100],
                    [600, 0, 750, 0],
                    [750, 0, 750, 200],
                    [750, 200, 550, 200],
                    [750, 0, 1e3, 0],
                    [1e3, 0, 1e3, 150],
                    [1e3, 150, 750, 200],
                    [200, 100, 200, 300],
                    [200, 300, 0, 300],
                    [0, 300, 0, 200],
                    [400, 100, 300, 300],
                    [300, 300, 200, 300],
                    [550, 200, 500, 300],
                    [500, 300, 300, 300],
                    [750, 200, 800, 350],
                    [800, 350, 500, 300],
                    [1e3, 150, 1e3, 350],
                    [1e3, 350, 800, 350],
                    [200, 300, 150, 500],
                    [150, 500, 0, 500],
                    [0, 500, 0, 300],
                    [300, 300, 300, 450],
                    [300, 450, 150, 500],
                    [500, 300, 500, 450],
                    [500, 450, 300, 450],
                    [800, 350, 800, 450],
                    [800, 450, 600, 450],
                    [600, 450, 500, 450],
                    [1e3, 350, 1e3, 500],
                    [1e3, 500, 800, 450],
                    [150, 500, 150, 700],
                    [150, 700, 0, 700],
                    [0, 700, 0, 500],
                    [300, 450, 300, 650],
                    [300, 650, 300, 700],
                    [300, 700, 150, 700],
                    [500, 450, 400, 650],
                    [400, 650, 300, 650],
                    [600, 450, 600, 650],
                    [600, 650, 400, 650],
                    [800, 450, 800, 650],
                    [800, 650, 700, 650],
                    [700, 650, 600, 650],
                    [1e3, 500, 1e3, 650],
                    [1e3, 650, 800, 650],
                    [150, 700, 200, 850],
                    [200, 850, 0, 850],
                    [0, 850, 0, 700],
                    [300, 700, 300, 850],
                    [300, 850, 200, 850],
                    [400, 650, 400, 850],
                    [400, 850, 300, 850],
                    [600, 650, 500, 850],
                    [500, 850, 400, 850],
                    [700, 650, 700, 800],
                    [700, 800, 500, 850],
                    [800, 650, 850, 800],
                    [850, 800, 700, 800],
                    [1e3, 650, 1e3, 800],
                    [1e3, 800, 850, 800],
                    [200, 850, 200, 1e3],
                    [200, 1e3, 0, 1e3],
                    [0, 1e3, 0, 850],
                    [400, 850, 300, 1e3],
                    [300, 1e3, 200, 1e3],
                    [500, 850, 500, 1e3],
                    [500, 1e3, 300, 1e3],
                    [700, 800, 700, 1e3],
                    [700, 1e3, 500, 1e3],
                    [850, 800, 850, 1e3],
                    [850, 1e3, 700, 1e3],
                    [1e3, 800, 1e3, 1e3],
                    [1e3, 1e3, 850, 1e3],
                ],
                nodeToFields: [
                    [0],
                    [0, 1],
                    [1, 2],
                    [2, 3],
                    [3, 4],
                    [4],
                    [0, 5],
                    [0, 1, 5, 6],
                    [1, 2, 6, 7],
                    [2, 3, 7, 8],
                    [3, 4, 8, 9],
                    [4, 9],
                    [5, 10],
                    [5, 6, 10, 11],
                    [6, 7, 11, 12],
                    [7, 8, 12, 13],
                    [8, 9, 13, 14],
                    [9, 14],
                    [10, 15],
                    [10, 11, 15, 16],
                    [11, 12, 16, 17],
                    [12, 13, 17, 18],
                    [13, 18, 19],
                    [13, 14, 19, 20],
                    [14, 20],
                    [15, 21],
                    [15, 16, 21, 22],
                    [16, 22, 23],
                    [16, 17, 23],
                    [17, 18, 23, 24],
                    [18, 19, 24, 25],
                    [19, 25, 26],
                    [19, 20, 26, 27],
                    [20, 27],
                    [21, 28],
                    [21, 22, 28, 29],
                    [22, 23, 29],
                    [23, 24, 29, 30],
                    [24, 25, 30, 31],
                    [25, 26, 31, 32],
                    [26, 27, 32, 33],
                    [27, 33],
                    [28],
                    [28, 29],
                    [29, 30],
                    [30, 31],
                    [31, 32],
                    [32, 33],
                    [33],
                ],
            };
            var yo = Ao;
            let Io = At,
                So = 2 * Io * 3;
            const Mo = 1.45,
                Do = Ft + 1.25,
                ko = new Pn(97),
                Co = new r.F({ map: et(null), side: r.k, flatShading: !0, emissiveIntensity: 0.01 }),
                jo = {};
            class No extends r.g {
                constructor() {
                    super(), (this.wallMap = []), (this.curVertIndex = 0), (this.curIndex = 0);
                    let e = 2 * Io * 3;
                    this.setIndex(new Float32Array(2 * (Io - 1))), this.setAttribute("position", new r.o(new Float32Array(e), 3)), this.attributes.position.setUsage(r.l);
                    let t = [],
                        i = 0;
                    for (let s = 0; s < e; s += 6) t.push(0, i, 0.45, i), (i += 2);
                    this.setAttribute("uv", new r.o(new Float32Array(t), 2)), this.attributes.uv.setUsage(r.l), (this.matrixAutoUpdate = !1), this.setDrawRange(0, 0);
                }
            }
            var zo = class {
                constructor(e, t, i, s, n) {
                    (this.verts = []),
                        (this.index = []),
                        (this.wallMap = []),
                        (this.wallsToDraw = []),
                        (this.fieldMap = []),
                        (this.leftWallNodes = []),
                        (this.rightWallNodes = []),
                        (this.curWallIndex = 0),
                        (this.curVertIndex = 0),
                        (this.curUVIndex = 0),
                        (this.curIndex = 0),
                        (this.fieldMapOffset = new r.V()),
                        (this.getXZ = () => {}),
                        (this.getXZQuick = () => {}),
                        (this.addTree = () => {}),
                        (this.initialised = !1),
                        (this.initCounter = 0),
                        (this.ready = !1),
                        (this.renderWalls = !0),
                        (this.distantResolution = 20),
                        (this.fieldChance = 0),
                        (this.getXZ = e),
                        (this.getXZQuick = t),
                        (this.getTreeDensity = i),
                        (this.addTree = s),
                        (Io = At),
                        (So = 2 * Io * 3),
                        (this.renderWalls = n),
                        (this.geo = new No()),
                        (this.verts = this.geo.attributes.position.array),
                        (this.uvs = this.geo.attributes.uv.array),
                        (this.index = []),
                        (this.mesh = new r.B(this.geo, Co)),
                        (this.mesh.visible = !1),
                        (jo.na = new r.V()),
                        (jo.nb = new r.V()),
                        (jo.t = new r.V()),
                        (jo.ti = new r.V()),
                        (jo.nextVert = new r.V());
                }
                initialise(e, t = null, i = null, s = !1, n = !0) {
                    if (((this.originPos = e), (this.debug = s), t && i)) {
                        if (n) for (this.originNode = t, jo.midNodeIndex = (i.i - t.i) / 2, jo.i = 0; jo.i < jo.midNodeIndex && this.originNode.next; jo.i++) this.originNode = this.originNode.next;
                        (this.entryNode = t), (this.exitNode = i), (this.distantResolution = 10), (this.checkBothDirections = i.i - t.i > 0.15 * At || !n);
                    } else (this.originNode = null), (this.entryNode = null), (this.exitNode = null), (this.distantResolution = 20);
                    (this.wallMap.length = 0),
                        (this.fieldMap.length = 0),
                        (this.skippedNodes = []),
                        (this.wallsToDraw.length = 0),
                        (this.wallTileOffsets = []),
                        (this.wallOffsets = []),
                        (this.skippedFieldNodes = []),
                        (this.skippedFieldNodeIDs = []),
                        (this.skippedFieldNodeOffset = []),
                        (this.leftWallNodes.length = 0),
                        (this.rightWallNodes.length = 0),
                        (this.index.length = 0),
                        (this.curWallIndex = 0),
                        (this.curVertIndex = 0),
                        (this.curUVIndex = 0),
                        (this.curIndex = 0),
                        n && this.geo.setDrawRange(0, 0),
                        (this.fieldMapOffset.x = this.originPos.x % 1e3),
                        (this.fieldMapOffset.z = this.originPos.z % 1e3),
                        this.fieldMapOffset.x < 0 && (this.fieldMapOffset.x += 1e3),
                        this.fieldMapOffset.z < 0 && (this.fieldMapOffset.z += 1e3),
                        (this.initialised = !1),
                        (this.initCounter = 0),
                        (this.ready = !1);
                }
                continueInitialise() {
                    if (this.initCounter < yo.fields.length) {
                        if (
                            ((jo.fi = this.initCounter),
                            (jo.f = yo.fields[this.initCounter++]),
                            (jo.fX = jo.f.center[0] - this.fieldMapOffset.x),
                            (jo.fZ = jo.f.center[1] - this.fieldMapOffset.z),
                            (jo.tX = 0),
                            (jo.tZ = 0),
                            jo.fX < 0 && ((jo.fX += 1e3), (jo.tX = 1e3)),
                            jo.fZ < 0 && ((jo.fZ += 1e3), (jo.tZ = 1e3)),
                            (jo.tX -= this.fieldMapOffset.x),
                            (jo.tZ -= this.fieldMapOffset.z),
                            (jo.debug = this.debug && (24 == jo.fi || 25 == jo.fi)),
                            jo.fX < At && jo.fZ < At)
                        ) {
                            for (jo.fn of jo.f.nodes)
                                if (
                                    ((jo.fnn = yo.nodes[jo.fn]),
                                    (jo.fnX = jo.fnn[0] - this.fieldMapOffset.x),
                                    (jo.fnZ = jo.fnn[1] - this.fieldMapOffset.z),
                                    jo.fnX < 0 && (jo.fnX += 1e3),
                                    jo.fnZ < 0 && (jo.fnZ += 1e3),
                                    jo.fnX > At || jo.fnZ > At)
                                )
                                    return;
                            if (((jo.h = this.getXZQuick(jo.fX, jo.fZ)), jo.h > 10 && jo.h < 100 && 0 == this.getTreeDensity(jo.fX, jo.fZ)))
                                if (((jo.fX += this.originPos.x), (jo.fZ += this.originPos.z), this.originNode))
                                    if (
                                        (this.checkBothDirections
                                            ? ((jo.rd = Kt(jo.fX, jo.fZ, this.entryNode, !0, jo.debug)), (jo.rd2 = Kt(jo.fX, jo.fZ, this.exitNode, !0, jo.debug)), jo.rd.d2 > jo.rd2.d2 && (jo.rd = jo.rd2))
                                            : (jo.rd = Kt(jo.fX, jo.fZ, this.originNode, !0, jo.debug)),
                                        jo.rd.d2 > jo.f.radius2)
                                    )
                                        for (jo.w of jo.f.walls) this.wallMap[jo.w] || ((this.wallMap[jo.w] = !0), this.wallOffsets.push([jo.tX, jo.tZ]), this.wallsToDraw.push(yo.walls[jo.w]), (this.fieldMap[jo.fi] = !0));
                                    else for (jo.sni of jo.f.nodes) (this.skippedFieldNodes[jo.sni] = jo.rd.n), (this.skippedFieldNodeIDs[jo.sni] = !0), (this.skippedFieldNodeOffset[jo.sni] = [jo.tX, jo.tZ]);
                                else for (jo.w of jo.f.walls) this.wallMap[jo.w] || ((this.wallMap[jo.w] = !0), this.wallOffsets.push([jo.tX, jo.tZ]), this.wallsToDraw.push(yo.walls[jo.w]), (this.fieldMap[jo.fi] = !0));
                        }
                    } else {
                        for (jo.rightIndex = -1, jo.leftIndex = -1, jo.ni = 0; jo.ni < yo.nodes.length; jo.ni++)
                            if (this.skippedFieldNodeIDs[jo.ni])
                                for (jo.fi of yo.nodeToFields[jo.ni])
                                    if (this.fieldMap[jo.fi]) {
                                        if (
                                            ((jo.node = yo.nodes[jo.ni]),
                                            (jo.offset = this.skippedFieldNodeOffset[jo.ni]),
                                            (jo.rd = _t(jo.node[0] + jo.offset[0] + this.originPos.x, jo.node[1] + jo.offset[1] + this.originPos.z, this.skippedFieldNodes[jo.ni])),
                                            jo.rd.d > yo.fields[jo.fi].radius || (jo.rd.s < 0 && jo.rd.n.g < -1.5) || (jo.rd.s > 0 && jo.rd.n.g > 1.5))
                                        )
                                            break;
                                        if (((jo.doBreak = !1), jo.rd.s < 0)) {
                                            for (jo.rwn of this.rightWallNodes)
                                                if (1 == Math.abs(jo.rd.n.i - jo.rwn.i)) {
                                                    jo.doBreak = !0;
                                                    break;
                                                }
                                            if (jo.doBreak) break;
                                            this.rightWallNodes.push(jo.rd.n), (jo.rightIndex = this.wallsToDraw.length);
                                        } else {
                                            for (jo.lwn of this.leftWallNodes)
                                                if (1 == Math.abs(jo.rd.n.i - jo.lwn.i)) {
                                                    jo.doBreak = !0;
                                                    break;
                                                }
                                            if (jo.doBreak) break;
                                            this.leftWallNodes.push(jo.rd.n), (jo.leftIndex = this.wallsToDraw.length);
                                        }
                                        (jo.d = Do + 0.1),
                                            jo.na.set(jo.rd.n.p.x - jo.rd.n.n.x * jo.d * jo.rd.s, jo.rd.n.p.z - jo.rd.n.n.z * jo.d * jo.rd.s),
                                            this.wallsToDraw.push([jo.node[0], jo.node[1], jo.na.x - this.originPos.x - jo.offset[0], jo.na.y - this.originPos.z - jo.offset[1], jo.rd.n]),
                                            this.wallOffsets.push(jo.offset);
                                        break;
                                    }
                        1 == this.rightWallNodes.length && (this.wallsToDraw.splice(jo.rightIndex, 1), this.wallOffsets.splice(jo.rightIndex, 1), jo.rightIndex < jo.leftIndex && jo.leftIndex--),
                            1 == this.leftWallNodes.length && (this.wallsToDraw.splice(jo.leftIndex, 1), this.wallOffsets.splice(jo.leftIndex, 1)),
                            (this.initialised = !0),
                            (this.ready = this.curWallIndex >= this.wallsToDraw.length);
                    }
                }
                buildNextWall() {
                    if (this.initialised) {
                        if (this.curVertIndex >= So || this.curWallIndex >= this.wallsToDraw.length || !this.renderWalls) return (this.ready = !0), void this.finalise();
                        for (
                            jo.cwi = this.wallsToDraw.length - 1 - this.curWallIndex,
                                jo.nodes = this.wallsToDraw[jo.cwi],
                                jo.offset = this.wallOffsets[jo.cwi],
                                jo.na.set(jo.nodes[0], jo.nodes[1]),
                                jo.nb.set(jo.nodes[2], jo.nodes[3]),
                                jo.d = jo.na.distanceTo(jo.nb),
                                jo.t.subVectors(jo.nb, jo.na).normalize(),
                                jo.ti.set(-jo.t.y, jo.t.x),
                                jo.fieldToTile = { x: jo.offset[0], z: jo.offset[1] },
                                jo.fieldToWorld = { x: jo.fieldToTile.x + this.originPos.x, z: jo.fieldToTile.z + this.originPos.z },
                                jo.refreshIndex = !0,
                                jo.n = jo.nodes[4],
                                jo.nearWall = !!jo.n,
                                jo.distanceBetween = 0,
                                jo.minDist = jo.n ? 1 : 10,
                                jo.hOffset = this.originPos.y + 0.6,
                                jo.doBreak = !1;
                            ;

                        ) {
                            if (
                                (jo.d < jo.minDist ? (jo.na.copy(jo.nb), (jo.hOffset += 0.2), (jo.distanceBetween = jo.d), (jo.doBreak = !0)) : ((jo.na.x += jo.t.x * jo.distanceBetween), (jo.na.y += jo.t.y * jo.distanceBetween)),
                                jo.nextVert.copy(jo.na),
                                jo.nearWall && jo.d < 15
                                    ? ((jo.rd = _t(jo.nextVert.x + jo.fieldToWorld.x, jo.nextVert.y + jo.fieldToWorld.z, jo.n)),
                                      (jo.h = si.lerpHeightGlobal(jo.nextVert.x + jo.fieldToWorld.x, jo.nextVert.y + jo.fieldToWorld.z, jo.rd, this.getXZ)))
                                    : (jo.h = this.getXZQuick(jo.nextVert.x + jo.fieldToTile.x, jo.nextVert.y + jo.fieldToTile.z)),
                                (jo.nextVert.x += jo.fieldToTile.x),
                                (jo.nextVert.y += jo.fieldToTile.z),
                                (jo.byWater = jo.h < 5),
                                (jo.h -= jo.hOffset),
                                jo.nearWall && Ih.value.detailLodIndex > 0
                                    ? ((this.verts[this.curVertIndex++] = jo.nextVert.x + 0.2 * jo.ti.x),
                                      (this.verts[this.curVertIndex++] = jo.h),
                                      (this.verts[this.curVertIndex++] = jo.nextVert.y + 0.2 * jo.ti.y),
                                      (this.verts[this.curVertIndex++] = jo.nextVert.x + 0.1 * jo.ti.x),
                                      (this.verts[this.curVertIndex++] = jo.h + Mo),
                                      (this.verts[this.curVertIndex++] = jo.nextVert.y + 0.1 * jo.ti.y),
                                      (this.verts[this.curVertIndex++] = jo.nextVert.x - 0.1 * jo.ti.x),
                                      (this.verts[this.curVertIndex++] = jo.h + Mo),
                                      (this.verts[this.curVertIndex++] = jo.nextVert.y - 0.1 * jo.ti.y),
                                      (this.verts[this.curVertIndex++] = jo.nextVert.x - 0.2 * jo.ti.x),
                                      (this.verts[this.curVertIndex++] = jo.h),
                                      (this.verts[this.curVertIndex++] = jo.nextVert.y - 0.2 * jo.ti.y),
                                      (this.uvs[this.curUVIndex++] = 0),
                                      (this.uvs[this.curUVIndex++] = 0.46 * jo.d),
                                      (this.uvs[this.curUVIndex++] = 0.44),
                                      (this.uvs[this.curUVIndex++] = 0.46 * jo.d),
                                      (this.uvs[this.curUVIndex++] = 0.56),
                                      (this.uvs[this.curUVIndex++] = 0.46 * jo.d),
                                      (this.uvs[this.curUVIndex++] = 1),
                                      (this.uvs[this.curUVIndex++] = 0.46 * jo.d),
                                      jo.refreshIndex ||
                                          ((jo.ii = this.curIndex - 4),
                                          this.index.push(
                                              jo.ii,
                                              jo.ii + 5,
                                              jo.ii + 1,
                                              jo.ii,
                                              jo.ii + 4,
                                              jo.ii + 5,
                                              jo.ii + 1,
                                              jo.ii + 6,
                                              jo.ii + 2,
                                              jo.ii + 1,
                                              jo.ii + 5,
                                              jo.ii + 6,
                                              jo.ii + 2,
                                              jo.ii + 7,
                                              jo.ii + 3,
                                              jo.ii + 2,
                                              jo.ii + 6,
                                              jo.ii + 7
                                          )),
                                      (this.curIndex += 4),
                                      (jo.refreshIndex = !1))
                                    : jo.byWater
                                    ? (jo.refreshIndex = !0)
                                    : ((this.verts[this.curVertIndex++] = jo.nextVert.x),
                                      (this.verts[this.curVertIndex++] = jo.h),
                                      (this.verts[this.curVertIndex++] = jo.nextVert.y),
                                      (this.verts[this.curVertIndex++] = jo.nextVert.x),
                                      (this.verts[this.curVertIndex++] = jo.h + Mo),
                                      (this.verts[this.curVertIndex++] = jo.nextVert.y),
                                      (this.uvs[this.curUVIndex++] = 0),
                                      (this.uvs[this.curUVIndex++] = 0.46 * jo.d),
                                      (this.uvs[this.curUVIndex++] = 0.46),
                                      (this.uvs[this.curUVIndex++] = 0.46 * jo.d),
                                      jo.refreshIndex || ((jo.ii = this.curIndex - 2), this.index.push(jo.ii, jo.ii + 3, jo.ii + 1, jo.ii, jo.ii + 2, jo.ii + 3)),
                                      (this.curIndex += 2),
                                      (jo.refreshIndex = !1)),
                                jo.n
                                    ? ((jo.distanceBetween = Math.min(10, Math.max(2, jo.d / 2))), !jo.byWater && jo.d > 20 && ko.next() < 0.1 && this.addTree(jo.nextVert.x, jo.h, jo.nextVert.y))
                                    : ((jo.distanceBetween = this.distantResolution), !jo.byWater && ko.next() < 0.2 && this.addTree(jo.nextVert.x, jo.h, jo.nextVert.y)),
                                (jo.d -= jo.distanceBetween),
                                this.curVertIndex >= So)
                            ) {
                                this.curWallIndex = this.wallsToDraw.length;
                                break;
                            }
                            if (jo.doBreak) break;
                        }
                        this.curWallIndex++, (this.ready = this.curWallIndex >= this.wallsToDraw.length), this.ready && this.finalise();
                    } else this.continueInitialise();
                }
                finalise() {
                    if (this.leftWallNodes.length > 1)
                        for (this.leftWallNodes = this.leftWallNodes.sort((e, t) => (e.i < t.i ? -1 : 1)), jo.ci = 0; jo.ci < this.leftWallNodes.length - 1; jo.ci++) {
                            var e;
                            if (((jo.curNode = this.leftWallNodes[jo.ci]), (jo.target = this.leftWallNodes[jo.ci + 1]), jo.target.i - jo.curNode.i < 30))
                                for (; jo.curNode.i <= jo.target.i; ) (jo.curNode.dswl = Do), (jo.curNode = jo.curNode.next);
                            else (null === (e = jo.curNode.prev) || void 0 === e ? void 0 : e.dswl) || (jo.curNode.dsel = !0);
                        }
                    if (this.rightWallNodes.length > 1)
                        for (this.rightWallNodes = this.rightWallNodes.sort((e, t) => (e.i < t.i ? -1 : 1)), jo.ci = 0; jo.ci < this.rightWallNodes.length - 1; jo.ci++) {
                            var t;
                            if (((jo.curNode = this.rightWallNodes[jo.ci]), (jo.target = this.rightWallNodes[jo.ci + 1]), jo.target.i - jo.curNode.i < 30))
                                for (; jo.curNode.i <= jo.target.i; ) (jo.curNode.dswr = -Do), (jo.curNode = jo.curNode.next);
                            else (null === (t = jo.curNode.prev) || void 0 === t ? void 0 : t.dswr) || (jo.curNode.dser = !0);
                        }
                    (this.geo.attributes.position.needsUpdate = !0), (this.geo.attributes.uv.needsUpdate = !0), this.geo.setDrawRange(0, this.index.length), this.geo.setIndex(this.index), this.mesh.updateMatrix(), (this.mesh.visible = !0);
                }
            };
            const Oo = new r.G(),
                Lo = new Pn(103, 2 * Math.PI),
                Ro = new Pn(51, 0.4),
                To = { vecV: new r.W(), vecH: new r.W() };
            var Po = class extends ri {
                constructor(...e) {
                    super(...e),
                        (this.maxTreeCount = 5120),
                        (this.treeMapRows = []),
                        (this.treeInstanceIndex = 0),
                        (this.treeMap = []),
                        (this.currentTreeInstance = 0),
                        (this.treeInstances = []),
                        (this.farWallRenderer = null),
                        (this.ready = !1),
                        (this.isDebug = !1),
                        (this.treeGenIndex = 0),
                        (this.treeMapTile = null),
                        (this.nearestNode = null),
                        (this.sea = null),
                        (this.seaRes = 10),
                        (this.seaDepth = null),
                        (this.seaDepthIndex = 0),
                        (this.seaRow = 0),
                        (this.maxTreeCount = Ss),
                        this.treeInstances.push(_a.getFarTreeInstance(this.maxTreeCount)),
                        (this.trees = this.treeInstances[0]),
                        (this.trees.count = 0),
                        this.geo.setAttribute("treeMask", new r.o(new Float32Array(this.geo.count), 1)),
                        this.geo.attributes.treeMask.setUsage(r.l),
                        (this.treeMask = this.geo.attributes.treeMask.array),
                        this.geo.setAttribute("grass", new r.o(new Float32Array(this.geo.count), 1)),
                        this.geo.attributes.grass.setUsage(r.l),
                        (this.grassArr = this.geo.attributes.grass.array),
                        this.mesh.add(this.trees),
                        (this.renderFarWalls = Ih.value.detailLodIndex > 0),
                        (this.farWallRenderer = new zo(
                            (e, t) => this.heightmap.getXZ(e, t),
                            (e, t) => this.lookupHeight(e, t),
                            (e, t) => this.lookupTreemapDensity(e, t),
                            (e, t, i) => this.addWallTree(e, t, i),
                            this.renderFarWalls
                        )),
                        this.renderFarWalls && this.mesh.add(this.farWallRenderer.mesh);
                }
                initGeneration(e, t, i, s, n, a, o) {
                    super.initGeneration(e, t, i, s, n, a, o), (this.treeInstanceIndex = 0), (this.treeGenIndex = 0);
                    for (let r of this.treeInstances) (r.count = 0), (r.visible = !1);
                    (this.currentTreeInstance = 0),
                        (this.trees = this.treeInstances[this.currentTreeInstance]),
                        (this.trees.visible = !0),
                        co[e] || (co[e] = {}),
                        (co[e][t] = null),
                        Bs
                            ? (this.sea || ((this.sea = this.getSeaMesh()), this.mesh.add(this.sea)),
                              (this.seaDepth = this.sea.geometry.attributes.depth.array),
                              (this.seaDepthIndex = 0),
                              (this.seaRow = 0),
                              (this.sea.visible = !0),
                              (this.sea.position.y = -this.mesh.position.y))
                            : (this.sea && (this.sea.visible = !1), (this.seaRow = Ws + 1)),
                        this.farWallRenderer.initialise(this.originPos, i, s, this.debug),
                        (e + t) % 3 == 0 && (this.farWallRenderer.ready = !0);
                }
                resetOverlapMap(e, t) {
                    super.resetOverlapMap(e, t),
                        (this.treeInstanceIndex = 0),
                        (this.treeGenIndex = 0),
                        (this.currentTreeInstance = 0),
                        (this.trees = this.treeInstances[this.currentTreeInstance]),
                        (this.trees.visible = !0),
                        this.farWallRenderer.initialise(this.originPos, this.originNode, e, this.debug, !1),
                        (this.originCoords.x + this.originCoords.z) % 3 == 0 && (this.farWallRenderer.ready = !0);
                }
                getSeaMesh() {
                    let e = new r.J(this.size, this.size, Ws, Ws);
                    e.setAttribute("depth", new r.o(new Float32Array((Ws + 1) * (Ws + 1)), 1)), e.attributes.depth.setUsage(r.l);
                    let t = new r.B(e, Gs);
                    return (t.position.x += this.size / 2), (t.position.z += this.size / 2), (t.rotation.x = -Math.PI / 2), t;
                }
                generate() {
                    if (this.genRow <= this.res) {
                        for (this.genIndex = this.genRow * this.res1 * 3, To.i = 0; To.i <= this.res; To.i++)
                            (To.index = this.genIndex + 3 * To.i),
                                (To.index3 = this.genRow * this.res1 + To.i),
                                (To.x = this.verts[To.index] + this.originPos.x),
                                (To.z = this.verts[To.index + 2] + this.originPos.z),
                                (To.h = this.heightmap.getXZ(To.x, To.z)),
                                (this.heights[To.index3] = To.h),
                                (this.heightOffsets[To.index3] = To.h - this.mesh.position.y),
                                (this.treeMask[To.index3] = 0),
                                (this.treeMap[To.index3] = _a.treeMap.getXZ(To.x, To.z)),
                                To.h < 100 ? (this.grassArr[To.index3] = (_a.grassMap.getXZ(To.x, To.z) / 3) * (To.h / 100)) : (this.grassArr[To.index3] = _a.grassMap.getXZ(To.x, To.z) / 3);
                        return (
                            this.genRow > 0 && this.computeSquareNormalsRow(this.genRow - 1),
                            this.genRow++,
                            this.genRow > this.res &&
                                (this.computeSquareNormalsRow(this.genRow - 1), (this.geo.attributes.normal.needsUpdate = !0), (this.geo.attributes.curvature.needsUpdate = !0), (this.geo.attributes.grass.needsUpdate = !0)),
                            !1
                        );
                    }
                    if (this.overlapIndex < this.overlapCells.length) {
                        for (To.oz in ((To.ox = this.overlapCells[this.overlapIndex]), this.overlapTile[To.ox]))
                            this.overlapTile[To.ox][To.oz] < 0 || ((To.index = To.ox * this.res1 + 1 * To.oz), (this.heightOffsets[To.index] = this.heights[To.index] - this.mesh.position.y - (6 + 2.5 * this.overlapTile[To.ox][To.oz])));
                        return this.overlapIndex++, !1;
                    }
                    if (this.treeGenIndex < this.res) return this.computeTreeRow(this.treeGenIndex), this.treeGenIndex++, !1;
                    if (!this.farWallRenderer.ready) return this.farWallRenderer.buildNextWall(), !1;
                    if (this.seaRow <= Ws) {
                        for (To.genIndex = this.seaRow * (Ws + 1), To.i = 0; To.i <= Ws; To.i++) this.seaDepth[To.genIndex + To.i] = this.lookupHeight((To.i / Ws) * this.size, (this.seaRow / Ws) * this.size);
                        return this.seaRow++, !1;
                    }
                    return (
                        this.readyTrees(),
                        (this.geo.attributes.treeMask.needsUpdate = !0),
                        Bs && (this.sea.geometry.attributes.depth.needsUpdate = !0),
                        (co[this.originCoords.x][this.originCoords.z] = this.treeMask),
                        this.mesh.visible && this.display(),
                        (this.ready = !0),
                        !0
                    );
                }
                lookupTreemapDensity(e, t) {
                    return e < 0 || e > this.size || t < 0 || t > this.size
                        ? 0
                        : ((To.cx = Math.max(e / 10, 0)),
                          (To.cz = Math.max(t / 10, 0)),
                          (To.ix = Math.min(this.size - 1, Math.floor(To.cx))),
                          (To.iz = Math.min(this.size - 1, Math.floor(To.cz))),
                          (To.index = this.res1 * To.ix + To.iz),
                          this.treeMask[To.index]);
                }
                addWallTree(e, t, i) {
                    Oo.position.set(e, t - 1, i),
                        (Oo.rotation.y = Lo.next()),
                        Oo.scale.set(0.75, 0.75, 0.75),
                        Oo.updateMatrix(),
                        this.trees.setMatrixAt(this.treeInstanceIndex, Oo.matrix),
                        (this.trees.instanceVariant.array[this.treeInstanceIndex] = 0),
                        Oo.rotation.y > 2.1 && (Oo.rotation.y > 4.2 ? (this.trees.instanceVariant.array[this.treeInstanceIndex] = 2) : (this.trees.instanceVariant.array[this.treeInstanceIndex] = 3)),
                        this.treeInstanceIndex++,
                        this.treeInstanceIndex >= this.maxTreeCount && this.getNewTreeInstance();
                }
                readyTrees() {
                    (this.trees.instanceMatrix.needsUpdate = !0), (this.trees.instanceVariant.needsUpdate = !0), (this.trees.count = Math.min(this.maxTreeCount, Math.max(0, this.treeInstanceIndex)));
                }
                getNewTreeInstance() {
                    if ((this.readyTrees(), this.currentTreeInstance++, this.treeInstances.length <= this.currentTreeInstance)) {
                        let e = _a.getFarTreeInstance(this.maxTreeCount);
                        this.mesh.add(e), this.treeInstances.push(e);
                    }
                    (this.trees = this.treeInstances[this.currentTreeInstance]), (this.trees.count = 0), (this.trees.visible = !0), (this.treeInstanceIndex = 0);
                }
                computeTreeRow(e) {
                    for (To.i = 0; To.i < this.res; To.i++)
                        if (
                            (this.treeInstanceIndex >= this.maxTreeCount && this.getNewTreeInstance(),
                            (To.index = e * this.res1 * 3 + 3 * To.i),
                            (To.index3 = e * this.res1 + To.i),
                            (To.tm = this.treeMap[To.index3]),
                            0 != To.tm &&
                                ((To.doContinue = !1),
                                this.heights[To.index3] < 0 && ((this.treeMask[To.index3] = 0), (To.doContinue = !0)),
                                this.heights[To.index3 + 1] < 0 && ((this.treeMask[To.index3 + 1] = 0), (To.doContinue = !0)),
                                this.heights[To.index3 + this.res1] < 0 && ((this.treeMask[To.index3 + this.res1] = 0), (To.doContinue = !0)),
                                this.heights[To.index3 + 1 + this.res1] < 0 && ((this.treeMask[To.index3 + 1 + this.res1] = 0), (To.doContinue = !0)),
                                !To.doContinue))
                        )
                            if (this.grads[To.index] > 0.2) (this.treeMask[To.index3] = 0), (this.treeMask[To.index3 + 1] = 0), (this.treeMask[To.index3 + this.res1] = 0), (this.treeMask[To.index3 + 1 + this.res1] = 0);
                            else {
                                (To.tx = e), (To.tz = To.i), (To.jInit = 0), this.overlapTile && To.tx + 1 in this.overlapTile && To.tz + 1 in this.overlapTile[To.tx + 1] && (To.jInit = 100), (To.treePositions = _a.getTreeMap(To.tm));
                                for (To.j = To.jInit; To.j < To.treePositions.length; To.j += 2)
                                    (To.ox = To.treePositions[To.j]),
                                        (To.oz = To.treePositions[To.j + 1]),
                                        (To.ha = To.ox * this.heightOffsets[To.index3 + this.res1] + (1 - To.ox) * this.heightOffsets[To.index3]),
                                        (To.hb = To.ox * this.heightOffsets[To.index3 + 1 + this.res1] + (1 - To.ox) * this.heightOffsets[To.index3 + 1]),
                                        Oo.position.set(10 * To.ox + 10 * To.tx, To.oz * To.hb + (1 - To.oz) * To.ha, 10 * To.oz + 10 * To.tz),
                                        (Oo.rotation.y = Lo.next()),
                                        (To.tms = 0.15 * (To.tm - 1) + 1),
                                        (To.hb = To.tms + (Ro.next() - 0.2) * To.tms),
                                        Oo.scale.set(To.hb, To.hb, To.hb),
                                        Oo.updateMatrix(),
                                        this.trees.setMatrixAt(this.treeInstanceIndex, Oo.matrix),
                                        (this.trees.instanceVariant.array[this.treeInstanceIndex] = 0),
                                        Oo.rotation.y > 2.1 && (Oo.rotation.y > 4.2 ? (this.trees.instanceVariant.array[this.treeInstanceIndex] = 2) : (this.trees.instanceVariant.array[this.treeInstanceIndex] = 3)),
                                        this.treeInstanceIndex++,
                                        this.treeInstanceIndex >= this.maxTreeCount && this.getNewTreeInstance();
                                (To.hb = To.tm / 3),
                                    (this.treeMask[To.index3] = Math.max(To.hb, this.treeMask[To.index3])),
                                    (this.treeMask[To.index3 + 1] = Math.max(To.hb, this.treeMask[To.index3 + 1])),
                                    (this.treeMask[To.index3 + this.res1] = Math.max(To.hb, this.treeMask[To.index3 + this.res1])),
                                    (this.treeMask[To.index3 + 1 + this.res1] = Math.max(To.hb, this.treeMask[To.index3 + 1 + this.res1]));
                            }
                }
                display(e = !1) {
                    super.display(e);
                    for (let t of this.treeInstances) t.visible && (t.geometry.boundingSphere = this.geo.boundingSphere.clone());
                    (this.farWallRenderer.geo.boundingSphere = this.geo.boundingSphere.clone()), this.sea && (this.sea.geometry.boundingSphere = { center: { x: 0, y: 0, z: 0 }, radius: this.geo.boundingSphere.radius });
                }
                retire() {
                    super.retire(), this.resetTrees(), delete co[this.originCoords.x][this.originCoords.z], Object.keys(co[this.originCoords.x]).length || delete co[this.originCoords.x];
                }
                resetTrees() {
                    for (; this.treeInstances.length > 1; ) _a.returnFarTreeInstance(this.treeInstances.pop());
                    this.treeInstances[0].visible = !1;
                }
            };
            class Go extends hi {
                constructor(e) {
                    super(),
                        (this.nearGridCell = bo),
                        (this.farGridCell = Po),
                        (this.groundMaterial = ys),
                        (this.skinList = Object.keys(Fs.skins)),
                        (this.skinIndex = 0),
                        (this.weatherList = Object.keys(Fs.weathers)),
                        (this.curWeatherIndex = 0),
                        (this.skinWeatherList = []),
                        (this.weatherOverride = !1),
                        (this.cycleWeathers = !1),
                        (this.weatherCycles = []),
                        (this.weatherCycleIndex = 0),
                        (this.weatherCycleCurrentIndex = 0),
                        (this.weatherCycleInterval = 0),
                        (this.weatherCycleCounter = 0),
                        (this.colorsA = { col: new r.i(), hemTop: new r.i(), hemGround: new r.i(), water: new r.i(), waterSkyReflection: new r.i(), underwater: new r.i(), skyCol: new r.i(), skyColFar: new r.i() }),
                        (this.colorsB = { col: new r.i(), hemTop: new r.i(), hemGround: new r.i(), water: new r.i(), waterSkyReflection: new r.i(), underwater: new r.i(), skyCol: new r.i(), skyColFar: new r.i() }),
                        (this.weatherBlend = {
                            amb: 0,
                            dir: 0,
                            hem: 0,
                            fogNear: 0,
                            fogFar: 0,
                            col: new r.i(),
                            hemTop: new r.i(),
                            hemGround: new r.i(),
                            water: new r.i(),
                            waterSkyReflection: new r.i(),
                            underwater: new r.i(),
                            skyCol: new r.i(),
                            skyColFar: new r.i(),
                        }),
                        (this.topoList = Object.keys(Fs.topography)),
                        (this.topoIndex = 0),
                        (this.ambiantAudio = null),
                        (this.windAudio = null),
                        (this.cachedTextures = { default: {} }),
                        (this.onWeatherCycleChangedBound = this.onWeatherCycleChanged.bind(this)),
                        (this.loadState = { init: !1, walls: !1, reset: !0, progress: 0 }),
                        (this.lastVehicleIndex = 0),
                        (this.seaDepth = null),
                        (this.fogHeight = 0),
                        (this.dynamicFog = !1),
                        (this.fogUpdate = !1),
                        (this.inWater = !1),
                        (this.lerpOffset = 0),
                        (this.lerpCounter = 0),
                        (this.timeInterval = 1),
                        (this.weatherType = 0),
                        (this.curWeatherIndex = 0),
                        (this.audioLerp = 0),
                        (this.tCol = new r.i()),
                        (this.getHeightAt = e),
                        (this.container = new r.G()),
                        (this.config = Fs),
                        Xn.initialise(e),
                        this.container.add(Xn.container),
                        (this.wallController = new Oa(this.getHeightAt)),
                        this.container.add(this.wallController.container),
                        (this.signController = new Ra()),
                        (this.bridgeController = new Ba(this.getHeightAt)),
                        (this.catsEyesController = new Za()),
                        this.container.add(this.catsEyesController.container),
                        (this.weatherController = new Ya()),
                        this.container.add(this.weatherController.container),
                        this.container.add(ao.container),
                        Ih.value.detailLodIndex > 0 && (this.container.add(ro.container), this.container.add(lo.container)),
                        _a.buildMap(Fs.treemap),
                        ao.reset(),
                        ro.reset(),
                        lo.reset(),
                        fe.addListener(xe, this.onHeadlightsChanged.bind(this)),
                        Vs.addListener(this.onWeatherCycleChangedBound),
                        this.onWeatherCycleChanged();
                }
                onWeatherCycleChanged(e) {
                    var t;
                    if (0 == Vs.cycleLength || !(null === (t = this.skin) || void 0 === t ? void 0 : t.cycles)) return (this.cycleWeathers = !1), void this.weatherController.onWeatherCycleChanged(!1);
                    for (
                        this.cycleWeathers || (this.weatherCycleIndex = 0), this.cycleWeathers = !0, this.weatherController.onWeatherCycleChanged(!0), this.weatherCycles = this.skin.cycles, this.weatherCycleIndex = 0;
                        this.weatherCycleIndex < this.weatherCycles.length &&
                        ((this.weatherCycleCurrentList = this.weatherCycles[this.weatherCycleIndex]),
                        (this.weatherCycleCurrentIndex = this.weatherCycleCurrentList.indexOf(this.skinWeatherList[this.curWeatherIndex])),
                        !(this.weatherCycleCurrentIndex >= 0));
                        this.weatherCycleIndex++
                    );
                    this.weatherCycleCurrentIndex < 0 && (this.weatherCycleCurrentIndex = 0), (this.weatherCycleInterval = Vs.cycleLength / this.weatherCycleCurrentList.length), (this.weatherCycleCounter = 0), this.prepWeatherBlend();
                }
                updateConfig(e, t) {
                    As(e, t);
                }
                sanitiseConfig(e, t = !1) {
                    (!t && this.skinList.includes(e.value.skin)) || (e.set("skin", "default", !0), e.set("weatherIndex", 1, !0));
                }
                destroy() {
                    Xn.destroy(),
                        this.weatherController.destroy(),
                        this.ambientAudio.stop(),
                        this.windAudio.stop(),
                        this.container.traverse((e) => {
                            e.geometry && e.geometry.dispose();
                        }),
                        this.container.clear();
                    for (let e in this.cachedTextures)
                        for (let t in this.cachedTextures[e])
                            if (this.cachedTextures[e][t].isTexture) this.cachedTextures[e][t].dispose();
                            else for (let i in this.cachedTextures[e][t]) this.cachedTextures[e][t][i].isTexture && this.cachedTextures[e][t][i].dispose();
                    delete this.cachedTextures, ao.destroy(), ro.destroy(), lo.destroy();
                }
                loader() {
                    return 1;
                }
                initialise(e, t, i) {
                    this.seed = e;
                    let s = t.topography;
                    (this.topoIndex = this.topoList.indexOf(s)), delete this.heightmap, (this.heightmap = new gi(e, Fs.topography[s].heightmap)), xt(Fs.topography[s].smoothWindow), Zt(Fs.topography[s].roadWidth), Bs || this.initSea(), i();
                }
                onMidlineReady() {
                    (this.lastVehicleIndex = $t.vehicleIndex),
                        this.signController.initialise(),
                        this.bridgeController.initialise(),
                        this.catsEyesController.initialise(),
                        ao.revert(Ds, Cs),
                        ro.revert(Rs, Ns),
                        lo.revert(Ts, Ns),
                        this.sea && ((this.sea.position.x = $t.vehicleNode.p.x), (this.sea.position.z = $t.vehicleNode.p.z));
                }
                onGridReady() {
                    this.wallController.initialise(), lo.initialiseVisible(), ro.initialiseVisible(), ao.initialiseVisible();
                }
                handleMidlineReset() {
                    this.wallController.handleMidlineReset();
                }
                initSea() {
                    let e = 2 * Mt,
                        t = new r.J(e, e, Ws, Ws);
                    (this.sea = new r.B(t, Gs)), (this.sea.rotation.x = -Math.PI / 2), (this.sea.frustumCulled = !1), this.container.add(this.sea);
                }
                destroySea() {
                    this.sea && (this.sea.geometry.dispose(), this.container.remove(this.sea), (this.sea = null));
                }
                update(e) {
                    var t;
                    this.weatherController.update(),
                        this.lastVehicleIndex < $t.vehicleIndex &&
                            (this.lastVehicleIndex++,
                            this.wallController.update(),
                            this.signController.update(),
                            this.bridgeController.update(),
                            Xn.update(),
                            ro.updateVisible(),
                            lo.updateVisible(),
                            ao.updateVisible(),
                            this.sea && ((this.sea.position.x = $t.vehicleNode.p.x), (this.sea.position.z = $t.vehicleNode.p.z))),
                        this.catsEyesController.update(),
                        this.wallController.updateStaged(),
                        (null === (t = Hs.parent) || void 0 === t ? void 0 : t.position)
                            ? (Gs.userData.camPos.value.copy(Hs.parent.position), Xt.userData.camPos.value.copy(Hs.parent.position))
                            : (Gs.userData.camPos.value.copy(Hs.position), Xt.userData.camPos.value.copy(Hs.position)),
                        (Gs.userData.time.value = 2 * oe.appTime),
                        (Gs.uniformsNeedUpdate = !0),
                        this.cycleWeathers
                            ? this.updateWeather(e)
                            : this.dynamicFog &&
                              this.fogUpdate &&
                              ((this.dynamicFogNear = 1 - Math.min(1, fe.position.y / 200)),
                              (this.dynamicFogFar = 0.2 + 0.8 * this.dynamicFogNear),
                              lt(this.weather.col, St * this.weather.fogNear * this.dynamicFogNear, Math.max(50, St * this.weather.fogFar * this.dynamicFogFar))),
                        (this.fogUpdate = !this.fogUpdate),
                        Hs.position.y < 0
                            ? ((this.inWater = !0),
                              (this.underwaterCol = this.weather.underwater),
                              this.cycleWeathers && (this.underwaterCol = this.weatherBlend.underwater.getHex()),
                              bt.setHex(this.underwaterCol),
                              (this.fogVis = 2 * Math.max(0, 8 + Hs.position.y)),
                              lt(this.underwaterCol, -30 + this.fogVis, 10 + this.fogVis))
                            : this.inWater &&
                              ((this.inWater = !1),
                              this.cycleWeathers ||
                                  (bt.setHex(this.weather.col),
                                  this.cycleWeathers
                                      ? this.updateWeather(e)
                                      : this.dynamicFog && this.fogUpdate
                                      ? ((this.dynamicFogNear = 1 - Math.min(1, fe.position.y / 200)),
                                        (this.dynamicFogFar = 0.2 + 0.8 * this.dynamicFogNear),
                                        lt(this.weather.col, St * this.weather.fogNear * this.dynamicFogNear, Math.max(50, St * this.weather.fogFar * this.dynamicFogFar)))
                                      : lt(this.weather.col, St * this.weather.fogNear, St * this.weather.fogFar)));
                }
                smoothLerp(e) {
                    return -1 * (3 - 2 * e) * e * e + 1;
                }
                smootherLerp(e) {
                    return (e * (6 * e - 15) + 10) * e * e * e * -1 + 1;
                }
                prepWeatherBlend() {
                    this.weatherCycleCurrentIndex >= this.weatherCycleCurrentList.length &&
                        ((this.weatherCycleIndex = (this.weatherCycleIndex + 1) % this.weatherCycles.length), (this.weatherCycleCurrentList = this.weatherCycles[this.weatherCycleIndex]), (this.weatherCycleCurrentIndex = 0)),
                        (this.wA = Fs.weathers[this.weatherCycleCurrentList[this.weatherCycleCurrentIndex]]),
                        this.weatherCycleCurrentIndex == this.weatherCycleCurrentList.length - 1
                            ? (this.wB = Fs.weathers[this.weatherCycles[(this.weatherCycleIndex + 1) % this.weatherCycles.length][0]])
                            : (this.wB = Fs.weathers[this.weatherCycleCurrentList[this.weatherCycleCurrentIndex + 1]]),
                        this.colorsA.col.setHex(this.wA.col),
                        this.colorsA.hemTop.setHex(this.wA.hemTop),
                        this.colorsA.hemGround.setHex(this.wA.hemGround),
                        this.colorsA.water.setHex(this.wA.water),
                        this.colorsA.waterSkyReflection.setHex(this.wA.waterSkyReflection),
                        this.colorsA.underwater.setHex(this.wA.underwater),
                        this.colorsA.skyCol.setHex(this.wA.skyCol),
                        this.colorsA.skyColFar.setHex(this.wA.skyColFar),
                        this.colorsB.col.setHex(this.wB.col),
                        this.colorsB.hemTop.setHex(this.wB.hemTop),
                        this.colorsB.hemGround.setHex(this.wB.hemGround),
                        this.colorsB.water.setHex(this.wB.water),
                        this.colorsB.waterSkyReflection.setHex(this.wB.waterSkyReflection),
                        this.colorsB.underwater.setHex(this.wB.underwater),
                        this.colorsB.skyCol.setHex(this.wB.skyCol),
                        this.colorsB.skyColFar.setHex(this.wB.skyColFar);
                }
                updateWeather(e) {
                    (this.weatherCycleCounter += e),
                        this.weatherCycleCounter > this.weatherCycleInterval && ((this.weatherCycleCounter -= this.weatherCycleInterval), this.weatherCycleCurrentIndex++, this.prepWeatherBlend(this.wA, this.wB));
                    let t = this.weatherCycleCounter / this.weatherCycleInterval;
                    t = this.smoothLerp(1 - t);
                    let i = 1 - t;
                    (this.weatherBlend.amb = this.wA.amb * i + this.wB.amb * t),
                        (this.weatherBlend.dir = this.wA.dir * i + this.wB.dir * t),
                        (this.weatherBlend.hem = this.wA.hem * i + this.wB.hem * t),
                        (this.weatherBlend.fogNear = this.wA.fogNear * i + this.wB.fogNear * t),
                        (this.weatherBlend.fogFar = this.wA.fogFar * i + this.wB.fogFar * t),
                        this.weatherBlend.col.copy(this.colorsA.col).lerp(this.colorsB.col, t),
                        this.weatherBlend.hemTop.copy(this.colorsA.hemTop).lerp(this.colorsB.hemTop, t),
                        this.weatherBlend.hemGround.copy(this.colorsA.hemGround).lerp(this.colorsB.hemGround, t),
                        this.weatherBlend.water.copy(this.colorsA.water).lerp(this.colorsB.water, t),
                        this.weatherBlend.waterSkyReflection.copy(this.colorsA.waterSkyReflection).lerp(this.colorsB.waterSkyReflection, t),
                        this.weatherBlend.underwater.copy(this.colorsA.underwater).lerp(this.colorsB.underwater, t),
                        this.weatherBlend.skyCol.copy(this.colorsA.skyCol).lerp(this.colorsB.skyCol, t),
                        this.weatherBlend.skyColFar.copy(this.colorsA.skyColFar).lerp(this.colorsB.skyColFar, t),
                        (vt.intensity = this.weatherBlend.amb),
                        vt.color.copy(this.weatherBlend.col),
                        Co.emissive.copy(vt.color),
                        (ft.intensity = this.weatherBlend.hem),
                        ft.color.copy(this.weatherBlend.hemTop),
                        ft.groundColor.copy(this.weatherBlend.hemGround),
                        (wt.intensity = this.weatherBlend.dir),
                        wt.color.copy(this.weatherBlend.col),
                        wt.sunOffset.fromArray([0, 100, 0]),
                        bt.copy(this.weatherBlend.col),
                        fe.headlightsManual || (this.wA.headlights && !this.wB.headlights ? fe.setHeadlights(t < 0.5) : !this.wA.headlights && this.wB.headlights && fe.setHeadlights(t > 0.5)),
                        fe.headlights && this.updateHeadlightIntensity(),
                        this.wA.dynamicFog || this.wB.dynamicFog
                            ? ((this.vehicleFogLerp = Math.min(1, fe.position.y / 200)),
                              this.wA.dynamicFog && !this.wB.dynamicFog
                                  ? (this.dynamicFogNear = 1 - this.vehicleFogLerp * i)
                                  : this.wB.dynamicFog && !this.wA.dynamicFog
                                  ? (this.dynamicFogNear = 1 - this.vehicleFogLerp * t)
                                  : (this.dynamicFogNear = 1 - this.vehicleFogLerp),
                              (this.dynamicFogFar = 0.2 + 0.8 * this.dynamicFogNear),
                              lt(this.weatherBlend.col.getHex(), St * this.weatherBlend.fogNear * this.dynamicFogNear, Math.max(50, St * this.weatherBlend.fogFar * this.dynamicFogFar)))
                            : lt(this.weatherBlend.col.getHex(), St * this.weatherBlend.fogNear, St * this.weatherBlend.fogFar),
                        (Xt.userData.hasClouds.value = !1),
                        Xt.userData.nearCol.value.copy(this.weatherBlend.skyCol),
                        Xt.userData.farCol.value.copy(this.weatherBlend.skyColFar),
                        (Xt.uniformsNeedUpdate = !0),
                        Gs.color.copy(this.weatherBlend.water),
                        (Gs.userData.sunCol.value = this.hexToArray(this.weatherBlend.col.getHex())),
                        (Gs.userData.skyCol.value = this.hexToArray(this.weatherBlend.waterSkyReflection.getHex())),
                        (Gs.uniformsNeedUpdate = !0);
                }
                updateHeadlightIntensity() {
                    fe.setHeadlightIntensity(Math.max(0.25, 3.25 - 2.5 * (wt.intensity + ft.intensity)));
                }
                onHeadlightsChanged() {
                    this.catsEyesController.container.visible = fe.headlights;
                }
                nextSkin() {
                    this.setSkin(this.skinList[++this.skinIndex % this.skinList.length]), this.onWeatherCycleChanged(Vs.value);
                }
                setTopography(e) {
                    window.localStorage.setItem("config-scene-topography", e);
                }
                nextTopography() {
                    this.setTopography(this.topoList[++this.topoIndex % this.topoList.length]);
                }
                loadGroundMaterialSkin(e, t, i, s, n = 4) {
                    this.skin[e] ? (i[e] || (i[e] = et(this.skin[e], n)), (ys.userData[t].value = i[e])) : (s[e] || (s[e] = et(Fs.skins.default[e], n)), (ys.userData[t].value = s[e]));
                }
                getSkinName(e) {
                    var t;
                    return (null === (t = Fs.skins[e]) || void 0 === t ? void 0 : t.name) || e;
                }
                setScene(e) {
                    this.setSkin(e.skin), this.setWeatherIndex(e.weatherIndex % this.skinWeatherList.length), this.onWeatherCycleChanged(Vs.value);
                }
                setSkin(e) {
                    this.skinName = e;
                    let t = Fs.skins.default;
                    (this.skin = Fs.skins[e]), this.cachedTextures[e] || (this.cachedTextures[e] = {});
                    let i = this.cachedTextures[e],
                        s = this.cachedTextures.default;
                    this.loadGroundMaterialSkin("grass", "grassMap", i, s, 2),
                        this.loadGroundMaterialSkin("forest", "forestMap", i, s),
                        this.loadGroundMaterialSkin("heather", "heatherMap", i, s),
                        this.loadGroundMaterialSkin("gravel", "gravelMap", i, s),
                        this.loadGroundMaterialSkin("rock", "rockMap", i, s),
                        this.loadGroundMaterialSkin("sand", "sandMap", i, s),
                        this.loadGroundMaterialSkin("roadBase", "roadBaseMap", i, s),
                        this.skin.road ? (i.road || (i.road = et(this.skin.road, 8)), (Qt.map = i.road)) : (s.road || (s.road = et(t.road, 8)), (Qt.map = s.road)),
                        (ys.userData.colouration.value = t.foliage.grassColouration),
                        (Ps[0].userData.colouration.value = t.foliage.grassColouration),
                        (Ps[1].userData.colouration.value = t.foliage.grassColouration),
                        (Os[0].userData.colouration.value = t.foliage.treeColouration),
                        (Os[1].userData.colouration.value = t.foliage.treeColouration),
                        this.skin.foliage &&
                            (this.skin.foliage.trees
                                ? (i.foliage || (i.foliage = {}),
                                  i.foliage.trees || (i.foliage.trees = [et(this.skin.foliage.trees[0], 4), et(this.skin.foliage.trees[1], 4)]),
                                  (Os[0].map = i.foliage.trees[0]),
                                  (Os[1].map = i.foliage.trees[1]),
                                  this.skin.foliage.treesb && Ih.value.detailLodIndex > 0
                                      ? (i.foliage.treesb || (i.foliage.treesb = [et(this.skin.foliage.treesb[0], 4), et(this.skin.foliage.treesb[1], 4)]),
                                        (Os[0].userData.mapb.value = i.foliage.treesb[0]),
                                        (Os[1].userData.mapb.value = i.foliage.treesb[1]),
                                        (Os[0].userData.highDef.value = !0),
                                        (Os[1].userData.highDef.value = !0))
                                      : ((Os[0].userData.mapb.value = null), (Os[1].userData.mapb.value = null), (Os[0].userData.highDef.value = !1), (Os[1].userData.highDef.value = !1)))
                                : (s.foliage || (s.foliage = {}), s.foliage.trees || (s.foliage.trees = [et(t.foliage.trees[0], 4), et(t.foliage.trees[1], 4)]), (Os[0].map = s.foliage.trees[0]), (Os[1].map = s.foliage.trees[1])),
                            "grass" in this.skin.foliage
                                ? (i.foliage || (i.foliage = {}), i.foliage.grass || (i.foliage.grass = et(this.skin.foliage.grass, 4)), (Ps[0].map = i.foliage.grass))
                                : (s.foliage || (s.foliage = {}), s.foliage.grass || (s.foliage.grass = et(t.foliage.grass, 4)), (Ps[0].map = s.foliage.grass)),
                            "bush" in this.skin.foliage
                                ? (i.foliage || (i.foliage = {}), i.foliage.bush || (i.foliage.bush = et(this.skin.foliage.bush, 4)), (Ps[1].map = i.foliage.bush))
                                : (s.foliage || (s.foliage = {}), s.foliage.bush || (s.foliage.bush = et(t.foliage.bush, 4)), (Ps[1].map = s.foliage.bush)),
                            this.skin.foliage.grassColouration &&
                                ((ys.userData.colouration.value = this.skin.foliage.grassColouration),
                                (Ps[0].userData.colouration.value = this.skin.foliage.grassColouration),
                                (Ps[1].userData.colouration.value = this.skin.foliage.grassColouration)),
                            this.skin.foliage.treeColouration && ((Os[0].userData.colouration.value = this.skin.foliage.treeColouration), (Os[1].userData.colouration.value = this.skin.foliage.treeColouration))),
                        (ys.uniformsNeedUpdate = !0),
                        (Ps[0].uniformsNeedUpdate = !0),
                        (Ps[1].uniformsNeedUpdate = !0),
                        (Os[0].uniformsNeedUpdate = !0),
                        (Os[1].uniformsNeedUpdate = !0),
                        this.skin.walls
                            ? (i.walls || (i.walls = {}),
                              s.walls || (s.walls = {}),
                              (ka.visible = !0),
                              "sea" in this.skin.walls
                                  ? (null == this.skin.walls.sea && (ka.visible = !1), i.walls.sea || (i.walls.sea = et(this.skin.walls.sea, 4)), (ka.map = i.walls.sea))
                                  : (s.walls.sea || (s.walls.sea = et(t.walls.sea, 4)), (ka.map = s.walls.sea)),
                              (Ia.visible = !0),
                              this.skin.walls.sea ? (i.walls.sea || (i.walls.sea = et(this.skin.walls.sea, 4)), (Ia.map = i.walls.sea)) : (s.walls.sea || (s.walls.sea = et(t.walls.sea, 4)), (Ia.map = s.walls.sea)),
                              (Zn.visible = !0),
                              "drystone" in this.skin.walls
                                  ? (null == this.skin.walls.drystone && (Zn.visible = !1), i.walls.drystone || (i.walls.drystone = et(this.skin.walls.drystone, 4)), (Zn.map = i.walls.drystone))
                                  : (s.walls.drystone || (s.walls.drystone = et(t.walls.drystone, 4)), (Zn.map = s.walls.drystone)),
                              "fence" in this.skin.walls ? (i.walls.fence || (i.walls.fence = et(this.skin.walls.fence, 4)), (xa.map = i.walls.fence)) : (s.walls.fence || (s.walls.drystone = et(t.walls.fence, 4)), (xa.map = s.walls.fence)))
                            : (s.walls || (s.walls = {}),
                              s.walls.drystone || (s.walls.drystone = et(t.walls.drystone, 4)),
                              (Zn.map = s.walls.drystone),
                              s.walls.fence || (s.walls.fence = et(t.walls.fence, 4)),
                              (xa.map = s.walls.fence),
                              s.walls.sea || (s.walls.sea = et(t.walls.sea, 4)),
                              (ka.map = s.walls.sea),
                              (Ia.map = s.walls.sea)),
                        (Co.map = Zn.map),
                        this.skin.friction ? (Pt(this.skin.friction.road), Bt(this.skin.friction.side), Et(this.skin.friction.grass)) : (Pt(1.4), Bt(0.95), Et(0.85)),
                        (this.weatherOverride = !1),
                        this.skin.weathers
                            ? ((this.weatherOverride = !0), (this.skinWeatherList = this.skin.weathers), this.setWeather(this.skinWeatherList[this.curWeatherIndex % this.skinWeatherList.length]))
                            : this.setWeather(this.weatherList[this.curWeatherIndex % this.weatherList.length]),
                        this.onWeatherCycleChanged(Vs.value);
                }
                setWeatherIndex(e) {
                    (this.curWeatherIndex = e), this.weatherOverride ? this.setWeather(this.skinWeatherList[e]) : this.setWeather(this.weatherList[e]);
                }
                nextWeather() {
                    this.weatherOverride ? this.setWeather(this.skinWeatherList[++this.curWeatherIndex % this.skinWeatherList.length]) : this.setWeather(this.weatherList[++this.curWeatherIndex % this.weatherList.length]);
                }
                updateAudio() {
                    var e, t;
                    (this.t = Math.min(1, Hs.speed / 35)),
                        (this.t *= this.t),
                        (this.interiorVol = Qs.value ? 0.33 : 1),
                        (this.audioLerp = 0.9 * this.audioLerp + 0.1 * this.t),
                        null === (e = this.ambientAudio) || void 0 === e || e.setVolume((1 - this.audioLerp) * this.interiorVol),
                        null === (t = this.windAudio) || void 0 === t || t.setVolume(0.8 * this.audioLerp * this.interiorVol);
                }
                hexToArray(e) {
                    return this.tCol.setHex(e).toArray().concat(1);
                }
                setWeather(e) {
                    var t, i, s, n;
                    (this.weather = Fs.weathers[e]), (this.weatherB = Fs.weathers.sunset);
                    let a = Fs.weathers.default,
                        o = (null === (t = this.weather) || void 0 === t || null === (i = t.audio) || void 0 === i ? void 0 : i.ambiance) || a.audio.ambiance;
                    ue.getAudio(o.src, (e) => {
                        this.ambientAudio && this.ambientAudio.stop(), e.setLoop(!0), e.setLoopStart(o.ls), e.setLoopEnd(e.buffer.duration - o.le), (this.ambientAudio = e), e.setVolume(0), e.play();
                    });
                    let r = (null === (s = this.weather) || void 0 === s || null === (n = s.audio) || void 0 === n ? void 0 : n.wind) || a.audio.wind;
                    ue.getAudio(r.src, (e) => {
                        this.windAudio && this.windAudio.stop(), e.setLoop(!0), e.setLoopStart(r.ls), e.setLoopEnd(e.buffer.duration - r.le), (this.windAudio = e), e.setVolume(0), e.play();
                    }),
                        (vt.intensity = this.weather.amb),
                        vt.color.setHex(this.weather.col),
                        Co.emissive.copy(vt.color),
                        (ft.intensity = this.weather.hem),
                        ft.color.setHex(this.weather.hemTop || this.weather.col),
                        ft.groundColor.setHex(this.weather.hemGround || this.weather.col),
                        (wt.intensity = this.weather.dir),
                        wt.color.setHex(this.weather.col),
                        wt.sunOffset.fromArray(this.weather.sunPos || [0, 100, 0]),
                        bt.setHex(this.weather.col),
                        fe.setHeadlightColour(16777215),
                        lt(this.weather.col, St * this.weather.fogNear, St * this.weather.fogFar),
                        (this.dynamicFog = !!this.weather.dynamicFog),
                        this.cachedTextures[e] || (this.cachedTextures[e] = {});
                    let h = this.cachedTextures[e],
                        l = this.cachedTextures.default;
                    (Xt.userData.hasClouds.value = !0),
                        "skyMap" in this.weather
                            ? null == this.weather.skyMap
                                ? (Xt.userData.hasClouds.value = !1)
                                : (h.skyMap || (h.skyMap = et(this.weather.skyMap, 2)), (Xt.map = h.skyMap))
                            : (l.skyMap || (l.skyMap = et(a.skyMap, 2)), (Xt.map = l.skyMap)),
                        this.weather.skyCol
                            ? (Xt.userData.nearCol.value.setHex(this.weather.skyCol), Xt.userData.farCol.value.setHex(this.weather.skyColFar))
                            : (Xt.userData.nearCol.value.setHex(a.skyCol), Xt.userData.farCol.value.setHex(a.skyColFar)),
                        (Xt.uniformsNeedUpdate = !0),
                        (Gs.visible = !0),
                        "water" in this.weather
                            ? (null == this.weather.water && (Gs.visible = !1),
                              Gs.color.setHex(this.weather.water),
                              (Gs.userData.sunCol.value = this.hexToArray(this.weather.col)),
                              (Gs.userData.skyCol.value = this.hexToArray(this.weather.waterSkyReflection || a.waterSkyReflection)),
                              (Gs.uniformsNeedUpdate = !0))
                            : Gs.color.setHex(a.water),
                        fe.setHeadlights(!!this.weather.headlights),
                        this.weatherController.setWeather(this.weather.particles),
                        this.onWeatherCycleChanged(Vs.value);
                }
            }
            (Go.config = Fs), (Go.sceneName = "Peaks");
            var Bo = Go;
            const Wo = {},
                Eo = 2 * Math.PI;
            var Fo = class extends li {
                    constructor(...e) {
                        super(...e),
                            (this.gradients = []),
                            (this.scale = 4e3),
                            (this.heightOffset = 150),
                            (this.heightInitial = 1),
                            (this.resolution = 2),
                            (this.depth = 3),
                            (this.upscale = 5),
                            (this.cache = {}),
                            (this.cacheAccess = {}),
                            (this.cacheCount = 0),
                            (this.maxCached = 15),
                            (this.craterLayers = 3),
                            (this.craterDepth = 2),
                            (this.craterCache = {}),
                            (this.cellScaleMetres = 1500),
                            (this.cellScaleWorld = 1e3),
                            (this.squared = !1),
                            (this.compound = !1),
                            (this.useQuick = !1);
                        let t = e[1] || {};
                        (this.seed = e[0] || Be),
                            (this.heightScale = t.heightScale || 1),
                            (this.heightInitial = t.heightInitial || 1),
                            (this.resolution = t.resolution || 5),
                            (this.depth = t.depth || 3),
                            (this.upscale = t.upscale || 3),
                            (this.heightOffset = t.heightOffset || 0),
                            (this.upscaleFactor = t.upscaleFactor || 2),
                            (this.craterLayers = null == t.craterLayers ? 2 : t.craterLayers),
                            (this.craterProb = t.craterProb || 0.33),
                            (this.craterDepth = t.craterDepth || 2),
                            (this.squared = t.squared || !1),
                            (this.squareLayers = t.squareLayers || this.depth),
                            (this.compound = t.compound || !1),
                            (this.cellScaleWorld = this.cellScaleMetres);
                    }
                    clearCache() {
                        if (this.cacheCount <= this.maxCached) return;
                        let e, t;
                        for (e in this.cache) {
                            for (t in this.cache[e])
                                if (this.cacheAccess[e][t]) this.cacheAccess[e][t] = !1;
                                else if ((delete this.cache[e][t], delete this.cacheAccess[e][t], e in this.craterCache && delete this.craterCache[e][t], this.cacheCount--, this.cacheCount <= this.maxCached)) break;
                            if (this.cacheCount <= this.maxCached) break;
                        }
                        en["heightmap-cache"] = this.cacheCount;
                    }
                    checkCellCrater(e, t, i, s, n) {
                        var a;
                        return (
                            (this.craterCache[e] && this.craterCache[e][t]) || this.cacheCellCraters(e, t), null === (a = this.craterCache[e][t][n][Math.floor(i * (2 * (n + 1)))]) || void 0 === a ? void 0 : a[Math.floor(s * (2 * (n + 1)))]
                        );
                    }
                    cacheCellCraters(e, t) {
                        let i,
                            s,
                            n,
                            a,
                            o,
                            r,
                            h,
                            l,
                            d,
                            c,
                            p,
                            u,
                            g = [],
                            m = 0,
                            x = new window.alea("" + this.seed + e + t);
                        for (let v = 0; v < this.craterLayers; v++) {
                            for (i = {}, s = 2 * (v + 1), n = 1 / (2 * s), r = 1 / s / 2, h = r / 2, o = r - h, m = this.craterProb * s * s, a = 0; a < m; a++)
                                (c = h + x() * o),
                                    (l = r - c),
                                    (d = -l / 2),
                                    (p = Math.floor(x() * s)),
                                    (u = Math.floor(x() * s)),
                                    i[p] || (i[p] = {}),
                                    (i[p][u] = { x: p / s + n + (x() * l + d), y: -(1 + x()) * this.craterDepth, z: u / s + n + (x() * l + d), r: c, r2: c * c, r3: c * c * c * 0.512 });
                            g.push(i);
                        }
                        return this.craterCache[e] || (this.craterCache[e] = {}), (this.craterCache[e][t] = g), g;
                    }
                    generateCell(e, t) {
                        let i,
                            s,
                            n,
                            a,
                            o = new window.alea(this.seed + e + t),
                            r = this.resolution,
                            h = [],
                            l = [];
                        for (i = 0; i < this.depth; i++) {
                            for (l = [], s = 0; s < r; s++) for (l.push([]), n = 0; n < r; n++) (a = o() * Eo), l[s].push({ x: Math.cos(a), y: Math.sin(a) });
                            h.push(l), (r = this.getNextDepthResolution(r, i));
                        }
                        return h;
                    }
                    getNextDepthResolution(e, t) {
                        return Math.round(e * this.upscaleFactor);
                    }
                    dotGridGradient(e, t, i, s, n) {
                        return (this.grad = e[t][i]), (s - t) * this.grad.x + (n - i) * this.grad.y;
                    }
                    sharpLerp(e, t, i) {
                        return (t - e) * i + e;
                    }
                    smoothLerp(e, t, i) {
                        return (t - e) * (3 - 2 * i) * i * i + e;
                    }
                    smootherLerp(e, t, i) {
                        return (i * (6 * i - 15) + 10) * i * i * i * (t - e) + e;
                    }
                    getXZ(e, t, i) {
                        for (Wo.layer of ((Wo.d = 0),
                        (Wo.h = 0),
                        (Wo.sq = this.resolution),
                        (Wo.sqb = Wo.sq - 1),
                        (Wo.wx = e / this.cellScaleWorld),
                        (Wo.wz = t / this.cellScaleWorld),
                        (Wo.ox = Math.floor(Wo.wx)),
                        (Wo.oz = Math.floor(Wo.wz)),
                        (Wo.px = Wo.wx - Wo.ox),
                        (Wo.pz = Wo.wz - Wo.oz),
                        (Wo.cell = this.getCell(Wo.ox, Wo.oz)),
                        (i = i || this.depth),
                        (Wo.depth = 0),
                        (Wo.h = this.heightInitial),
                        (Wo.heightFactor = 1),
                        (Wo.ch = 0),
                        Wo.cell)) {
                            if (Wo.depth == i) break;
                            (Wo.sx = Wo.px * Wo.sq),
                                (Wo.sz = Wo.pz * Wo.sq),
                                (Wo.ix = Math.floor(Wo.sx)),
                                (Wo.ix1 = Wo.ix + 1),
                                (Wo.iz = Math.floor(Wo.sz)),
                                (Wo.iz1 = Wo.iz + 1),
                                (Wo.qx = Wo.sx - Wo.ix),
                                (Wo.qz = Wo.sz - Wo.iz),
                                (Wo.n0 = this.dotGridGradient(Wo.layer, Wo.ix, Wo.iz, Wo.sx, Wo.sz)),
                                Wo.ix1 < Wo.sq ? (Wo.n1 = this.dotGridGradient(Wo.layer, Wo.ix1, Wo.iz, Wo.sx, Wo.sz)) : (Wo.n1 = this.dotGridGradient(this.getCell(Wo.ox + 1, Wo.oz)[Wo.depth], 0, Wo.iz, Wo.sx - Wo.sq, Wo.sz)),
                                (Wo.int0 = this.smootherLerp(Wo.n0, Wo.n1, Wo.qx)),
                                Wo.iz1 < Wo.sq
                                    ? ((Wo.n0 = this.dotGridGradient(Wo.layer, Wo.ix, Wo.iz1, Wo.sx, Wo.sz)),
                                      Wo.ix1 < Wo.sq ? (Wo.n1 = this.dotGridGradient(Wo.layer, Wo.ix1, Wo.iz1, Wo.sx, Wo.sz)) : (Wo.n1 = this.dotGridGradient(this.getCell(Wo.ox + 1, Wo.oz)[Wo.depth], 0, Wo.iz1, Wo.sx - Wo.sq, Wo.sz)))
                                    : ((Wo.n0 = this.dotGridGradient(this.getCell(Wo.ox, Wo.oz + 1)[Wo.depth], Wo.ix, 0, Wo.sx, Wo.sz - Wo.sq)),
                                      Wo.ix1 < Wo.sq
                                          ? (Wo.n1 = this.dotGridGradient(this.getCell(Wo.ox, Wo.oz + 1)[Wo.depth], Wo.ix1, 0, Wo.sx, Wo.sz - Wo.sq))
                                          : (Wo.n1 = this.dotGridGradient(this.getCell(Wo.ox + 1, Wo.oz + 1)[Wo.depth], 0, 0, Wo.sx - Wo.sq, Wo.sz - Wo.sq))),
                                (Wo.int1 = this.smootherLerp(Wo.n0, Wo.n1, Wo.qx)),
                                (Wo.heightFactor = this.resolution / Wo.sq),
                                this.compound && (Wo.heightFactor *= Wo.h),
                                (Wo.cl = 1),
                                Wo.depth < this.craterLayers &&
                                    ((Wo.craterFactor = 1 / (2 * (Wo.depth + 1))),
                                    (Wo.c = this.checkCellCrater(Wo.ox, Wo.oz, Wo.px, Wo.pz, Wo.depth)),
                                    Wo.c &&
                                        ((Wo.d = (Wo.c.x - Wo.px) * (Wo.c.x - Wo.px) + (Wo.c.z - Wo.pz) * (Wo.c.z - Wo.pz)),
                                        Wo.d < Wo.c.r2 &&
                                            ((Wo.ch -= Wo.c.y * (1 - this.smoothLerpW(1 - Wo.d / Wo.c.r2)) * Wo.craterFactor * 0.5 * Wo.cl),
                                            (Wo.d *= Math.sqrt(Wo.d)),
                                            Wo.d < Wo.c.r3 && ((Wo.d = Wo.d / Wo.c.r3), (Wo.ch += Wo.c.y * (1 - this.smootherLerpW(1 - Wo.d)) * Wo.craterFactor * Wo.cl), (Wo.cl = Math.min(Wo.cl, Wo.d)))))),
                                (Wo.h += this.smootherLerp(Wo.int0, Wo.int1, Wo.qz) * Wo.heightFactor * Wo.cl),
                                (Wo.sq = this.getNextDepthResolution(Wo.sq, Wo.depth)),
                                Wo.depth++;
                        }
                        return this.squared && (Wo.h *= Wo.h), (Wo.h += Wo.ch), Wo.h * this.heightScale + this.heightOffset;
                    }
                    getXZLayer(e, t, i) {
                        for (Wo.layer of ((Wo.d = 0),
                        (Wo.h = 0),
                        (Wo.sq = this.resolution),
                        (Wo.sqb = Wo.sq - 1),
                        (Wo.wx = e / this.cellScaleWorld),
                        (Wo.wz = t / this.cellScaleWorld),
                        (Wo.ox = Math.floor(Wo.wx)),
                        (Wo.oz = Math.floor(Wo.wz)),
                        (Wo.px = Wo.wx - Wo.ox),
                        (Wo.pz = Wo.wz - Wo.oz),
                        (Wo.cell = this.getCell(Wo.ox, Wo.oz)),
                        (Wo.depth = 0),
                        (Wo.h = this.heightInitial),
                        (Wo.heightFactor = 1),
                        (Wo.ch = 0),
                        Wo.cell))
                            if (Wo.depth < i) (Wo.sq = this.getNextDepthResolution(Wo.sq, Wo.depth)), Wo.depth++;
                            else {
                                if (Wo.depth == this.depth || Wo.depth > i) break;
                                (Wo.sx = Wo.px * Wo.sq),
                                    (Wo.sz = Wo.pz * Wo.sq),
                                    (Wo.ix = Math.floor(Wo.sx)),
                                    (Wo.ix1 = Wo.ix + 1),
                                    (Wo.iz = Math.floor(Wo.sz)),
                                    (Wo.iz1 = Wo.iz + 1),
                                    (Wo.qx = Wo.sx - Wo.ix),
                                    (Wo.qz = Wo.sz - Wo.iz),
                                    (Wo.n0 = this.dotGridGradient(Wo.layer, Wo.ix, Wo.iz, Wo.sx, Wo.sz)),
                                    Wo.ix1 < Wo.sq ? (Wo.n1 = this.dotGridGradient(Wo.layer, Wo.ix1, Wo.iz, Wo.sx, Wo.sz)) : (Wo.n1 = this.dotGridGradient(this.getCell(Wo.ox + 1, Wo.oz)[Wo.depth], 0, Wo.iz, Wo.sx - Wo.sq, Wo.sz)),
                                    (Wo.int0 = this.smootherLerp(Wo.n0, Wo.n1, Wo.qx)),
                                    Wo.iz1 < Wo.sq
                                        ? ((Wo.n0 = this.dotGridGradient(Wo.layer, Wo.ix, Wo.iz1, Wo.sx, Wo.sz)),
                                          Wo.ix1 < Wo.sq ? (Wo.n1 = this.dotGridGradient(Wo.layer, Wo.ix1, Wo.iz1, Wo.sx, Wo.sz)) : (Wo.n1 = this.dotGridGradient(this.getCell(Wo.ox + 1, Wo.oz)[Wo.depth], 0, Wo.iz1, Wo.sx - Wo.sq, Wo.sz)))
                                        : ((Wo.n0 = this.dotGridGradient(this.getCell(Wo.ox, Wo.oz + 1)[Wo.depth], Wo.ix, 0, Wo.sx, Wo.sz - Wo.sq)),
                                          Wo.ix1 < Wo.sq
                                              ? (Wo.n1 = this.dotGridGradient(this.getCell(Wo.ox, Wo.oz + 1)[Wo.depth], Wo.ix1, 0, Wo.sx, Wo.sz - Wo.sq))
                                              : (Wo.n1 = this.dotGridGradient(this.getCell(Wo.ox + 1, Wo.oz + 1)[Wo.depth], 0, 0, Wo.sx - Wo.sq, Wo.sz - Wo.sq))),
                                    (Wo.int1 = this.smootherLerp(Wo.n0, Wo.n1, Wo.qx)),
                                    (Wo.heightFactor = this.resolution / Wo.sq),
                                    this.compound && (Wo.heightFactor *= Wo.h),
                                    (Wo.cl = 1),
                                    Wo.depth < this.craterLayers &&
                                        ((Wo.craterFactor = 1 / (2 * (Wo.depth + 1))),
                                        (Wo.c = this.checkCellCrater(Wo.ox, Wo.oz, Wo.px, Wo.pz, Wo.depth)),
                                        Wo.c &&
                                            ((Wo.d = (Wo.c.x - Wo.px) * (Wo.c.x - Wo.px) + (Wo.c.z - Wo.pz) * (Wo.c.z - Wo.pz)),
                                            Wo.d < Wo.c.r2 &&
                                                ((Wo.ch -= Wo.c.y * (1 - this.smoothLerpW(1 - Wo.d / Wo.c.r2)) * Wo.craterFactor * 0.5 * Wo.cl),
                                                (Wo.d *= Math.sqrt(Wo.d)),
                                                Wo.d < Wo.c.r3 && ((Wo.d = Wo.d / Wo.c.r3), (Wo.ch += Wo.c.y * (1 - this.smootherLerpW(1 - Wo.d)) * Wo.craterFactor * Wo.cl), (Wo.cl = Math.min(Wo.cl, Wo.d)))))),
                                    (Wo.h += this.smootherLerp(Wo.int0, Wo.int1, Wo.qz) * Wo.heightFactor * Wo.cl),
                                    (Wo.sq = this.getNextDepthResolution(Wo.sq, Wo.depth)),
                                    Wo.depth++;
                            }
                        return this.squared && (Wo.h *= Wo.h), (Wo.h += Wo.ch), Wo.h * this.heightScale + this.heightOffset;
                    }
                    smootherLerpW(e) {
                        return (e * (6 * e - 15) + 10) * e * e * e * -1 + 1;
                    }
                    sharpLerpW(e) {
                        return 1 - e;
                    }
                    smoothLerpW(e) {
                        return -1 * (3 - 2 * e) * e * e + 1;
                    }
                },
                Zo = i.p + "static/media/road_offworld.235fa320.webp",
                Ho = i.p + "static/media/mars_road_base.4b28c294.webp",
                Qo = i.p + "static/media/mars_surface.4083a724.webp",
                Yo = i.p + "static/media/mars_subsurface.d95fa5d1.webp",
                Vo = i.p + "static/media/mars_surface_bump.65340168.webp",
                Uo = i.p + "static/media/mars_cliff_bump.8e6fa674.webp",
                Xo = i.p + "static/media/mars_shale.9fd99ef9.webp",
                Jo = i.p + "static/media/mars_shale_bump.c92f843f.webp",
                qo = i.p + "static/media/mars_rubble.c8241124.webp",
                Ko = i.p + "static/media/mars_rubble_bump.80ebc535.webp",
                _o = i.p + "static/media/mars_rock.75c6c859.webp",
                $o = i.p + "static/media/mars_rock_bump.15322551.webp",
                er = i.p + "static/media/mars_cliff.3ae2933c.webp",
                tr = i.p + "static/media/mars_barrier_wide.d7dc8819.webp",
                ir = i.p + "static/media/venus_road_base.20746f01.webp",
                sr = i.p + "static/media/venus_surface.38f0fb31.webp",
                nr = i.p + "static/media/venus_shale.bafde95f.webp",
                ar = i.p + "static/media/venus_rubble.1f56f6fb.webp",
                or = i.p + "static/media/venus_rock.c3115f27.webp",
                rr = i.p + "static/media/venus_cliff.fbb8e3df.webp",
                hr = i.p + "static/media/road_venus.61168361.webp",
                lr = i.p + "static/media/venus_barrier_wide.1b943c45.webp",
                dr = i.p + "static/media/moon_surface.f0a08f87.webp",
                cr = i.p + "static/media/moon_rock.47e45865.webp",
                pr = i.p + "static/media/moon_gravel.b53b019d.webp",
                ur = i.p + "static/media/moon_shale.07a93da8.webp",
                gr = i.p + "static/media/moon_cliff.4bb9ff9d.webp",
                mr = i.p + "static/media/road_moon.c594cb0f.webp",
                xr = i.p + "static/media/clouds_01.e03e365b.webp",
                vr = i.p + "static/media/clouds_02.840643a8.webp",
                fr = i.p + "static/media/ambiance_offworld.41a010f6.mp3",
                wr = i.p + "static/media/wind_offworld_02.5468adb6.mp3",
                br = i.p + "static/media/crossfade_fine.0d1ec73b.webp",
                Ar = i.p + "static/media/crossfade_finest.da758a11.webp";
            const yr = {
                topography: {
                    normal: {
                        heightmap: { heightScale: 50, heightOffset: 500, heightInitial: 1.1, resolution: 1, craterLayers: 2, craterDepth: 0.75, upscaleFactor: 2.5, depth: 4, midlineDepth: 5, squared: !0, compound: !0 },
                        roadWidth: 3,
                        smoothWindow: 7,
                    },
                    hard: {
                        heightmap: { heightScale: 40, heightOffset: 500, heightInitial: 1, resolution: 2, craterLayers: 3, craterDepth: 1.5, upscaleFactor: 2, depth: 5, midlineDepth: 5, squared: !0, compound: !1 },
                        roadWidth: 2.8,
                        smoothWindow: 5,
                    },
                    easy: {
                        heightmap: { heightScale: 45, heightOffset: 500, heightInitial: 1.5, resolution: 2, craterLayers: 2, craterDepth: 0.75, upscaleFactor: 2, depth: 3, midlineDepth: 5, squared: !1, compound: !0 },
                        roadWidth: 3.2,
                        smoothWindow: 7,
                    },
                    casual: {
                        heightmap: { heightScale: 60, heightOffset: 500, heightInitial: 1.5, resolution: 2, craterLayers: 1, craterDepth: 0.5, upscaleFactor: 2, depth: 2, midlineDepth: 5, squared: !1, compound: !0 },
                        roadWidth: 3.2,
                        smoothWindow: 7,
                    },
                    straight: {
                        heightmap: { heightScale: 45, heightOffset: 500, heightInitial: 1.5, resolution: 2, craterLayers: 2, craterDepth: 0.5, upscaleFactor: 2, depth: 3, midlineDepth: 5, squared: !1, compound: !0 },
                        roadWidth: 3.2,
                        smoothWindow: 7,
                    },
                    flat: { heightmap: { heightScale: 0, heightOffset: 50, resolution: 1, depth: 1, upscale: 1 }, roadWidth: 20, smoothWindow: 7 },
                },
                weathers: {
                    default: {
                        audio: { ambiance: { src: fr, ls: 0.1, le: 0.1 }, wind: { src: wr, ls: 0.07, le: 0.07 } },
                        water: 11378325,
                        col: 16121855,
                        hemTop: 6710886,
                        hemGround: 16777215,
                        skyCol: 5197130,
                        skyColFar: 15904116,
                        skyMap: xr,
                        amb: 0.2,
                        hem: 0.3,
                        dir: 0.5,
                        fogNear: 0,
                        fogFar: 1,
                        sunPos: [0, 100, 0],
                    },
                    mars: {
                        audio: { ambiance: { src: fr, ls: 0.1, le: 0.1 }, wind: { src: wr, ls: 0.07, le: 0.07 } },
                        col: 16758891,
                        skyCol: 11378567,
                        skyColFar: 16761989,
                        skyMap: null,
                        hemTop: 16769727,
                        hemGround: 0,
                        water: 11378325,
                        amb: 0.4,
                        hem: 0.2,
                        dir: 0.5,
                        fogNear: -0.05,
                        fogFar: 1,
                        sunPos: [0, 100, -75],
                    },
                    marsRise: { col: 5338516, skyCol: 2368806, skyColFar: 5338516, skyMap: null, amb: 0, hem: 0.25, dir: 0.25, headlights: !0, headlightColour: 9694965, fogNear: -0.1, fogFar: 1, sunPos: [0, 100, 200] },
                    marsNight: { col: 1579803, skyCol: 1183766, skyColFar: 1579803, skyMap: null, amb: 0.7, hem: 0.5, dir: 0.2, headlights: !0, headlightColour: 9694965 },
                    venus: {
                        audio: { ambiance: { src: fr, ls: 0.1, le: 0.1 }, wind: { src: wr, ls: 0.1, le: 0.1 } },
                        col: 14729798,
                        skyCol: 12624422,
                        skyColFar: 12624422,
                        skyMap: vr,
                        water: null,
                        amb: 0,
                        hem: 0.5,
                        dir: 0.5,
                        fogNear: -0.1,
                        fogFar: 0.5,
                    },
                    venusSet: { col: 6049571, skyCol: 2366739, skyColFar: 6049571, skyMap: vr, water: null, amb: 0.2, hem: 0.6, dir: 0.2, fogNear: -0.2, fogFar: 0.5, headlights: !0, headlightColour: 16773557 },
                    moon: {
                        audio: { ambiance: { src: null, ls: 0.1, le: 0.1 }, wind: { src: null, ls: 0.07, le: 0.07 } },
                        col: 1118480,
                        skyCol: 1118480,
                        skyColFar: 1118480,
                        skyMap: null,
                        hemTop: 16777215,
                        hemGround: 0,
                        water: null,
                        amb: 2,
                        hem: 0,
                        dir: 15,
                        fogNear: 0.25,
                        fogFar: 1,
                        sunPos: [-25, 100, 75],
                    },
                },
                skins: {
                    default: {
                        name: "mars",
                        weathers: ["mars", "marsRise"],
                        surface: Qo,
                        subSurface: Yo,
                        gravel: Ho,
                        gravelBump: Uo,
                        rock: _o,
                        cliff: er,
                        shale: Xo,
                        shaleBump: Jo,
                        rubble: qo,
                        rubbleBump: Ko,
                        road: Zo,
                        roadBase: Ho,
                        friction: { road: 0.99, side: 0.95, grass: 0.9 },
                        walls: { barrier: tr },
                    },
                    venus: {
                        name: "venus",
                        weathers: ["venus", "venusSet"],
                        surface: ir,
                        subSurface: sr,
                        gravel: sr,
                        cliff: rr,
                        rock: or,
                        shale: nr,
                        rubble: ar,
                        road: hr,
                        roadBase: sr,
                        water: null,
                        friction: { road: 0.99, side: 0.95, grass: 0.9 },
                        walls: { barrier: lr },
                    },
                    moon: {
                        name: "moon",
                        weathers: ["moon"],
                        surface: dr,
                        subSurface: cr,
                        gravel: pr,
                        cliff: gr,
                        rock: cr,
                        shale: ur,
                        rubble: null,
                        road: mr,
                        roadBase: pr,
                        water: null,
                        friction: { road: 0.99, side: 0.9, grass: 0.8 },
                        walls: { barrier: lr },
                    },
                },
            };
            let Ir = new r.F({ map: et(Qo, 0) });
            (Ir.userData.surfaceMap = { value: null }),
                (Ir.userData.surfaceBump = { value: et(Vo, 0) }),
                (Ir.userData.subSurfaceMap = { value: null }),
                (Ir.userData.shaleMap = { value: null }),
                (Ir.userData.shaleBump = { value: et(Jo, 4) }),
                (Ir.userData.rockMap = { value: null }),
                (Ir.userData.rockBump = { value: et($o, 0) }),
                (Ir.userData.cliffMap = { value: null }),
                (Ir.userData.cliffBump = { value: et(Uo, 0) }),
                (Ir.userData.gravelMap = { value: null }),
                (Ir.userData.roadBaseMap = { value: null }),
                (Ir.userData.fadeRockMap = { value: et(br, 4) }),
                (Ir.userData.fadeFiner = { value: et(Ar, 4) }),
                (Ir.onBeforeCompile = (e) => (
                    (e.uniforms.surfaceMap = Sr.userData.surfaceMap),
                    (e.uniforms.surfaceBump = Sr.userData.surfaceBump),
                    (e.uniforms.subSurfaceMap = Sr.userData.subSurfaceMap),
                    (e.uniforms.shaleMap = Sr.userData.shaleMap),
                    (e.uniforms.shaleBump = Sr.userData.shaleBump),
                    (e.uniforms.rockMap = Sr.userData.rockMap),
                    (e.uniforms.rockBump = Sr.userData.rockBump),
                    (e.uniforms.cliffMap = Sr.userData.cliffMap),
                    (e.uniforms.cliffBump = Sr.userData.cliffBump),
                    (e.uniforms.gravelMap = Sr.userData.gravelMap),
                    (e.uniforms.roadBaseMap = Sr.userData.roadBaseMap),
                    (e.uniforms.fadeRockMap = Sr.userData.fadeRockMap),
                    (e.uniforms.fadeFiner = Sr.userData.fadeFiner),
                    (e.vertexShader = e.vertexShader.replace(
                        "#include <displacementmap_pars_vertex>",
                        "\n\nattribute float heightOffset;\nattribute float roadProximity;\nattribute float curvature;\nattribute vec2 wuv;\n\nvarying float height;\nvarying float steepness;\nvarying float roadProx;\nvarying float vCurvature;\nvarying vec2 vWv;\nvarying vec2 vWWv;\n\nuniform sampler2D displacementMap;\nuniform sampler2D fadeFiner;\n\nfloat wuvSize = 150.0;\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec3 upvec = vec3(0.0,1.0,0.0);\n\n"
                    )),
                    (e.vertexShader = e.vertexShader.replace(
                        "#include <displacementmap_vertex>",
                        "\n\n  vec4 wPos = modelMatrix * vec4( position, 1.0 );\n  height = wPos.y + heightOffset;\n\n  vUv.x = wPos.x / 10.0;\n  vUv.y = wPos.z / 10.0;\n\n\n  // 0 is perfectly flat, 1 is 90 degrees\n  steepness = 1.0 - dot(normal, upvec);\n  steepness = clamp(steepness * 4.0, 0.0, 1.0);\n\n  // Anything up to 0.8 is 1\n  // 0.8 down to 0.6\n  // 0.6 and under is 0\n\n  // steepness = 1.0 - clamp((steepness - 0.6) / 0.2, 0.0, 1.0);\n  // steepness = 1.0 - map(steepness, 0.2, 0.7, 0.0, 1.0);\n\n  // steepness = 1.0 - steepness;//clamp((steepness * 2.0), 0.0, 1.0);\n  // steepness = map(steepness, 0.0, 1.0, 0.3, 0.7);\n\n  if(roadProximity < 0.0) {\n    roadProx = -roadProximity * 2.0;\n  } else {\n    roadProx = 0.0;\n  }\n  // roadProx = roadProximity;\n\n  // if(roadProx > -1.0) {\n  //   transformed.y += texture2D( fadeFiner, vUv ).r * 0.1;\n  // }\n\n  // MAGIC NUMBERS TO BE TWEAKED BASED ON HEIGHT PARAMETERS\n  if(curvature > 0.0) {\n    vCurvature = min(1.0, curvature * 5.0);\n  } else {\n    vCurvature = max(-1.0, curvature * 5.0);\n  }\n\n  // TODO PASS IN SCALE AS UNIFORM\n  vWv.x = wPos.x / wuvSize;\n  vWv.y = wPos.z / wuvSize;\n\n  vWWv.x = vWv.x / 10.0;\n  vWWv.y = vWv.y / 10.0;\n\n  transformed += vec3(0.0, heightOffset, 0.0);\n\n  // Experimenting with displacement map\n  if(steepness > 0.3) {\n    transformed += normalize( objectNormal ) * ( texture2D( fadeFiner, vUv ).x * (steepness-0.3) * 0.5 );\n  }\n\n"
                    )),
                    (e.fragmentShader = e.fragmentShader.replace(
                        "#include <map_pars_fragment>",
                        "\n\n  varying float height;\n  varying float steepness;\n  varying float roadProx;\n  varying float vCurvature;\n  varying vec2 vWv;\n  varying vec2 vWWv;\n\n  uniform sampler2D surfaceMap;\n  uniform sampler2D subSurfaceMap;\n  uniform sampler2D surfaceBump;\n  uniform sampler2D shaleMap;\n  uniform sampler2D shaleBump;\n  uniform sampler2D rockMap;\n  uniform sampler2D rockBump;\n  uniform sampler2D cliffMap;\n  uniform sampler2D cliffBump;\n  uniform sampler2D gravelMap;\n  uniform sampler2D gravelBump;\n  uniform sampler2D roadBaseMap;\n  uniform sampler2D fadeRockMap;\n  uniform sampler2D fadeFiner;\n\n\n  vec4 terrainBlend(vec4 tx1, float w1, vec4 tx2, float w2, float depth) {\n    // Perform the blending\n    float ma = max(tx1.a + w1, tx2.a + w2) - depth;\n    float b1 = max(tx1.a + w1 - ma, 0.0);\n    float b2 = max(tx2.a + w2 - ma, 0.0);\n\n    return ((tx1 * b1) + (tx2 * b2)) / (b1 + b2);\n  }\n\n"
                    )),
                    (e.fragmentShader = e.fragmentShader.replace(
                        "#include <map_fragment>",
                        "\n\n  vec4 texelColor = texture2D( surfaceMap, vUv );\n\n  // Prep textures ahead of blending\n  vec4 surfaceTex = texture2D(surfaceMap, vUv); //vec4(0.7,0.7,0.0,1.0);\n  vec4 subSurfaceTex = texture2D(subSurfaceMap, vUv); //vec4(0.5,0.5,0.0,1.0);\n  vec4 shaleTex = texture2D(shaleMap, vUv);\n\n  vec4 rockTex = texture2D(rockMap, vUv); //vec4(0.3,0.3,0.1,1.0);\n\n  vec4 gravelTex = texture2D(gravelMap, vUv);\n  vec4 cliffTex = texture2D(cliffMap, vUv); //vec4(0.15,0.15,0.0,1.0);\n\n  // Get our fades at different scales\n  float fade0 = texture2D( fadeRockMap, vUv ).r;\n  float fade1 = texture2D( fadeRockMap, vWv ).r;\n  float fade2 = texture2D( fadeRockMap, vWWv ).r;\n\n  // Set alphas from maps etc.\n  float rockFade = texture2D(rockBump, vWv).r;\n  rockTex.a = texture2D(rockBump, vUv).r;\n  gravelTex.a = texture2D(gravelBump, vUv).r;\n  cliffTex.a = texture2D(cliffBump, vUv).r;\n  surfaceTex.a = texture2D(surfaceBump, vUv).r;\n  shaleTex.a = texture2D(shaleBump, vUv).r;\n\n  subSurfaceTex.a = fade1;\n\n  float roadProx2 = 1.0 - max(0.0, min(1.0, roadProx*0.25));\n\n  float w;\n\n  //// SAND/SURFACE\n\n  texelColor = mix(surfaceTex, subSurfaceTex, max(0.0,vCurvature-0.5)*fade2);\n\n  //// SHALE\n\n  if(vCurvature >= fade2) {\n    w = (vCurvature - fade2 * fade1) * roadProx2;\n\n    if(fade1 > 0.5) {\n      w *= 1.0 - (fade1 - 0.5) * 2.0;\n    }\n\n    w = min(0.6, w);\n    texelColor.a = 0.5;\n    texelColor = terrainBlend(texelColor, 1.0 - w, shaleTex, w, 0.1);\n  } else if(fade2 > 0.25) {\n    w = (fade2 - 0.25) * roadProx2;\n    texelColor = terrainBlend(texelColor, 1.0 - w, shaleTex, w, 0.1);\n  }\n\n  //// ROCK OUTCROPS\n\n  w = max(-0.8, ((vCurvature - fade2) * max(0.5, fade1))) * roadProx2;\n  rockTex.a -= rockFade;\n\n  if(w < 0.0) {\n    texelColor.a = 0.25 + fade2; //max(0.75, fade1);\n    texelColor = terrainBlend(texelColor, 1.0+w, rockTex, -w, 0.2);\n  } else if(fade1 > 0.5) {\n    texelColor.a = 0.25 + fade2;\n    w = (fade1 - 0.5) * 2.0;\n    texelColor = terrainBlend(texelColor, 1.0-w, rockTex, w, 0.2);\n  }\n\n  //// CLIFFS\n\n  if(steepness > 0.2) {\n    w = (steepness-0.2) + fade1 * 0.2;\n    texelColor = terrainBlend(texelColor, 1.0-w, cliffTex, w, 0.2);\n  }\n\n  //// ROAD PROXIMITY\n\n  if(roadProx > 0.0) {\n    w = min(1.0, (roadProx/2.5) - fade1*fade0);\n    texelColor = terrainBlend(texelColor, 1.0-w, gravelTex, w, 0.5);\n  }\n\n  texelColor.a = 1.0;\n\n  diffuseColor *= texelColor;\n\n"
                    )),
                    e
                ));
            const Sr = Ir,
                Mr = (e, t) => {
                    (jr = Cr[Math.floor((e + t) / 2)]), (kr = Dr[e]), (Nr = Ct), Or();
                },
                Dr = [5, 10, 15, 20];
            let kr = 10;
            const Cr = [500, 1e3, 2e3, 3e3];
            let jr = 1e3;
            let Nr = 32;
            const zr = [],
                Or = () => {
                    zr.length = 0;
                    let e,
                        t = new window.alea("bump");
                    for (let i = 0; i < Nr; i++) {
                        e = [];
                        for (let i = 0; i < Nr; i++) e.push(0.1 * t());
                        e.push(e[0]), zr.push(e);
                    }
                    zr.push(zr[0]);
                };
            Mr(st, nt), Or();
            var Lr = yr;
            var Rr = { rock: { src: i(42), obj: null } };
            var Tr = class {
                    constructor(e, t) {
                        (this.loader = new tn.a()), (this.assetCount = Object.keys(e).length), (this.loadCount = 0), (this.onComplete = t), (this.loadedAssets = {});
                        for (let i in e)
                            this.loader.load(e[i].src.default, (e) => {
                                (this.loadedAssets[i] = e), this.onLoaded(i);
                            });
                    }
                    onLoaded(e) {
                        ++this.loadCount >= this.assetCount && this.onComplete(this.loadedAssets);
                    }
                },
                Pr = i.p + "static/media/marsmarker.6a313c62.obj";
            const Gr = { black: new r.D({ color: 5588019 }), reflect: new r.D({ color: 2293725, emissive: 2293725, emissiveIntensity: 0.2 }) };
            var Br = class extends nn {
                    constructor(...e) {
                        super(...e), (this.geoSource = Pr), (this.objectType = "VergeMarker"), (this.materials = Gr);
                    }
                },
                Wr = i.p + "static/media/marsbarrier.c460e93d.obj";
            const Er = { black: new r.D({ color: 5588019 }), reflect: new r.D({ color: 2293725, emissive: 2293725, emissiveIntensity: 0.75 }) };
            const Fr = {
                    VergeMarker: { class: Br, geo: null },
                    BarrierMarker: {
                        class: class extends nn {
                            constructor(...e) {
                                super(...e), (this.geoSource = Wr), (this.objectType = "BarrierMarker"), (this.materials = Er);
                            }
                        },
                        geo: null,
                    },
                },
                Zr = "BarrierMarker";
            var Hr = new (class {
                constructor() {
                    (this.lastRepositionIndex = 0),
                        (this.pools = {}),
                        (this.active = []),
                        (this.loadingQueue = []),
                        (this.getHeightAt = () => {}),
                        (this.loadCounter = 0),
                        (this.didLoadBound = this.didLoad.bind(this)),
                        (this.addObjectBound = this.addObject.bind(this)),
                        (this.container = new r.G()),
                        (this.container.matrixAutoUpdate = !1),
                        (this.loadingQueue = []);
                }
                destroy() {
                    this.loadingQueue.length = 0;
                    for (let t in this.pools) {
                        var e;
                        for (let e of this.pools[t]) e.destroy();
                        null === (e = Fr[t].geo) || void 0 === e || e.destroy();
                    }
                    for (let t of this.active) t.destroy();
                    for (this.active.length = 0, this.pools = {}; this.container.children.length; ) this.container.remove(this.container.children[0]);
                }
                initialise(e) {
                    (this.getHeightAt = e), this.initLibrary();
                }
                reset(e) {
                    this.getHeightAt = e;
                }
                initLibrary() {
                    for (let e in Fr) this.loadObject(e), (this.pools[e] = []);
                }
                loadObject(e) {
                    let t = Fr[e],
                        i = new t.class();
                    i.initialiseGeometry(() => {
                        (t.geo = i), this.didLoad();
                    });
                }
                didLoad() {
                    if ((this.loadCounter++, this.loadCounter >= Object.keys(Fr).length))
                        for (; this.loadingQueue.length; ) {
                            let e = this.loadingQueue.pop();
                            this.addObject(...e);
                        }
                }
                addCustom(e, t, i, s, n = null) {
                    if ((n || (n = 5), $t.vehicleIndex > s + n)) return;
                    let a;
                    for (
                        e.keyName = null, e.worldPosition = t.clone(), e.position.subVectors(e.worldPosition, this.container.position), e.rotation.y = i, e.visible = !0, e.retireIndex = s + n, this.container.add(e), a = 0;
                        a < this.active.length && !(this.active[a].retireIndex > e.retireIndex);
                        a++
                    );
                    this.active.splice(a, 0, e);
                }
                addObject(e, t, i, s, n = null) {
                    if (!(e in Fr)) return void console.error("Unrecognised roadside object type ", e);
                    if (!Fr[e].geo) return void this.loadingQueue.push([e, t, i, s, n]);
                    let a, o;
                    for (
                        this.pools[e].length ? (a = this.pools[e].pop()) : ((a = Fr[e].geo.clone()), this.container.add(a), en["roadside-objects"]++),
                            a.keyName = e,
                            a.worldPosition.copy(t),
                            a.position.subVectors(a.worldPosition, this.container.position),
                            a.rotation.y = i,
                            a.visible = !0,
                            a.retireIndex = s + 5,
                            null !== n && a.setVariant(n),
                            o = 0;
                        o < this.active.length && !(this.active[o].retireIndex > a.retireIndex);
                        o++
                    );
                    return this.active.splice(o, 0, a), a;
                }
                update() {
                    if (this.active.length && $t.vehicleIndex >= this.active[0].retireIndex) {
                        let e = this.active.shift();
                        (e.visible = !1), e.keyName ? this.pools[e.keyName].push(e) : this.container.remove(e);
                    }
                    if ($t.vehicleIndex - this.lastRepositionIndex > 100) {
                        (this.container.position.x = $t.vehicleNode.p.x), (this.container.position.z = $t.vehicleNode.p.z), this.container.updateMatrix();
                        for (let e of this.container.children) e.position.subVectors(e.worldPosition, this.container.position);
                        this.lastRepositionIndex = $t.vehicleIndex;
                    }
                }
            })();
            const Qr = 0.8,
                Yr = 151,
                Vr = 0.65,
                Ur = ((e, t = 0.75, i = 0, s = null, n = null, a = !1) => {
                    let o = new r.F({ map: Je(e, i, r.O), alphaTest: t, side: r.k, depthTest: !0, roughness: 1, flatShading: !0 });
                    return s && (o.normalMap = Je(s, i)), (o.onBeforeCompile = Ke), o;
                })(null, 0.75, 8, null, null, !0),
                Xr = {};
            class Jr extends Dn {
                constructor(e = null) {
                    super(),
                        (this.p = new r.W()),
                        (this.ni = 0),
                        (this.mapSource = null),
                        (this.normSource = null),
                        (this.material = Ur),
                        (this.mesh = new r.B(Jr.getGeo(), this.material)),
                        (this.mesh.matrixAutoUpdate = !1),
                        this.mesh.geometry.setDrawRange(0, 0),
                        (this.posAttribute = this.mesh.geometry.attributes.position),
                        (this.posArr = this.posAttribute.array),
                        (this.uvAttribute = this.mesh.geometry.attributes.uv),
                        (this.uvArr = this.uvAttribute.array),
                        e && this.drawSegment(e),
                        this.applyMaterial();
                }
                applyMaterial() {
                    this.mapSource && (this.material.map = et(this.mapSource, 4)), this.normSource && (this.material.normalMap = et(this.normSource, 4));
                }
                setMap(e) {
                    this.material.map = e;
                }
                drawSegment(e) {
                    return (
                        (this.seg = e),
                        (this.drawNode = this.seg.startNode),
                        (this.pi = 0),
                        (this.ui = 0),
                        (this.ni = 0),
                        (this.ox = this.seg.startNode.p.x),
                        (this.oz = this.seg.startNode.p.z),
                        (this.uvDist = 0),
                        (this.side = Math.sign(e.distance)),
                        this.drawNextNode()
                    );
                }
                drawNextNode() {
                    for (
                        Xr.dnp = this.drawNode.p,
                            this.ni > 0
                                ? ((this.bounds.maxX = Math.max(this.bounds.maxX, Xr.dnp.x - this.ox)),
                                  (this.bounds.minX = Math.min(this.bounds.minX, Xr.dnp.x - this.ox)),
                                  (this.bounds.maxY = Math.max(this.bounds.maxY, Xr.dnp.y)),
                                  (this.bounds.minY = Math.min(this.bounds.minY, Xr.dnp.y)),
                                  (this.bounds.maxZ = Math.max(this.bounds.maxZ, Xr.dnp.z - this.oz)),
                                  (this.bounds.minZ = Math.min(this.bounds.minZ, Xr.dnp.z - this.oz)))
                                : ((this.bounds.maxX = Xr.dnp.x - this.ox),
                                  (this.bounds.minX = Xr.dnp.x - this.ox),
                                  (this.bounds.maxY = Xr.dnp.y),
                                  (this.bounds.minY = Xr.dnp.y),
                                  (this.bounds.maxZ = Xr.dnp.z - this.oz),
                                  (this.bounds.minZ = Xr.dnp.z - this.oz)),
                            Xr.j = 0;
                        Xr.j < this.drawNode.ps.length;
                        Xr.j += 2
                    )
                        (Xr.pj = this.drawNode.ps[Xr.j]),
                            (Xr.nj = this.drawNode.ns[Xr.j]),
                            (Xr.x = Xr.pj.x + Xr.nj.x * this.seg.distance),
                            (Xr.x1 = Xr.x + 0.1 * Xr.nj.x * this.side),
                            (Xr.z = Xr.pj.z + Xr.nj.z * this.seg.distance),
                            (Xr.z1 = Xr.z + 0.1 * Xr.nj.z * this.side),
                            (this.posArr[this.pi++] = Xr.x1 - this.ox),
                            (this.posArr[this.pi++] = Xr.pj.y),
                            (this.posArr[this.pi++] = Xr.z1 - this.oz),
                            (this.posArr[this.pi++] = Xr.x - this.ox),
                            (this.posArr[this.pi++] = Xr.pj.y + 0.52),
                            (this.posArr[this.pi++] = Xr.z - this.oz),
                            (this.posArr[this.pi++] = Xr.x - this.ox),
                            (this.posArr[this.pi++] = Xr.pj.y + 0.7200000000000001),
                            (this.posArr[this.pi++] = Xr.z - this.oz),
                            (this.posArr[this.pi++] = Xr.x1 - this.ox),
                            (this.posArr[this.pi++] = Xr.pj.y + Qr),
                            (this.posArr[this.pi++] = Xr.z1 - this.oz);
                    return (
                        this.ni++,
                        (this.drawNode = this.drawNode.next),
                        !(this.drawNode.i < this.seg.endNode.i) &&
                            ((Xr.pj = this.drawNode.p),
                            (Xr.nj = this.drawNode.n),
                            (Xr.x = Xr.pj.x + Xr.nj.x * this.seg.distance),
                            (Xr.z = Xr.pj.z + Xr.nj.z * this.seg.distance),
                            (Xr.x1 = Xr.x + 0.1 * Xr.nj.x * this.side),
                            (Xr.z1 = Xr.z + 0.1 * Xr.nj.z * this.side),
                            (this.posArr[this.pi++] = Xr.x1 - this.ox),
                            (this.posArr[this.pi++] = Xr.pj.y),
                            (this.posArr[this.pi++] = Xr.z1 - this.oz),
                            (this.posArr[this.pi++] = Xr.x - this.ox),
                            (this.posArr[this.pi++] = Xr.pj.y + 0.52),
                            (this.posArr[this.pi++] = Xr.z - this.oz),
                            (this.posArr[this.pi++] = Xr.x - this.ox),
                            (this.posArr[this.pi++] = Xr.pj.y + 0.7200000000000001),
                            (this.posArr[this.pi++] = Xr.z - this.oz),
                            (this.posArr[this.pi++] = Xr.x1 - this.ox),
                            (this.posArr[this.pi++] = Xr.pj.y + Qr),
                            (this.posArr[this.pi++] = Xr.z1 - this.oz),
                            this.mesh.geometry.setDrawRange(0, 5 * this.seg.length * 6 * 3),
                            this.computeBoundingSphere(),
                            (this.mesh.geometry.boundingSphere = this.boundingSphere),
                            this.mesh.position.set(this.ox, -0.1, this.oz),
                            (this.posAttribute.needsUpdate = !0),
                            (this.mesh.visible = !0),
                            this.mesh.updateMatrix(),
                            this.seg.contiguousStart ||
                                ((this.p.x = this.posArr[0] + this.mesh.position.x),
                                (this.p.y = this.posArr[1]),
                                (this.p.z = this.posArr[2] + this.mesh.position.z),
                                Hr.addObject(Zr, this.p, Math.PI + (Math.PI / 2) * this.side - this.seg.startNode.a, this.seg.startNode.i)),
                            !0)
                    );
                }
                retire() {
                    this.mesh.visible = !1;
                }
                computeBoundingSphere() {
                    (Xr.minX = this.bounds.minX),
                        (Xr.maxX = this.bounds.maxX),
                        (Xr.minY = this.bounds.minY),
                        (Xr.maxY = this.bounds.maxY),
                        (Xr.minZ = this.bounds.minZ),
                        (Xr.maxZ = this.bounds.maxZ),
                        (this.boundingSphere.center.x = (Xr.minX + Xr.maxX) / 2),
                        (this.boundingSphere.center.y = (Xr.minY + Xr.maxY) / 2),
                        (this.boundingSphere.center.z = (Xr.minZ + Xr.maxZ) / 2),
                        (this.boundingSphere.radius = Math.sqrt((Xr.maxX - Xr.minX) * (Xr.maxX - Xr.minX) + (Xr.maxY - Xr.minY) * (Xr.maxY - Xr.minY) + (Xr.maxZ - Xr.minZ) * (Xr.maxZ - Xr.minZ)) / 2 + 10);
                }
                static getNorms() {
                    let e = [];
                    for (let t = 0; t < Yr; t++) e.push(0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0);
                    return e;
                }
                static getUV() {
                    let e = [],
                        t = 0;
                    for (let i = 0; i < Yr; i++) (t = 0.4 * i), e.push(t, 0, t, Vr, t, 0.9, t, 1);
                    return e;
                }
                static getGeo() {
                    let e = new r.g();
                    e.setIndex(Jr.getIndex()), e.setAttribute("position", new r.o(new Float32Array(1812), 3)), e.attributes.position.setUsage(r.l), e.setAttribute("uv", new r.o(new Float32Array(Jr.getUV()), 2));
                    let t = new Float32Array(Jr.getNorms());
                    return e.setAttribute("normal", new r.o(t, 3)), e;
                }
                static getIndex() {
                    let e,
                        t,
                        i,
                        s,
                        n,
                        a,
                        o,
                        r,
                        h = [];
                    for (let l = 0; l < Yr; l++) (e = 4 * l), (t = e + 1), (i = e + 2), (s = e + 3), (n = 4 * (l + 1)), (a = n + 1), (o = n + 2), (r = n + 3), h.push(e, t, n, t, a, n, t, i, a, i, o, a, i, s, o, s, r, o);
                    return h;
                }
            }
            class qr extends Tn {
                generate(e) {
                    let t = e.prev;
                    for (e = e.next; this.test(t) && t.prev && t.i > this.prev.endNode.i; ) t = t.prev;
                    for (t.i - this.prev.endNode.i < 4 && (t = this.prev.endNode); this.test(e) && e.i - t.i < Ut; ) e = e.next;
                    let i = new Rn(t, e, this.typeID, (t.w + Ht) * this.side);
                    return this.prev.endNode.i == t.i && this.prev.type == i.type && ((this.prev.contiguousEnd = !0), (i.contiguousStart = !0), (i.distance = this.prev.distance)), i;
                }
                testGenLeft(e) {
                    return !e.bridge && null == e.lWallDist && e.i >= this.prevLeft.endNode.i && (e.g < -1.25 || (e.g < 0 && e.da > 0.25 && e.h < 0.6));
                }
                testGenRight(e) {
                    return !e.bridge && null == e.rWallDist && e.i >= this.prevRight.endNode.i && (e.g > 1.25 || (e.g > 0 && e.da < -0.25 && e.h < 0.6));
                }
                testLeft(e) {
                    return !e.bridge && e.p.y > 3 && (e.g < -0.75 || (e.g < 0.1 && e.da < -0.05 && e.h < 0.6));
                }
                testRight(e) {
                    return !e.bridge && e.p.y > 3 && (e.g > 0.75 || (e.g > -0.1 && e.da > 0.05 && e.h < 0.6));
                }
            }
            const Kr = { Barrier: 0 },
                _r = [Jr];
            var $r = class {
                constructor(e) {
                    (this.stagedSegments = []), (this.activeSegments = []), (this.count = 0), (this.prevWasContiguous = !1), (this.getHeightAt = e), (this.container = new r.G()), (this.segments = []), this.initPools();
                }
                initialise() {
                    (this.renderIndex = $t.vehicleIndex),
                        (this.genNode = $t.vehicleNode),
                        (this.genIndex = $t.vehicleIndex),
                        (this.genNodeLeft = $t.vehicleNode),
                        (this.genNodeRight = $t.vehicleNode),
                        (this.barrierGenerator = new qr($t.vehicleNode, Kr.Barrier)),
                        (this.segments.length = 0);
                    do {
                        this.updateGeneration();
                    } while (this.genIndex < $t.vehicleIndex + Yt);
                    for (; this.segments.length > 0 && $t.vehicleIndex + Vt >= this.segments[0].startNode.i; ) this.drawNextSegment();
                    do {
                        this.updateStaged();
                    } while (this.stagedSegments.length);
                }
                reset(e) {
                    (this.getHeightAt = e), this.resetPools(), this.initialise();
                }
                initPools() {
                    this.pools = [];
                    let e,
                        t,
                        i = Object.keys(Kr).length;
                    for (e = 0; e < i; e++) (t = new _r[e](null, this.getHeightAt)), this.container.add(t.mesh), this.pools.push([t]);
                }
                resetPools() {
                    for (; this.activeSegments.length; ) this.retireSegment(this.activeSegments.shift());
                }
                setSkin(e) {}
                handleMidlineReset() {
                    ($t.tail.i < this.genNodeLeft.i || $t.tail.i < this.genNodeRight.i) &&
                        (console.error("Wall controller must handle reset gracefully"), (this.genNodeLeft = $t.tail), (this.genNodeRight = $t.tail), (this.renderIndex = $t.tail.i));
                }
                updateGeneration() {
                    this.genIndex++,
                        this.genNodeLeft.i < this.genIndex && ((this.genNodeLeft = this.genNodeLeft.next), this.checkGenerateLeftSegment()),
                        this.genNodeRight.i < this.genIndex && ((this.genNodeRight = this.genNodeRight.next), this.checkGenerateRightSegment());
                }
                update() {
                    for (this.updateGeneration(); this.segments.length > 0 && $t.vehicleIndex + Vt >= this.segments[0].startNode.i; ) this.drawNextSegment();
                    if (this.activeSegments.length) for (; $t.vehicleIndex > this.activeSegments[0].endNode.i + 10 && (this.retireSegment(this.activeSegments.shift()), 0 != this.activeSegments.length); );
                }
                updateStaged() {
                    this.stagedSegments.length && this.stagedSegments[0].drawNextNode() && (this.stagedSegments.shift(), (en.walls = this.activeSegments.length + " (" + this.stagedSegments.length + ")"));
                }
                checkGenerateLeftSegment() {
                    this.addLeftSegment(this.barrierGenerator.generateLeft(this.genNodeLeft));
                }
                checkGenerateRightSegment() {
                    this.addRightSegment(this.barrierGenerator.generateRight(this.genNodeRight));
                }
                addRightSegment(e) {
                    if (!e) return;
                    let t = e.startNode;
                    for (; t.i < e.endNode.i; ) (!t.rWallDist || t.rWallDist > e.distance) && ((t.rWallDist = e.distance), (t.wallSide = -1)), (t = t.next);
                    this.segments.push(e);
                }
                addLeftSegment(e) {
                    if (!e) return;
                    let t = e.startNode;
                    for (; t.i < e.endNode.i; ) (!t.lWallDist || t.lWallDist > -e.distance) && ((t.lWallDist = -e.distance), (t.wallSide = 1)), (t = t.next);
                    this.segments.push(e);
                }
                getSegmentObject(e) {
                    let t;
                    if (this.pools[e].length) t = this.pools[e].pop();
                    else {
                        (t = new (0, _r[e])(null, this.getHeightAt)), this.container.add(t.mesh);
                    }
                    return t;
                }
                drawNextSegment() {
                    let e = this.segments.shift(),
                        t = this.getSegmentObject(e.type);
                    t.drawSegment(e) || this.stagedSegments.push(t), (e.obj = t), this.activeSegments.push(e), (en.walls = this.activeSegments.length + " (" + this.stagedSegments.length + ")");
                }
                retireSegment(e) {
                    e.obj.retire(), this.pools[e.type].push(e.obj), (en.walls = this.activeSegments.length + " (" + this.stagedSegments.length + ")");
                }
            };
            const eh = new r.F({ map: null });
            const th = new (class {
                constructor() {
                    (this.loader = new tn.a()), (this.meshes = []), (this.template = null);
                    let e = et(Ko);
                    (eh.map = e), (eh.bumpMap = e), (eh.bumpScale = 0.02);
                }
                getInstancedMesh(e) {
                    let t = new r.u(Rr.rock.geo.clone(), eh, e);
                    return (t.matrixAutoUpdate = !1), t.instanceMatrix.setUsage(r.l), this.template || this.meshes.push(), t;
                }
            })();
            class ih extends eo {
                constructor() {
                    super(), (this.index = 0), (this.mesh = th.getInstancedMesh(jr)), (this.mesh.receiveShadow = !0), (this.retireNodeIndex = -1), (this.showNodeIndex = 0);
                }
            }
            (ih.typeName = "rubble"), (ih.rubbleController = th);
            var sh = new to(ih, jr, kr);
            const nh = new r.G(),
                ah = new Pn(119),
                oh = new Pn(47, 6.28),
                rh = new Pn(119, 0.7, -0.1),
                hh = {},
                lh = (e, t, i, s) => (
                    (hh.x = Math.round(((e - i.x) / zt) * Nr)), (hh.z = Math.round(((t - i.z) / zt) * Nr)), hh.x < 0 ? (hh.x += Nr) : hh.x >= Nr && (hh.x -= Nr), hh.z < 0 ? (hh.z += Nr) : hh.z >= Nr && (hh.z -= Nr), zr[hh.x][hh.z]
                );
            class dh extends si {
                constructor(...e) {
                    super(...e), (this.rubbleProb = 0.05), (this.rubbleProb = 100 / (this.res1 * this.res1));
                }
                lerpHeight(e, t, i) {
                    (i.ga = Math.abs(i.g)), (i.w += Ht + 0.25 * i.ga);
                    let s = 0,
                        n = 16 * (1 - Math.max(0.25, Math.min(0.5, 0.25 * i.ga)));
                    if (i.d < i.w + n)
                        if (i.d < i.w) (s = i.y), i.d < i.w - 1 ? (s += 0.15 * lh(e, t, this.originPos, this.res)) : (s += lh(e, t, this.originPos, this.res) * (1 - (i.w - i.d)));
                        else {
                            let a = Math.max(0, Math.min(1, (i.d - i.w) / n));
                            (a = dh.hockeyLerp(a)), (s = this.heightmap.getXZ(e, t)), (s = s * a + i.y * (1 - a) + lh(e, t, this.originPos, this.res) * Math.max(0, Math.min(1, 1 - (i.d - i.w) / n)));
                        }
                    else s = this.heightmap.getXZ(e, t);
                    return s;
                }
                postProcessRow(e) {
                    sh.active && this.placeRubbleRow(e);
                }
                placeRubbleRow(e) {
                    let t, i, s, n, a, o;
                    for (let r = 0; r < this.res; r++)
                        (t = e * this.res1 + r),
                            (s = this.heights[t]),
                            (i = this.signedRoadProx[t]),
                            (n = [this.norms[3 * t], this.norms[3 * t + 1], this.norms[3 * t + 2]]),
                            (a = i > 0.2 && i < 20 ? (this.grads[t] < 0.1 ? 1 : 0.1 - this.grads[t]) : 0),
                            (o = rh.next()),
                            (a *= Math.abs(this.curves[t])),
                            a * this.rubbleProb > ah.next() &&
                                ((s -= i < Ht ? Ht - i : (i / 20) * 0.2),
                                (s -= 0.1 * o),
                                nh.position.set((this.coords.x + e / this.res) * zt + (ah.next() - 0.5), s - this.grads[t] / 2, (this.coords.z + r / this.res) * zt + (ah.next() - 0.5)),
                                nh.scale.set(o, o, o),
                                (nh.rotation.y = oh.next()),
                                (nh.rotation.x = oh.next()),
                                nh.updateMatrix(),
                                sh.addInstance(this.lod, nh.matrix, 0, this.originIndex, nh.position, n));
                }
                postProcessCell() {}
                display() {
                    super.display(), 1 == this.lod && this.tileset.mesh.visible && sh.updateCurrentInstance(1);
                }
            }
            dh.paved = !1;
            var ch = dh;
            var ph = class extends ri {},
                uh = i.p + "static/media/earthrise.c3eff6a4.webp";
            class gh extends hi {
                constructor(e) {
                    super(),
                        (this.groundMaterial = Sr),
                        (this.nearGridCell = ch),
                        (this.farGridCell = ph),
                        (this.skinList = Object.keys(Lr.skins)),
                        (this.skinIndex = 0),
                        (this.weatherList = Object.keys(Lr.weathers)),
                        (this.weatherIndex = 0),
                        (this.skinWeatherList = []),
                        (this.weatherOverride = !1),
                        (this.topoList = Object.keys(Lr.topography)),
                        (this.topoIndex = 0),
                        (this.ambiantAudio = null),
                        (this.windAudio = null),
                        (this.cachedTextures = { default: {} }),
                        (this.hasRubble = !0),
                        (this.lastVehicleIndex = 0),
                        (this.loadState = { init: !1, assets: !1, walls: !1, reset: !0, progress: 0 }),
                        (this.p = new r.W()),
                        (this.curWeatherIndex = 0),
                        (this.audioLerp = 0),
                        (this.getHeightAt = e),
                        (this.container = new r.G()),
                        (this.config = Lr);
                }
                updateConfig(e, t) {
                    Mr(e, t), sh.revert(jr, kr);
                }
                destroy() {
                    var e, t;
                    Hr.destroy(),
                        null === (e = this.ambientAudio) || void 0 === e || e.stop(),
                        null === (t = this.windAudio) || void 0 === t || t.stop(),
                        this.container.traverse((e) => {
                            e.isMesh && e.geometry.dispose();
                        }),
                        this.container.clear();
                    for (let i in this.cachedTextures)
                        for (let e in this.cachedTextures[i])
                            if (this.cachedTextures[i][e].isTexture) this.cachedTextures[i][e].dispose();
                            else for (let t in this.cachedTextures[i][e]) this.cachedTextures[i][e][t].isTexture && this.cachedTextures[i][e][t].dispose();
                    delete this.cachedTextures, this.destroyAssets(), sh.destroy();
                }
                initialise(e, t, i) {
                    var s;
                    this.seed = e;
                    let n = t.topography;
                    (this.topoIndex = this.topoList.indexOf(n)),
                        null === (s = this.heightmap) || void 0 === s || s.destroy(),
                        (this.heightmap = new Fo(e, Lr.topography[n].heightmap)),
                        (this.loadState.init = !1),
                        (this.loadState.progress = 0),
                        xt(Lr.topography[n].smoothWindow),
                        Zt(Lr.topography[n].roadWidth),
                        (this.hasRubble = Ih.value.detailLodIndex > 0),
                        this.loadState.assets || new Tr(Rr, this.onAssetsLoaded.bind(this)),
                        i();
                }
                onGridReady() {
                    sh.updateVisible();
                }
                reset(e, t, i) {
                    (this.loadState.reset = !1),
                        this.initialise(e, t, () => {
                            (this.loadState.init = !0), i();
                        });
                }
                destroyAssets() {
                    for (let e in Rr) Rr[e].geo.dispose();
                }
                onAssetsLoaded(e) {
                    for (let t in Rr) Rr[t].geo = e[t].children[0].geometry;
                    sh.revert(jr, kr), (this.loadState.assets = !0);
                }
                loader() {
                    return this.loadState.init
                        ? this.loadState.assets
                            ? this.loadState.walls
                                ? (this.loadState.reset || ((this.lastVehicleIndex = $t.vehicleIndex), this.wallController.reset(this.getHeightAt), Hr.reset(this.getHeightAt), (this.loadState.reset = !0)), sh.revert(jr, kr), 1)
                                : ((this.wallController = new $r(this.getHeightAt)), this.wallController.initialise(), this.container.add(this.wallController.container), (this.loadState.walls = !0), 0.9)
                            : ((this.loadState.walls = !1), 0.7)
                        : ((this.lastVehicleIndex = $t.vehicleIndex),
                          this.earthrise ||
                              ((this.earthrise = new r.B(new r.J(10, 10), new r.C({ map: et(uh), fog: !1, depthTest: !1, alphaTest: 0.5, side: r.k }))),
                              (this.earthrise.renderOrder = -1),
                              (this.earthrise.rotation.y = -Math.PI / 2),
                              this.container.add(this.earthrise)),
                          Hr.initialise(this.getHeightAt),
                          this.container.add(Hr.container),
                          this.hasRubble && this.container.add(sh.container),
                          (sh.active = this.hasRubble),
                          (this.loadState.init = !0),
                          0.3);
                }
                handleMidlineReset() {
                    this.wallController.handleMidlineReset();
                }
                update() {
                    if ((this.earthrise.visible && ((this.earthrise.position.x = Hs.position.x + 100), (this.earthrise.position.y = Hs.position.y + 15), (this.earthrise.position.z = Hs.position.z)), $t.vehicleIndexDidChange))
                        do {
                            this.lastVehicleIndex++, this.wallController.update(), Hr.update(), this.hasRubble && sh.updateVisible();
                        } while (this.lastVehicleIndex < $t.vehicleIndex);
                    this.wallController.updateStaged();
                }
                nextSkin() {
                    this.setSkin(this.skinList[++this.skinIndex % this.skinList.length]);
                }
                setTopography(e) {
                    window.localStorage.setItem("config-scene-topography", e);
                }
                nextTopography() {
                    this.setTopography(this.topoList[++this.topoIndex % this.topoList.length]);
                }
                loadGroundMaterialSkin(e, t, i, s, n = 4) {
                    this.skin[e] ? (i[e] || (i[e] = et(this.skin[e], n)), (Sr.userData[t].value = i[e])) : (s[e] || (s[e] = et(Lr.skins.default[e], n)), (Sr.userData[t].value = s[e]));
                }
                getSkinName(e) {
                    var t;
                    return (null === (t = Lr.skins[e]) || void 0 === t ? void 0 : t.name) || e;
                }
                setScene(e) {
                    this.setSkin(e.skin), this.setWeatherIndex(e.weatherIndex % this.skinWeatherList.length);
                }
                sanitiseConfig(e) {
                    super.sanitiseConfig(e), e.set("weatherIndex", 0, !0);
                }
                setSkin(e) {
                    (this.skinName = e), (this.earthrise.visible = "moon" == e);
                    let t = Lr.skins.default;
                    (this.skin = Lr.skins[e]), this.cachedTextures[e] || (this.cachedTextures[e] = {});
                    let i = this.cachedTextures[e],
                        s = this.cachedTextures.default;
                    this.loadGroundMaterialSkin("surface", "surfaceMap", i, s),
                        this.loadGroundMaterialSkin("subSurface", "subSurfaceMap", i, s),
                        this.loadGroundMaterialSkin("shale", "shaleMap", i, s, 8),
                        this.loadGroundMaterialSkin("gravel", "gravelMap", i, s),
                        this.loadGroundMaterialSkin("rock", "rockMap", i, s),
                        this.loadGroundMaterialSkin("cliff", "cliffMap", i, s),
                        this.loadGroundMaterialSkin("roadBase", "roadBaseMap", i, s),
                        (Sr.uniformsNeedUpdate = !0),
                        this.skin.road ? (i.road || (i.road = et(this.skin.road, 8)), (Qt.map = i.road)) : (s.road || (s.road = et(t.road, 8)), (Qt.map = s.road)),
                        this.skin.rubble ? (i.rubble || (i.rubble = et(this.skin.rubble, 2)), (sh.container.visible = !0), (eh.map = i.rubble)) : (sh.container.visible = !1),
                        this.skin.walls
                            ? (i.walls || (i.walls = {}),
                              s.walls || (s.walls = {}),
                              (Ur.visible = !0),
                              "barrier" in this.skin.walls
                                  ? (null == this.skin.walls.barrier && (Ur.visible = !1), i.walls.barrier || (i.walls.barrier = et(this.skin.walls.barrier, 4)), (Ur.map = i.walls.barrier))
                                  : (s.walls.barrer || (s.walls.barrier = et(t.walls.barrier, 4)), (Ur.map = s.walls.barrier)))
                            : (s.walls || (s.walls = {}), s.walls.barrier || (s.walls.barrier = et(t.walls.barrier, 4)), (Ur.map = s.walls.barrier)),
                        this.skin.friction ? (Pt(this.skin.friction.road), Bt(this.skin.friction.side), Et(this.skin.friction.grass)) : (Pt(1.4), Bt(0.95), Et(0.85)),
                        (this.weatherOverride = !1),
                        this.skin.weathers
                            ? ((this.weatherOverride = !0), (this.skinWeatherList = this.skin.weathers), this.setWeather(this.skinWeatherList[this.curWeatherIndex % this.skinWeatherList.length]))
                            : this.setWeather(this.weatherList[this.curWeatherIndex % this.weatherList.length]);
                }
                setWeatherIndex(e) {
                    (this.curWeatherIndex = e), this.weatherOverride ? this.setWeather(this.skinWeatherList[e]) : this.setWeather(this.weatherList[e]);
                }
                nextWeather() {
                    this.weatherOverride ? this.setWeather(this.skinWeatherList[++this.weatherIndex % this.skinWeatherList.length]) : this.setWeather(this.weatherList[++this.weatherIndex % this.weatherList.length]);
                }
                updateAudio() {
                    var e, t;
                    (this.t = Math.min(1, Hs.speed / 35)),
                        (this.t *= this.t),
                        (this.audioLerp = 0.9 * this.audioLerp + 0.1 * this.t),
                        null === (e = this.ambientAudio) || void 0 === e || e.setVolume(1 - this.audioLerp),
                        null === (t = this.windAudio) || void 0 === t || t.setVolume(0.8 * this.audioLerp);
                }
                setWeather(e) {
                    var t, i, s, n;
                    this.weather = Lr.weathers[e];
                    let a = Lr.weathers.default;
                    this.ambientAudio && this.ambientAudio.stop();
                    let o = (null === (t = this.weather) || void 0 === t || null === (i = t.audio) || void 0 === i ? void 0 : i.ambiance) || a.audio.ambiance;
                    null !== o.src &&
                        ue.getAudio(o.src, (e) => {
                            this.ambientAudio && this.ambientAudio.stop(), e.setLoop(!0), e.setLoopStart(o.ls), e.setLoopEnd(e.buffer.duration - o.le), (this.ambientAudio = e), e.setVolume(0), e.play();
                        }),
                        this.windAudio && this.windAudio.stop();
                    let r = (null === (s = this.weather) || void 0 === s || null === (n = s.audio) || void 0 === n ? void 0 : n.wind) || a.audio.wind;
                    null !== r.src &&
                        ue.getAudio(r.src, (e) => {
                            e.setLoop(!0), e.setLoopStart(r.ls), e.setLoopEnd(e.buffer.duration - r.le), (this.windAudio = e), e.setVolume(0), e.play();
                        }),
                        (vt.intensity = this.weather.amb),
                        vt.color.setHex(this.weather.col),
                        (ft.intensity = this.weather.hem),
                        ft.color.setHex(this.weather.hemTop || this.weather.col),
                        ft.groundColor.setHex(this.weather.hemGround || this.weather.col),
                        (wt.intensity = this.weather.dir),
                        wt.color.setHex(this.weather.col),
                        wt.sunOffset.fromArray(this.weather.sunPos || [0, 100, 0]),
                        fe.setHeadlightColour(this.weather.headlightColour || 16777215),
                        bt.setHex(this.weather.col),
                        lt(this.weather.col, St * this.weather.fogNear, St * this.weather.fogFar),
                        this.cachedTextures[e] || (this.cachedTextures[e] = {});
                    let h = this.cachedTextures[e],
                        l = this.cachedTextures.default;
                    (Xt.userData.hasClouds.value = !0),
                        "skyMap" in this.weather
                            ? null == this.weather.skyMap
                                ? (Xt.userData.hasClouds.value = !1)
                                : (h.skyMap || (h.skyMap = et(this.weather.skyMap, 2)), (Xt.map = h.skyMap))
                            : (l.skyMap || (l.skyMap = et(a.skyMap, 2)), (Xt.map = l.skyMap)),
                        this.weather.skyCol
                            ? (Xt.userData.nearCol.value.setHex(this.weather.skyCol), Xt.userData.farCol.value.setHex(this.weather.skyColFar))
                            : (Xt.userData.nearCol.value.setHex(a.skyCol), Xt.userData.farCol.value.setHex(a.skyColFar)),
                        fe.setHeadlights(!!this.weather.headlights);
                }
            }
            (gh.config = Lr), (gh.sceneName = "Planet"), (gh.hasTrees = !1), (gh.hasGrass = !1);
            const mh = { Hills: Bo, Planet: gh },
                xh = ["Hills", "Planet"],
                vh = ["straight", "casual", "easy", "normal", "hard"],
                fh = [0.5, 0.75, 1, 1.5, 2],
                wh = {
                    seed: "seed",
                    sceneName: "config-scene-name",
                    topography: "config-scene-topography",
                    skin: "config-scene-skin",
                    weatherIndex: "config-scene-weather-index",
                    viewLodIndex: "config-view-lod-index",
                    detailLodIndex: "config-detail-lod-index",
                    antialias: "config-antialias",
                    renderScale: "config-render-scale",
                    verticalFov: "config-vertical-fov",
                },
                bh = { seed: Be, sceneName: "Hills", topography: "normal", skin: "winter", weatherIndex: 2, viewLodIndex: 2, detailLodIndex: 1, antialias: !0, renderScale: 2, verticalFov: 68 },
                Ah = {
                    viewLodIndex: { readable: "View Distance", type: u.Enum, labels: ["Low", "Medium", "High", "Ultra", "Ultra+"], onSet: (e) => yh.set("viewLodIndex", e) },
                    detailLodIndex: { readable: "Environment Detail", type: u.Enum, labels: ["Low", "Medium", "High", "Ultra"], onSet: (e) => yh.set("detailLodIndex", e) },
                    renderScale: { readable: "Render Scale", type: u.Enum, labels: ["50%", "75%", "100%", "150%", "200%"], onSet: (e) => yh.set("renderScale", e) },
                    verticalFov: { readable: "Vertical FOV", type: u.FloatRange, default: 68, min: 40, max: 80, precision: 0, onSet: (e) => yh.set("verticalFov", e) },
                };
            const yh = new (class extends p {
                constructor() {
                    super(), (this.value = { ...bh }), (this.initialValue = { ...bh }), (this.initialNode = 0), (this.accumulatedProgress = 0), (this.sceneMeta = {}), this.buildSceneMeta(), this.loadConfig(), this.loadProgress();
                    let e = window.location.search.substring(1).split("&");
                    for (let t of e) {
                        let e = t.split("=");
                        if ("node" == e[0])
                            try {
                                let t = parseInt(e[1]);
                                !isNaN(t) && t > 0 && ((this.initialNode = t), console.log("Overwriting initial node from QS: ", e[1]));
                            } catch (Au) {
                                console.error("Failed to load initial node from QS:", e[1]);
                            }
                        else
                            "topo" == e[0] &&
                                (vh.includes(e[1]) || "flat" === e[1]
                                    ? (this.set("topography", e[1], !0), console.log("Overwriting topography from QS: ", e[1]))
                                    : (console.warn("Invalid topo parameter; reverting to 'normal'"), this.set("topography", "normal", !0)));
                    }
                }
                resetMemory() {
                    console.log("Resetting config to defaults");
                    for (let e in this.value) window.localStorage.setItem(wh[e], bh[e]);
                }
                buildSceneMeta() {
                    let e,
                        t = { current: bh.sceneName, hasCycles: !1, scenes: {} };
                    for (let i in mh) {
                        (e = mh[i].config), (t.scenes[i] = { topography: Object.keys(e.topography), skins: Object.keys(e.skins) });
                        let s = {},
                            n = {};
                        for (let a in e.skins) (s[a] = e.skins[a].weathers.slice()), (n[a] = e.skins[a].name), (t.scenes[i].hasCycles = t.hasCycles || void 0 !== e.skins[a].cycles);
                        (t.scenes[i].skinWeathers = s), (t.scenes[i].skinNames = n);
                    }
                    return (this.sceneMeta = t), this.sceneMeta;
                }
                set(e, t, i = !1) {
                    i || !d.value
                        ? ("verticalFov" == e &&
                              ((It = t),
                              (Mt = St / Math.cos(((It * (Math.PI / 180)) / 2) * (window.screen.availWidth / window.screen.availHeight))),
                              (Mt = St / Math.cos(((It * (Math.PI / 180)) / 2) * (window.screen.availWidth / window.screen.availHeight)))),
                          super.set(e, t, i),
                          window.localStorage.setItem(wh[e], t))
                        : console.warn("Preventing config update to " + e + " during load");
                }
                loadConfig() {
                    let e, t;
                    for (t in this.value) {
                        if (((e = window.localStorage.getItem(wh[t]) || bh[t]), "sceneName" == t)) e in mh || (console.warn("Loaded unrecognsied scene name " + e + ", restoring default"), (e = bh.sceneName)), (this.sceneMeta.current = e);
                        else
                            try {
                                e = JSON.parse(e);
                            } catch (Au) {}
                        console.log("SceneConfig: Load ", t, e), this.set(t, e, !0), (this.initialValue[t] = e);
                    }
                }
                revertProgress() {
                    this.saveProgress(0, 0), (this.saveProgress = () => {});
                }
                saveProgress(e = 0, t = null) {
                    let i = this.getConfigKey();
                    window.localStorage.setItem(i + "_node", Math.max(0, e - 5)), null !== t && window.localStorage.setItem(i + "_progress", t);
                }
                loadProgress() {
                    this.convertLegacyProgress(), (this.initialNode = 0), (this.accumulatedProgress = 0);
                    let e = this.getConfigKey(),
                        t = e + "_node";
                    if (localStorage.getItem(t)) {
                        let e = parseInt(localStorage.getItem(t));
                        e && (this.initialNode = e);
                    }
                    let i = e + "_progress";
                    if (localStorage.getItem(i)) {
                        let e = parseInt(localStorage.getItem(i));
                        e && (this.accumulatedProgress = e);
                    }
                    if (localStorage.getItem("restore-progress")) {
                        let e = 0;
                        try {
                            (e = parseInt(localStorage.getItem("restore-progress"))),
                                e > 0 && ((this.accumulatedProgress += e), localStorage.setItem(i, this.accumulatedProgress), console.log("Storing accumulated progress ", e, this.accumulatedProgress));
                        } catch (Au) {}
                        localStorage.removeItem("restore-progress");
                    }
                    console.log("Loaded node and progress " + this.initialNode + ", " + this.accumulatedProgress + " for confKey " + e);
                }
                convertLegacyProgress() {
                    try {
                        let e,
                            t,
                            i,
                            s,
                            n = JSON.parse(localStorage.getItem("analytics_seeds")),
                            a = ["easy", "normal", "hard"];
                        for (t of n)
                            if (t)
                                for (i of ((e = t.toString()), a))
                                    (s = e + "?" + i),
                                        localStorage.getItem(s) && (console.log("Converting legacy progress for seed ", e, i), localStorage.setItem(e + "_Hills_" + i + "_node", localStorage.getItem(s)), localStorage.removeItem(s));
                    } catch (Au) {}
                }
                getConfigKey() {
                    return this.value.seed + "_" + this.value.sceneName + "_" + this.value.topography;
                }
            })();
            var Ih = yh;
            const Sh = 0.3,
                Mh = window.localStorage.getItem("settings-camera-mode") || 0;
            var Dh = i(15);
            const kh = "analytics_returningPlayer",
                Ch = "analytics_lastActive",
                jh = { newUser: null == localStorage.getItem(kh), lastActiveTime: localStorage.getItem(Ch) };
            var Nh = jh;
            var zh = new (class {
                constructor() {
                    (this.speed = 0), (this.dist = 0);
                }
                cosntructor() {
                    this.reset();
                }
                reset() {
                    (this.speed = 0), (this.dist = 0);
                }
            })();
            var Oh = new (class extends l {})(),
                Lh = new l(null);
            const Rh = "https://34.250.221.219:443",
                Th = "initialise",
                Ph = "feedback",
                Gh = "analytics_returningPlayer",
                Bh = "analytics_totalTime",
                Wh = "analytics_totalDist",
                Eh = "analytics_seeds",
                Fh = "analytics_disable",
                Zh = "analytics_lastVisit",
                Hh = "analytics_lastActive",
                Qh = "analytics_revisits",
                Yh = "analytics_sessions",
                Vh = "analytics_stickySteer";
            var Uh = new (class {
                constructor() {
                    (this.socket = null),
                        (this.connected = !1),
                        (this.playerProfile = {}),
                        (this.midlineLoadTime = 0),
                        (this.envLoadTime = 0),
                        (this.startTime = Date.now()),
                        (this.onTickerStateChangedBound = this.onTickerStateChanged.bind(this)),
                        (this.doInitialiseAnalytics = !1),
                        (this.analyticsInitialised = !1),
                        oe.addStateListener(this.onTickerStateChangedBound),
                        ce.addListener((e) => {
                            this.sendUpdate("autodrive", e);
                        }),
                        this.loadPlayerProfile(),
                        this.initialiseConnection();
                }
                onTickerStateChanged(e) {
                    this.connected && this.sendUpdate("paused", e);
                }
                checkLocation(e) {
                    var t = new XMLHttpRequest();
                    t.open("GET", "https://ipapi.co/json"),
                        t.setRequestHeader("Content-Type", "application/json"),
                        (t.timeout = 3e3),
                        t.send(null),
                        (t.onreadystatechange = function () {
                            if (4 === t.readyState && 200 === t.status)
                                try {
                                    var i = JSON.parse(t.response);
                                    console.log("Analytics: Got location of ", i.country_name), e({ country: i.country, city: i.city, region: i.region });
                                } catch (Au) {
                                    e({ country: "unknown", city: "unknown", region: "unknown" });
                                }
                        });
                }
                initialiseConnection() {
                    if (window.localStorage.getItem("analytics-disabled")) return console.log("Analytics: Disabled; will not connect"), window.localStorage.removeItem("unsent-feedback"), void (this.socket = { emit: () => {} });
                    this.connected ||
                        (console.log("Analytics: Initialising socket"),
                        (this.socket = Object(Dh.a)(Rh, { reconnection: !1, rejectUnauthorized: !1 })),
                        this.socket.on("connect", () => {
                            console.log("Analytics: Connected"), (this.connected = !0), this.doInitialiseAnalytics && this.initialiseAnalytics(), U() && this.sendUpdate("mobile", !0);
                        }),
                        this.socket.on("pre_initialise", (e) => {
                            console.log("Got cumulative meters as ", e.cumulativeMeters), Lh.set(e.cumulativeMeters);
                            let t = document.getElementById("splash-player-count");
                            t && e.playerCount && (t.innerHTML = e.playerCount + " playing &#183; "),
                                e.latestVersion &&
                                    ((e, t) => {
                                        if (e === t) return 0;
                                        let i = _s(t),
                                            s = _s(e);
                                        return 1e5 * s.major + 1e4 * s.minor + 1e3 * s.patch + 10 * s.release + s.releaseVersion > 1e5 * i.major + 1e4 * i.minor + 1e3 * i.patch + 10 * i.release + i.releaseVersion ? 1 : -1;
                                    })(e.latestVersion, $s) > 0 &&
                                    (console.log("! Version out of date - prompting refresh"), (document.getElementById("update-alert").style.display = "block"));
                        }),
                        this.socket.on("connect_error", (e) => {
                            console.error("Analytics: Connection failed"), console.error(e), (this.connected = !1);
                        }),
                        Oh.set(this.socket));
                }
                initialiseAnalytics() {
                    if (this.getStorage(Fh)) return;
                    if (this.analyticsInitialised) return;
                    if (((window.onbeforeunload = () => this.savePlayerProfile()), !this.connected)) return void (this.doInitialiseAnalytics = !0);
                    let e = { sceneConfig: { seed: Be, ...Ih.value, initNode: Ih.initialNode, accumProg: Ih.accumulatedProgress }, vehConfig: Pe.value, playerProfile: this.playerProfile };
                    "default" == Ih.value.skin && ("Planet" == Ih.value.sceneName ? (e.sceneConfig.skin = "mars") : (e.sceneConfig.skin = "summer")),
                        window.localStorage.getItem("analytics-nowrite") && (e.playerProfile.noWriteAnalytics = !0),
                        this.socket.emit(Th, e),
                        this.sendCachedFeedback(),
                        (this.analyticsInitialised = !0);
                }
                loadPlayerProfile() {
                    let e = {
                        totalTime: 0,
                        totalDist: 0,
                        seeds: [],
                        browser: this.checkBrowser(),
                        resolution: { w: window.screen.width, h: window.screen.height },
                        midlineLoadTime: this.midlineLoadTime,
                        envLoadTime: this.envLoadTime,
                        visitTime: Date.now(),
                        revisitCount: 0,
                        isRevisit: !1,
                        lastVisit: null,
                        cameraMode: "Chase",
                        isMobile: U(),
                        version: $s,
                        sessionCount: 1,
                        stickySteerCount: 0,
                        pixelRatio: window.devicePixelRatio,
                    };
                    if (((e.returningPlayer = !Nh.newUser), (e.totalTime = 0), e.returningPlayer))
                        if (
                            ((e.totalTime = this.getStorage(Bh, parseInt) || 0),
                            (e.totalDist = this.getStorage(Wh, parseInt) || 0),
                            (e.seeds = this.getStorage(Eh) || []),
                            (e.lastVisit = this.getStorage(Zh, parseInt) || null),
                            (e.lastActive = this.getStorage(Hh, parseInt) || null),
                            (e.revisitCount = this.getStorage(Qh, parseInt) || 0),
                            (e.sessionCount = this.getStorage(Yh, parseInt) || 1),
                            (e.stickySteerCount = this.getStorage(Vh, parseInt) || 0),
                            e.sessionCount++,
                            e.lastActive)
                        ) {
                            Date.now() - e.lastActive > 3e4 && (e.revisitCount++, (e.isRevisit = !0));
                        } else e.revisitCount++, (e.isRevisit = !0);
                    return (this.playerProfile = e), this.recordSeed(Be), this.playerProfile;
                }
                recordSeed(e) {
                    this.playerProfile.seeds.includes(e) || this.playerProfile.seeds.push(e);
                }
                savePlayerProfile() {
                    this.playerProfile &&
                        ((this.playerProfile.totalDist += zh.dist),
                        this.setStorage(Gh, !0),
                        this.setStorage(Bh, Math.floor(this.playerProfile.totalTime + 1e3 * oe.playTime)),
                        this.setStorage(Wh, this.playerProfile.totalDist),
                        this.setStorage(Eh, this.playerProfile.seeds),
                        this.setStorage(Zh, this.playerProfile.visitTime),
                        this.setStorage(Hh, Date.now()),
                        this.setStorage(Qh, this.playerProfile.revisitCount),
                        this.setStorage(Yh, this.playerProfile.sessionCount),
                        this.setStorage(Vh, this.playerProfile.stickySteerCount));
                }
                sendFeedback(e) {
                    if (this.connected) this.sendUpdate(Ph, e);
                    else {
                        let t = [];
                        if (window.localStorage.getItem("unsent-feedback"))
                            try {
                                t = JSON.parse(window.localStorage.getItem("unsent-feedback"));
                            } catch (Au) {
                                t = [];
                            }
                        t.push(e), window.localStorage.setItem("unsent-feedback", JSON.stringify(t));
                    }
                }
                sendCachedFeedback() {
                    let e = [];
                    if (window.localStorage.getItem("unsent-feedback"))
                        try {
                            e = JSON.parse(window.localStorage.getItem("unsent-feedback"));
                            for (let t of e) this.sendUpdate(Ph, t);
                        } catch (Au) {
                            console.error("Could not write unsent feedback from prior session");
                        }
                    window.localStorage.removeItem("unsent-feedback");
                }
                sendUpdate(e, t) {
                    var i;
                    null === (i = this.socket) || void 0 === i || i.emit(e, t);
                }
                getStorage(e, t = null) {
                    let i = null;
                    try {
                        (i = JSON.parse(window.localStorage.getItem(e))), "function" === typeof t && (i = t(i));
                    } catch (Au) {
                        console.warn("Could not parse analytics item ", e), console.log(window.localStorage.getItem(e)), console.log(Au), window.localStorage.removeItem(e);
                    }
                    return i;
                }
                setStorage(e, t) {
                    void 0 !== t && ("number" === typeof t && isNaN(t) ? console.warn("Attempting to store NaN value ", e) : window.localStorage.setItem(e, JSON.stringify(t)));
                }
                checkBrowser() {
                    return -1 != (navigator.userAgent.indexOf("Opera") || navigator.userAgent.indexOf("OPR"))
                        ? "Opera"
                        : -1 != navigator.userAgent.indexOf("Edg")
                        ? "Edge"
                        : -1 != navigator.userAgent.indexOf("Chrome")
                        ? "Chrome"
                        : -1 != navigator.userAgent.indexOf("Safari")
                        ? "Safari"
                        : -1 != navigator.userAgent.indexOf("Firefox")
                        ? "Firefox"
                        : -1 != navigator.userAgent.indexOf("MSIE") || 1 == !!document.documentMode
                        ? "IE"
                        : "unknown";
                }
                logStickySteer() {
                    this.playerProfile.stickySteerCount++, this.sendUpdate("stickySteer", this.playerProfile.stickySteerCount);
                }
            })();
            var Xh = new r.P();
            const Jh = new r.C({ color: 110832, fog: !1, depthTest: !1 });
            r.G;
            class qh extends r.G {
                constructor(e) {
                    super();
                    let t = new r.S(0.5, 8, 8);
                    (this.mesh = new r.B(t, Jh.clone())),
                        (null === e || void 0 === e ? void 0 : e.scale) && this.scale.set(e.scale, e.scale, e.scale),
                        (null === e || void 0 === e ? void 0 : e.color) && this.mesh.material.color.setHex(e.color),
                        this.add(this.mesh),
                        Xh.add(this);
                }
            }
            const Kh = Math.floor(mt / 2);
            let _h = !1;
            const $h = 10,
                el = (Ih.value.topography, 0.463),
                tl = 10,
                il = 2,
                sl = 0.18,
                nl = {},
                al = { vecA: new r.W(), vecB: new r.W() };
            var ol = class {
                constructor(e = !1) {
                    (this.lineMat = new r.w({ color: 16724787 })),
                        (this.lineIndex = 0),
                        (this.head = null),
                        (this.tail = null),
                        (this.discretisedTail = null),
                        (this.origin = new r.W()),
                        (this.prevOriginSide = 0),
                        (this.originOverflow = 0),
                        (this.antiTarget = new r.W()),
                        (this.antiTargetRevert = 40),
                        (this.antiTargetRange = 0),
                        (this.antiTargetDebug = _h ? new qh({ color: 16711935, scale: 10 }) : null),
                        (this.antiTargetTrigger = 0),
                        (this.antiTargetTriggerPoint = new r.W()),
                        (this.antiTargetTriggerCount = 0),
                        (this.antiWeight = 0),
                        (this.antiResetIndex = 0),
                        (this.maxRetractIndex = 0),
                        (this.bridging = !1),
                        (this.antiBridgePoint = new r.W()),
                        (this.bridge = { landing: new r.W(), distance: 0, spawnNode: null }),
                        (this.turnTrackers = [
                            { i: 0, m: 15, r: 15, n: null, a: 3.3, da: 0, o: 0 },
                            { i: 1, m: 30, r: 10, n: null, a: 3.3, da: 0, o: 0.5 },
                            { i: 2, m: 60, r: 15, n: null, a: 3.4, da: 0, o: 0.75 },
                            { i: 3, m: 120, r: 20, n: null, a: 3.6, da: 0, o: 0.8 },
                        ]),
                        (this.trackIndex = null),
                        (this.vehicleDebug = _h ? new qh({ color: 16711680, scale: 0.5 }) : null),
                        (this.antiDir = new r.W()),
                        (this.originDir = new r.W(0, 0, 1)),
                        (this.midlineDir = new r.W()),
                        (this.midlineOrth = new r.W()),
                        (this.isStraight = !1),
                        (this.hasInitGeneration = !1),
                        (this.generationResets = 0),
                        (this.hasInitSmoothing = !1),
                        (this.hasInitDiscretisation = !1),
                        (this.loaderIteration = 0),
                        (this.tVec = new r.W()),
                        (this.h1 = 0),
                        (this.h2 = 0),
                        (this.feelDir = new r.W(1, 0, 0.5)),
                        (this.feelLeft = _h ? new qh({ color: 255, scale: 1 }) : null),
                        (this.feelRight = _h ? new qh({ color: 16711680, scale: 1 }) : null),
                        (this.prevT = 0),
                        (this.byWater = !1),
                        (this.waterFactor = 0),
                        (this.closestApproach = 0),
                        (this.trackRevertCount = 0),
                        (this.allowEmergencyBridge = !1),
                        (this.landing = new r.W()),
                        (this.smoothWindowHead = null),
                        (this.doUpdate = 0),
                        (this.didExtend = !1),
                        (this.lineOrigin = new r.W()),
                        (this.container = new r.G()),
                        (_h = !1),
                        _h &&
                            ((this.lineArr = new Float32Array(15e4)),
                            (this.lineGeo = new r.g()),
                            this.lineGeo.setAttribute("position", new r.f(this.lineArr, 3)),
                            (this.lineGeo.attributes.position.updateRange.count = 0),
                            (this.line = new r.v(this.lineGeo, this.lineMat)),
                            this.container.add(this.line)),
                        (this.isStraight = "straight" == Ih.value.topography);
                }
                initialise(e, t, i) {
                    return (
                        (this.heightmap = t),
                        (this.hasInitGeneration = !1),
                        (this.generationResets = 0),
                        (this.hasInitSmoothing = !1),
                        (this.hasInitDiscretisation = !1),
                        (this.loaderIteration = 0),
                        (this.maxResets = Ih.initialNode / 30 + 50),
                        ($t.vehicleIndex = 0),
                        ($t.vehicleIndexDidChange = !0),
                        this.reset(e, i)
                    );
                }
                loader() {
                    if (!this.hasInitGeneration) {
                        if ($t.tail.i < Ih.initialNode + ct) {
                            if ((this.extendMidline() || this.generationResets++, 320 == this.antiTargetRevert || this.generationResets > this.maxResets || null == $t.tail.prev)) {
                                if (((this.generationResets = 0), (this.antiTargetRevert = 15), console.error("Bad seed ", $t.head.a), delete $t.head.next, ($t.head.next = null), ($t.head.a += this.rand()), $t.head.a > 6.28)) return -1;
                                for (nl.tracker of (this.originDir.set(Math.cos($t.head.a), 0, Math.sin($t.head.a)), ($t.tail = $t.head), (this.smoothWindowHead = $t.head), this.turnTrackers)) (nl.tracker.n = $t.head), (nl.tracker.da = 0);
                                this.resetBridgeState(), (this.bridging = !1), (this.trackRevertCount = 0), (this.antiTargetRevert = 0);
                            }
                        } else {
                            for (this.hasInitGeneration = !0, nl.n = $t.head, nl.i = 0; nl.i <= Kh; nl.i++)
                                (nl.h = { i: 0 - (nl.i + 1), p: $t.head.p.clone(), c: $t.head.c.clone(), h: 0, next: nl.n, prev: null }), (nl.n.prev = nl.h), (nl.n = nl.n.prev);
                            this.smoothWindowHead = nl.n;
                        }
                        return $t.tail.i - $t.head.i > ct && (($t.head = $t.head.next), delete $t.head.prev, ($t.head.prev = null), ($t.vehicleNode = $t.head)), ($t.tail.i / (Ih.initialNode + ct)) * 0.8;
                    }
                    return this.hasInitSmoothing
                        ? this.hasInitDiscretisation
                            ? void 0
                            : $t.discretisedTail.i < $t.vehicleIndex + gt
                            ? (this.discretiseNext(), 0.9 + ($t.discretisedTail.i / ($t.vehicleIndex + gt)) * 0.0999)
                            : ((this.hasInitDiscretisation = !0), 1)
                        : (this.smoothWindowHead.i < $t.tail.i - mt ? this.smoothHeight() : ((this.hasInitSmoothing = !0), delete $t.head.prev, this.resetDiscretised()), 0.8 + (this.smoothWindowHead.i / ($t.tail.i - mt)) * 0.1);
                }
                finalise() {
                    for ($t.vehicleNode = $t.head, nl.i = 0; nl.i < 5; nl.i++) $t.vehicleNode = $t.vehicleNode.next;
                    ($t.vehicleIndex = $t.vehicleNode.i), ($t.vehicleIndexDidChange = !0);
                }
                destroy() {
                    this.revert(), _h && this.lineGeo.dispose();
                }
                revert() {
                    for (nl.t of (delete $t.head, delete $t.discretisedTail, delete $t.tail, delete $t.vehicleNode, this.turnTrackers)) nl.t.n = null;
                }
                reset(e, t) {
                    for (nl.tracker of (this.revert(),
                    (this.rand = new window.alea(e)),
                    ($t.head = {
                        i: 0,
                        p: new r.W(t.x, this.heightmap.getXZ(t.x, t.z, this.heightmap.midlineDepth), t.z),
                        n: { x: 1, z: 0 },
                        a: Math.PI / 2,
                        da: 0,
                        t: 0,
                        c: new r.W(),
                        w: Ft,
                        g: 0,
                        gfa: 0,
                        h: 0,
                        ps: null,
                        ns: null,
                        next: null,
                        prev: null,
                    }),
                    ($t.tail = $t.head),
                    ($t.vehicleNode = $t.head),
                    ($t.vehicleIndex = $t.head.i),
                    ($t.vehicleIndexDidChange = !0),
                    this.originDir.set(Math.cos($t.head.a), 0, Math.sin($t.head.a)),
                    this.origin.copy($t.head.p),
                    _h && (this.lineOrigin.copy(this.origin), this.line.position.copy(this.lineOrigin), (this.line.position.y = 0)),
                    (this.smoothWindowHead = $t.head),
                    this.turnTrackers))
                        (nl.tracker.n = $t.head), (nl.tracker.da = 0);
                }
                processCurve(e, t, i, s, n = !1) {
                    for (nl.ps = [], nl.ns = [], nl.i = 0; nl.i < s; nl.i++)
                        (nl.t = nl.i / s),
                            (nl.ti = 1 - nl.t),
                            (nl.x = nl.ti * nl.ti * e.p.x + 2 * nl.ti * nl.t * t.x + nl.t * nl.t * i.p.x),
                            (nl.z = nl.ti * nl.ti * e.p.z + 2 * nl.ti * nl.t * t.z + nl.t * nl.t * i.p.z),
                            nl.ps.push({ x: nl.x, y: nl.ti * nl.ti * e.p.y + 2 * nl.ti * nl.t * t.y + nl.t * nl.t * i.p.y, z: nl.z }),
                            n && nl.i > 0 && ((nl.dx = nl.x - nl.ps[nl.i - 1].x), (nl.dz = nl.z - nl.ps[nl.i - 1].z), (nl.dxz = Math.sqrt(nl.dx * nl.dx + nl.dz * nl.dz)), nl.ns.push({ x: -nl.dz / nl.dxz, z: nl.dx / nl.dxz }));
                    return n && ((nl.dx = i.x - nl.ps[s - 1].x), (nl.dz = i.z - nl.ps[s - 1].z), (nl.dxz = Math.sqrt(nl.dx * nl.dx + nl.dz * nl.dz)), nl.ns.push({ x: -nl.dz / nl.dxz, z: nl.dx / nl.dxz })), { ps: nl.ps, ns: nl.ns };
                }
                stitchNormals(e, t) {
                    let i,
                        s,
                        n,
                        a = e.ps[e.ps.length - 2];
                    (i = t.ps[0].x - a.x),
                        (s = t.ps[0].z - a.z),
                        (n = Math.sqrt(i * i + s * s)),
                        (e.ns[e.ps.length - 1] = { x: -s / n, z: i / n }),
                        (a = e.ps[e.ps.length - 1]),
                        (i = t.ps[1].x - a.x),
                        (s = t.ps[1].z - a.z),
                        (n = Math.sqrt(i * i + s * s)),
                        (t.ns[0] = { x: -s / n, z: i / n });
                    for (let o = 1; o < t.ps.length - 1; o++) (i = t.ps[o + 1].x - t.ps[o - 1].x), (s = t.ps[o + 1].z - t.ps[o - 1].z), (n = Math.sqrt(i * i + s * s)), (t.ns[o] = { x: -s / n, z: i / n });
                }
                resetDiscretised() {
                    ($t.discretisedTail = $t.head),
                        ($t.vehicleIndex = $t.head.i),
                        ($t.vehicleNode = $t.head),
                        (nl.head = $t.head),
                        (nl.pc = this.processCurve(nl.head, nl.head.c, nl.head.next, 10, !0)),
                        ($t.head.ps = nl.pc.ps),
                        ($t.head.ns = nl.pc.ns),
                        ($t.vehicleNode = $t.head);
                }
                discretiseNext() {
                    (nl.nextTail = $t.discretisedTail.next),
                        (nl.pc = this.processCurve(nl.nextTail, nl.nextTail.c, nl.nextTail.next, 10)),
                        this.stitchNormals($t.discretisedTail, nl.pc),
                        (nl.nextTail.ps = nl.pc.ps),
                        (nl.nextTail.ns = nl.pc.ns),
                        ($t.discretisedTail = nl.nextTail);
                }
                drawFeelers(e) {
                    this.feelLeft.position.copy($t.tail.p), this.feelRight.position.copy($t.tail.p);
                    let t = Math.cos($t.tail.a - el) * e + $t.tail.p.x,
                        i = Math.sin($t.tail.a - el) * e + $t.tail.p.z;
                    this.feelLeft.position.set(t, this.heightmap.getXZ(t, i, this.heightmap.midlineDepth), i),
                        (t = Math.cos($t.tail.a + el) * e + $t.tail.p.x),
                        (i = Math.sin($t.tail.a + el) * e + $t.tail.p.z),
                        this.feelRight.position.set(t, this.heightmap.getXZ(t, i, this.heightmap.midlineDepth), i);
                }
                extendMidline() {
                    if (((this.didExtend = !0), _h && this.lineIndex >= 15e4)) return;
                    for (al.tracker of ($t.tail.i > ct &&
                        $t.tail.i - $t.vehicleIndex < pt &&
                        !this.allowEmergencyBridge &&
                        !this.bridging &&
                        (console.warn("Midline stuck; safe horizon no longer safe. Allowing emergency bridge"), (this.allowEmergencyBridge = !0)),
                    (nl.feelDist = $h * (1 + this.waterFactor)),
                    (nl.feelL = this.heightmap.getXZ(Math.cos($t.tail.a - el) * nl.feelDist + $t.tail.p.x, Math.sin($t.tail.a - el) * nl.feelDist + $t.tail.p.z, this.heightmap.midlineDepth)),
                    (nl.feelR = this.heightmap.getXZ(Math.cos($t.tail.a + el) * nl.feelDist + $t.tail.p.x, Math.sin($t.tail.a + el) * nl.feelDist + $t.tail.p.z, this.heightmap.midlineDepth)),
                    (nl.feelA = this.heightmap.getXZ($t.tail.p.x, $t.tail.p.z, this.heightmap.midlineDepth)),
                    (nl.feelA = Math.max(nl.feelA, il)),
                    (this.waterFactor = 0),
                    (this.byWater = !1),
                    (nl.feelR < 2 * il || nl.feelL < 2 * il) && (this.byWater = !0),
                    (nl.feelAvg = (nl.feelR + nl.feelL) / 2),
                    nl.feelAvg < 3 * il && (nl.feelAvg > il ? (this.waterFactor = 1 - (nl.feelAvg - il) / (2 * il)) : (this.waterFactor = 1)),
                    (nl.feelDif = (nl.feelR - nl.feelL) / 2),
                    (nl.gradLat = (nl.feelL - nl.feelR) / nl.feelDist),
                    (nl.gradLat /= sl),
                    (nl.gradLon = (nl.feelAvg - nl.feelA) / nl.feelDist),
                    (nl.gradLon /= sl),
                    (nl.bT = 0),
                    0 !== nl.feelDif && (nl.bT = (nl.feelAvg - nl.feelA) / nl.feelDif),
                    (nl.bT = Math.max(Math.min(nl.bT, 1), -1)),
                    this.midlineDir.set(Math.cos($t.tail.a), 0, Math.sin($t.tail.a)),
                    this.midlineOrth.set(-this.midlineDir.z, 0, this.midlineDir.x),
                    (al.originDot = Math.max(Math.min(1, this.midlineDir.dot(this.originDir)), -1)),
                    (al.originSide = -1 * this.midlineOrth.dot(this.originDir)),
                    0 != al.originSide && (al.originSide /= Math.abs(al.originSide)),
                    al.originSide == this.prevOriginSide && this.originOverflow > 1.5 && (1 == al.originSide ? (al.originSide = -2) : (al.originSide = 2)),
                    al.originSide !== this.prevOriginSide
                        ? al.originSide > this.prevOriginSide
                            ? this.prevT < 0
                                ? ((this.originOverflow += this.prevT), this.originOverflow > 0 ? ((al.originSide = this.prevOriginSide), (al.originDot = -1)) : (this.originOverflow = 0))
                                : this.prevT > 0 && ((this.originOverflow += this.prevT), (al.originSide = this.prevOriginSide), (al.originDot = -1))
                            : this.prevT > 0
                            ? ((this.originOverflow -= this.prevT), this.originOverflow > 0 ? ((al.originSide = this.prevOriginSide), (al.originDot = -1)) : (this.originOverflow = 0))
                            : this.prevT < 0 && ((this.originOverflow -= this.prevT), (al.originSide = this.prevOriginSide), (al.originDot = -1))
                        : (this.originOverflow = 0),
                    (this.prevOriginSide = al.originSide),
                    (al.originAng = Math.acos(al.originDot)),
                    (nl.gradLeft = (nl.feelL - nl.feelA) / nl.feelDist / sl),
                    (nl.gradRight = (nl.feelR - nl.feelA) / nl.feelDist / sl),
                    (nl.maxT = 1),
                    (nl.minT = -1),
                    (nl.gradLeftAbs = Math.abs(nl.gradLeft)),
                    (nl.gradRightAbs = Math.abs(nl.gradRight)),
                    (nl.gradLeftAbs > 1 || nl.gradRightAbs > 1) &&
                        ((nl.gradDif = (nl.gradLeft - nl.gradRight) / 2),
                        (nl.gradAvg = (nl.gradLeft + nl.gradRight) / 2),
                        (nl.gradLeft > 1 && nl.gradRight > 1) || (nl.gradLeft < -1 && nl.gradRight < -1)
                            ? nl.gradLeftAbs < nl.gradRightAbs
                                ? ((nl.maxT = 1), (nl.minT = 1))
                                : ((nl.maxT = -1), (nl.minT = -1))
                            : (nl.gradLeftAbs > 1 && (nl.gradLeft < 0 ? (nl.maxT = (1 + nl.gradAvg) / Math.abs(nl.gradDif)) : (nl.maxT = (1 - nl.gradAvg) / Math.abs(nl.gradDif))),
                              nl.gradRightAbs > 1 && (nl.gradRight < 0 ? (nl.minT = (1 + nl.gradAvg) / Math.abs(nl.gradDif)) : (nl.minT = (1 - nl.gradAvg) / Math.abs(nl.gradDif)), (nl.minT *= -1)))),
                    (nl.gradAvg = (Math.abs(nl.gradLat) + Math.abs(nl.gradLon)) / 2),
                    (nl.maxDif = 0.5 + 0.5 * Math.abs(nl.gradAvg)),
                    (nl.maxT *= 1.5),
                    (nl.minT *= 1.5),
                    nl.maxT > 0 && (nl.maxT = Math.min(nl.maxT, this.prevT + nl.maxDif)),
                    nl.minT < 0 && (nl.minT = Math.max(nl.minT, this.prevT - nl.maxDif)),
                    this.byWater && (nl.gradLat < 0 ? nl.maxT > 0 && (nl.maxT *= 1 - this.waterFactor) : nl.minT < 0 && (nl.minT *= 1 - this.waterFactor)),
                    (nl.bT = Math.max(Math.min(nl.maxT, nl.bT), nl.minT)),
                    !this.bridging &&
                        this.byWater &&
                        ((al.originSide < 0 && nl.gradLat > 0) || (al.originSide > 0 && nl.gradLat < 0)) &&
                        (this.tVec.set(0, 0, 0),
                        ((0 == this.originOverflow && this.allowEmergencyBridge) || (nl.gradLon < -0.3 && Math.abs(nl.gradLat) < 1)) &&
                            ((this.tVec.x = this.midlineDir.x), (this.tVec.z = this.midlineDir.z), this.tVec.normalize(), this.testForBridge($t.tail.prev, 1, this.tVec)),
                        (this.tVec.x = $t.tail.prev.n.x * -al.originSide),
                        (this.tVec.z = $t.tail.prev.n.z * -al.originSide),
                        this.tVec.normalize(),
                        this.testForBridge($t.tail.prev, 1, this.tVec),
                        this.allowEmergencyBridge && ((this.tVec.x += this.midlineDir.x), (this.tVec.z += this.midlineDir.z), this.tVec.normalize(), this.testForBridge($t.tail.prev, 1, this.tVec))),
                    (nl.gradLon2 = nl.gradLon * nl.gradLon),
                    nl.gradLon2 <= 1 ? (!this.byWater || nl.gradLon > 0) && (nl.bT *= Math.abs(nl.gradLon2)) : nl.bT < 0 ? (nl.bT = nl.minT) : (nl.bT = nl.maxT),
                    (nl.bT = Math.max(Math.min(nl.maxT, nl.bT), nl.minT)),
                    (this.antiWeight = 0),
                    this.antiTargetRange > 0 &&
                        ((al.d = $t.tail.p.x - this.antiTarget.x),
                        (al.d = al.d * al.d + ($t.tail.p.z - this.antiTarget.z) * ($t.tail.p.z - this.antiTarget.z)),
                        this.antiDir.set(this.antiTarget.x - $t.tail.p.x, 0, this.antiTarget.z - $t.tail.p.z),
                        this.antiDir.normalize(),
                        (al.antiDot = this.midlineDir.dot(this.antiDir)),
                        al.d < this.antiTargetRange
                            ? ((this.antiWeight = 1 - al.d / this.antiTargetRange),
                              (al.antiSide = this.midlineOrth.dot(this.antiDir)),
                              (al.antiRedirect = 2 * el * al.antiSide),
                              (al.antiAdjust = (al.antiDot + 1) / 2),
                              (this.antiWeight *= al.antiAdjust),
                              (al.antiRedirect = Math.max(Math.min(nl.maxT, al.antiRedirect), nl.minT)),
                              (nl.bT = this.antiWeight * al.antiRedirect + (1 - this.antiWeight) * nl.bT))
                            : al.antiDot < -0.707 && ((this.antiTargetRange = 0), (this.trackIndex = null), (this.trackRevertCount = 0))),
                    (al.originAdjust = (1 - (al.originDot + 1) / 2) * (1 - this.waterFactor * this.waterFactor)),
                    (al.originAdjust *= 1 - this.antiWeight),
                    (al.originRedirect = (al.originAng * al.originSide) / el),
                    (al.originRedirect = Math.max(Math.min(nl.maxT, al.originRedirect), nl.minT)),
                    (nl.bT = al.originAdjust * al.originRedirect + (1 - al.originAdjust) * nl.bT),
                    (al.shouldBridge = !this.bridging && this.byWater && this.bridge.spawnNode && $t.tail.i - this.bridge.spawnNode.i < 150 && (this.originOverflow > 0 || this.allowEmergencyBridge)),
                    this.turnTrackers))
                        if (
                            ((al.tracker.da += $t.tail.da),
                            al.tracker.n.i <= $t.tail.i - al.tracker.m && ((al.tracker.da -= al.tracker.n.da), (al.tracker.n = al.tracker.n.next)),
                            (Math.abs(al.tracker.da) > al.tracker.a && (this.byWater || al.originDot < al.tracker.o)) || al.shouldBridge)
                        ) {
                            for (
                                this.bridging && ((al.shouldBridge = !1), (this.bridging = !1), (this.bridge.spawnNode = null)),
                                    al.shouldBridge || this.trackRevertCount++,
                                    (al.shouldBridge || (this.trackRevertCount > 5 && this.bridge.spawnNode && $t.tail.i - this.bridge.spawnNode.i < this.antiTargetRevert)) &&
                                        ((this.bridging = !0), this.improveBridgeStartNode(), (this.bridge.landing.y = (this.bridge.spawnNode.p.y + this.bridge.landing.y) / 2), (this.bridge.height = this.bridge.landing.y)),
                                    this.didExtend = !1,
                                    al.revertDistance = 0,
                                    this.bridging
                                        ? ((this.trackIndex = null), (this.antiTargetRange = 0), (this.antiTargetTrigger = $t.tail.i), (al.revertDistance = $t.tail.i - this.bridge.spawnNode.i))
                                        : Math.abs(this.antiResetIndex - $t.tail.i) < 2 * al.tracker.m || (this.trackIndex == al.tracker.i && this.antiWeight > 0)
                                        ? (this.antiTargetTriggerCount++,
                                          (this.antiTargetRevert += this.antiTargetTriggerCount * al.tracker.r),
                                          $t.tail.i - this.antiTargetRevert < this.maxRetractIndex &&
                                              (this.antiTarget.copy($t.tail.p), (this.antiTargetRevert = $t.tail.i - this.maxRetractIndex), console.warn("Max revert; allowing emergency bridge"), (this.allowEmergencyBridge = !0)),
                                          (al.revertDistance = this.antiTargetRevert))
                                        : ((this.trackIndex = al.tracker.i),
                                          this.antiTarget.copy($t.tail.p),
                                          (this.antiTargetRevert = al.tracker.m),
                                          (this.antiTargetTrigger = $t.tail.i),
                                          this.antiTargetTriggerPoint.copy(this.antiTarget),
                                          (this.antiTargetTriggerCount = 0),
                                          (al.revertDistance = this.antiTargetRevert)),
                                    al.resetIndex = $t.tail.i - al.revertDistance;
                                $t.tail.i > al.resetIndex;

                            ) {
                                var e;
                                if (!$t.tail.bridge && (null === (e = $t.tail.prev) || void 0 === e ? void 0 : e.bridge)) {
                                    for (al.bn = $t.tail.prev; null === (t = al.bn) || void 0 === t ? void 0 : t.bridge; ) {
                                        var t;
                                        al.bn = al.bn.prev;
                                    }
                                    if (al.bn.i < al.resetIndex) break;
                                    this.antiBridgePoint.copy($t.tail.p);
                                }
                                if (null == $t.tail.prev || $t.tail.i - $t.head.i < mt) break;
                                ($t.tail = $t.tail.prev), delete $t.tail.next, ($t.tail.next = null);
                            }
                            if (this.smoothWindowHead.i > $t.tail.i - mt)
                                for (
                                    al.startI = 0,
                                        this.smoothWindowHead.i <= $t.tail.i ? (al.startI = Math.max(0, $t.tail.i - this.smoothWindowHead.i)) : ((this.smoothWindowHead = $t.tail), (this.smoothWindowHead.p.y += this.smoothWindowHead.h)),
                                        al.i = al.startI;
                                    al.i <= mt;
                                    al.i++
                                )
                                    this.smoothWindowHead.prev && ((this.smoothWindowHead = this.smoothWindowHead.prev), (this.smoothWindowHead.p.y += this.smoothWindowHead.h));
                            for (al.tracker2 of (this.bridging || ((this.antiTargetRange = 4 * this.antiTarget.distanceToSquared($t.tail.p)), (this.antiResetIndex = $t.tail.i)),
                            !this.bridging && this.bridge.spawnNode && this.bridge.spawnNode.i > $t.tail.i && this.resetBridgeState(),
                            $t.vehicleIndex > $t.tail.i && (($t.vehicleIndex = $t.tail.i), ($t.vehicleNode = $t.tail)),
                            this.hasInitGeneration && $t.tail.i - pt + 100 < $t.vehicleIndex && (console.error("Midline reset violation"), console.log($t.vehicleIndex, $t.tail.i)),
                            this.turnTrackers))
                                for (al.tracker2.n = $t.tail, al.tracker2.da = $t.tail.da, al.i = 0; al.i < al.tracker2.m && al.tracker2.n.prev; al.i++) (al.tracker2.n = al.tracker2.n.prev), (al.tracker2.da += al.tracker2.n.da);
                            return (
                                (this.prevT = $t.tail.t),
                                (this.waterFactor = Math.max(Math.min(1, 1 - ($t.tail.p.y - il) / (2 * il)), 0)),
                                "o" in $t.tail
                                    ? $t.tail.o < 0
                                        ? ((this.prevOriginSide = -1), (this.originOverflow = -$t.tail.o))
                                        : ((this.prevOriginSide = 1), (this.originOverflow = $t.tail.o))
                                    : (this.midlineDir.set(Math.cos($t.tail.a), 0, Math.sin($t.tail.a)),
                                      this.midlineOrth.set(-this.midlineDir.z, 0, this.midlineDir.x),
                                      (al.originDot = this.midlineDir.dot(this.originDir)),
                                      (al.originSide = -1 * this.midlineOrth.dot(this.originDir)),
                                      0 != al.originSide && (al.originSide /= Math.abs(al.originSide)),
                                      (this.prevOriginSide = al.originSide),
                                      (this.originOverflow = 0)),
                                !1
                            );
                        }
                    this.bridging &&
                        (al.vecA.set(this.bridge.landing.x - $t.tail.p.x, 0, this.bridge.landing.z - $t.tail.p.z).normalize(),
                        al.vecB.set($t.tail.p.x - $t.tail.prev.p.x, 0, $t.tail.p.z - $t.tail.prev.p.z).normalize(),
                        $t.tail.p.distanceTo(this.bridge.landing) < 10 && ((this.bridging = !1), (this.allowEmergencyBridge = !1), this.resetBridgeState()),
                        (nl.dot = Math.min(al.vecA.dot(al.vecB), 1)),
                        (nl.side = (this.bridge.landing.x - $t.tail.p.x) * al.vecB.z - (this.bridge.landing.z - $t.tail.p.z) * al.vecB.x),
                        (nl.side = nl.side < 0 ? -1 : 1),
                        (nl.bT = Math.min(Math.max(Math.acos(nl.dot), -1.5), 1.5) * nl.side)),
                        this.isStraight && (nl.bT = 0),
                        (this.prevT = nl.bT),
                        (nl.bDir = $t.tail.a - nl.bT * el),
                        nl.bDir < -Math.PI ? (nl.bDir += 2 * Math.PI) : nl.bDir > Math.PI && (nl.bDir -= 2 * Math.PI),
                        (al.cDist = 0.5 * tl),
                        (al.x = Math.cos($t.tail.a) * al.cDist + $t.tail.p.x),
                        (al.z = Math.sin($t.tail.a) * al.cDist + $t.tail.p.z),
                        (al.roadSinkFactor = 0.1 * (1 - this.waterFactor)),
                        ($t.tail.c.x = al.x),
                        ($t.tail.c.y = $t.tail.p.y),
                        ($t.tail.c.z = al.z),
                        (al.nx = al.x - $t.tail.p.x),
                        (al.nz = al.z - $t.tail.p.z),
                        (al.nxz = Math.sqrt(al.nx * al.nx + al.nz * al.nz)),
                        ($t.tail.n = { x: -al.nz / al.nxz, z: al.nx / al.nxz }),
                        (al.x = Math.cos(nl.bDir) * al.cDist + al.x),
                        (al.z = Math.sin(nl.bDir) * al.cDist + al.z);
                    let i = {
                        i: $t.tail.i + 1,
                        p: new r.W(al.x, (this.bridging ? this.bridge.height : Math.max(this.heightmap.getXZ(al.x, al.z, this.heightmap.midlineDepth), il)) - al.roadSinkFactor, al.z),
                        a: nl.bDir,
                        da: nl.bT * el,
                        h: 0,
                        c: new r.W(),
                        t: nl.bT,
                        n: { x: 0, z: 1 },
                        w: Ft,
                        g: nl.gradLat,
                        gfa: Math.abs(nl.gradLon),
                        next: null,
                        prev: $t.tail,
                    };
                    return (
                        (this.bridging || (this.isStraight && i.p.y <= 2)) && (i.bridge = !0),
                        ($t.tail.c.y = ($t.tail.c.y + i.p.y) / 2),
                        this.originOverflow > 0 && (i.o = this.originOverflow * al.originSide),
                        ($t.tail.next = i),
                        isNaN(al.x)
                            ? (console.log("NAN x AT INDEX " + i.i),
                              console.log("bT ", nl.bT),
                              console.log("bDir ", nl.bDir),
                              console.log("E.originDot ", al.originDot),
                              console.log("originAdjust ", al.originAdjust),
                              console.log("OriginRedirect ", al.originRedirect),
                              console.log("OriginSide ", al.originSide),
                              console.log("originAng ", al.originAng),
                              console.log("Origindir ", this.originDir),
                              console.log("Min max ", nl.minT, nl.maxT),
                              console.log("Gradlat, lon ", nl.gradLat, nl.gradLon),
                              console.log("gradAVg ", nl.gradAvg),
                              console.log("antiWeight ", this.antiWeight),
                              console.log("feelL, feelR ", nl.feelL, nl.feelR),
                              console.log("feelAvg ", nl.feelAvg),
                              console.log("feelDif ", nl.feelDif),
                              console.log("waterFactor ", this.waterFactor),
                              console.log("maxDif ", nl.maxDif),
                              !1)
                            : (_h && this.drawPoints($t.tail), ($t.tail = i), (this.maxRetractIndex = Math.max(this.maxRetractIndex, $t.tail.i - ut)), $t.tail.i > 1640 && $t.tail.i, !0)
                    );
                }
                resetBridgeState() {
                    (this.bridge.spawnNode = null), (this.bridge.distance = 0), this.bridge.landing.set(0, 0, 0);
                }
                improveBridgeStartNode() {
                    let e,
                        t,
                        i = this.bridge.spawnNode.prev,
                        s = this.bridge.spawnNode.p.distanceToSquared(this.bridge.landing),
                        n = new r.V(),
                        a = new r.V();
                    (a.x = i.p.x - i.prev.p.x), (a.y = i.p.z - i.prev.p.z), a.normalize(), n.set(this.bridge.landing.x - i.p.x, this.bridge.landing.z - i.p.z).normalize(), (t = a.dot(n));
                    let o = a.dot(n);
                    for (let r = 0; r < 20 && i.prev && !(Math.abs(i.p.y - this.bridge.landing.y) > 2); r++)
                        (e = i.p.distanceToSquared(this.bridge.landing)),
                            (a.x = i.p.x - i.prev.p.x),
                            (a.y = i.p.z - i.prev.p.z),
                            a.normalize(),
                            n.set(this.bridge.landing.x - i.p.x, this.bridge.landing.z - i.p.z).normalize(),
                            (t = a.dot(n)),
                            (e < s || s < 0) && t > -0.1 && ((s = e), (this.bridge.spawnNode = i)),
                            t > o && e < 1.2 * s && ((o = t), (this.bridge.spawnNode = i)),
                            (i = i.prev);
                }
                testForBridge(e, t, i) {
                    this.landing = new r.W();
                    let s = 0,
                        n = 250,
                        a = 5,
                        o = n / 2;
                    if (this.allowEmergencyBridge)
                        do {
                            (this.landing.x = e.p.x + i.x * n * t), (this.landing.z = e.p.z + i.z * n * t), (this.landing.y = this.heightmap.getXZ(this.landing.x, this.landing.z, this.heightmap.midlineDepth)), (n += 250), (a += 1);
                        } while (this.landing.y < 2);
                    else if (((this.landing.x = e.p.x + i.x * n * t), (this.landing.z = e.p.z + i.z * n * t), (this.landing.y = this.heightmap.getXZ(this.landing.x, this.landing.z, this.heightmap.midlineDepth)), this.landing.y < 2))
                        return (this.landing.y = 0), null;
                    for (let r = 0; r < a; r++)
                        (this.landing.x = e.p.x + i.x * o * t),
                            (this.landing.z = e.p.z + i.z * o * t),
                            (this.landing.y = this.heightmap.getXZ(this.landing.x, this.landing.z, this.heightmap.midlineDepth)),
                            this.landing.y < 2 ? ((s = o), (o = 0.5 * s + 0.5 * n)) : ((n = o), (o = 0.5 * s + 0.5 * n));
                    return o < 40 || this.landing.distanceTo(this.antiBridgePoint) < 100
                        ? null
                        : (!this.bridge.spawnNode || e.i - this.bridge.spawnNode.i > 20 || o < this.bridge.distance) && this.checkBridgeQuality(e.p, this.landing)
                        ? ((this.bridge.spawnNode = e), (this.bridge.distance = o), this.bridge.landing.copy(this.landing), this.landing)
                        : null;
                }
                checkBridgeQuality(e, t) {
                    let i = e.clone().add(t).multiplyScalar(0.5);
                    if (this.heightmap.getXZ(i.x, i.z, this.heightmap.midlineDepth) > -2) return !1;
                    let s = t.clone().sub(e);
                    if (((s.y = 0), s.normalize(), 0 == this.originOverflow && s.dot(this.originDir) < 0)) return !1;
                    (s.y = s.x), (s.x = -s.z), (s.z = s.y);
                    let n = e.distanceTo(i) / 2,
                        a = s.clone().multiplyScalar(n).add(i);
                    return !(this.heightmap.getXZ(a.x, a.z, this.heightmap.midlineDepth) > 0) && ((a = s.multiplyScalar(-n).add(i)), !(this.heightmap.getXZ(a.x, a.z, this.heightmap.midlineDepth) > 0));
                }
                smoothHeight() {
                    for (al.avg = 0, al.n = this.smoothWindowHead, al.i = 0; al.i < mt; al.i++) (al.avg += al.n.p.y), (al.n = al.n.next), al.i <= Kh && (al.s = al.n);
                    (al.avg /= mt),
                        (al.r = al.s.prev),
                        (al.q = al.r.prev),
                        (al.s.h = al.s.p.y - al.avg),
                        (al.hAngle = (al.avg - (al.q.p.y - al.q.h)) / 20),
                        (al.r.c.y = al.r.p.y - al.r.h + 5 * al.hAngle),
                        (this.smoothWindowHead.p.y -= this.smoothWindowHead.h),
                        (this.smoothWindowHead = this.smoothWindowHead.next);
                }
                update() {
                    return (
                        $t.tail.i < $t.vehicleIndex + ct ? (this.extendMidline(), this.smoothHeight()) : $t.tail.i - $t.head.i > ct && ((nl.n = $t.head.next), delete $t.head, ($t.head = nl.n), ($t.head.prev = null)),
                        $t.discretisedTail.i < $t.vehicleIndex + gt ? this.discretiseNext() : $t.discretisedTail.i - $t.head.i > gt && ((nl.n = $t.head.next), delete $t.head, ($t.head = nl.n), ($t.head.prev = null)),
                        this.didExtend
                    );
                }
                drawFine(e) {
                    let t;
                    for (; null === (i = e.next) || void 0 === i ? void 0 : i.ps; ) {
                        var i;
                        for (t of e.ps) (this.lineArr[this.lineIndex++] = t.x), (this.lineArr[this.lineIndex++] = t.y + 1), (this.lineArr[this.lineIndex++] = t.z);
                        e = e.next;
                    }
                    this.lineGeo.setDrawRange(0, this.lineIndex / 3), (this.lineGeo.attributes.position.needsUpdate = !0), this.lineGeo.computeBoundingSphere();
                }
                drawPoints(e) {
                    let t, i, s, n, a;
                    for (; e.next; ) {
                        for (s of ((t = new r.N(e.p, e.c, e.next.p)), (i = t.getPoints(1)), i))
                            (n = s.x - this.line.position.x),
                                (a = s.z - this.line.position.z),
                                (this.lineArr[this.lineIndex++] = n),
                                (this.lineArr[this.lineIndex++] = Math.max(2, this.heightmap.getXZ(s.x, s.z, this.heightmap.midlineDepth)) + 1),
                                (this.lineArr[this.lineIndex++] = a);
                        e = e.next;
                    }
                    this.lineGeo.setDrawRange(0, this.lineIndex / 3), (this.lineGeo.attributes.position.needsUpdate = !0), this.lineGeo.computeBoundingSphere();
                }
            };
            class rl {
                static getUVs(e) {
                    let t = [],
                        i = Math.floor(100 / (2 * Ft));
                    i = 16;
                    for (let s = 0; s <= e; s++) t.push(1, (s / e) * 16), t.push(0, (s / e) * 16);
                    return t;
                }
                constructor(e, t = !1) {
                    (this.genNode = null),
                        (this.genIndex = 0),
                        (this.nodeIndex = 0),
                        (this.originPos = new r.W()),
                        (this.numPoints = 10),
                        (this.isCoarse = !1),
                        (this.p = new r.W()),
                        (this.numPoints = e),
                        (this.isCoarse = t),
                        (this.geo = new r.g()),
                        this.geo.setIndex(rl.getIndex(e + 1)),
                        this.geo.setAttribute("position", new r.o(new Float32Array(2 * (e + 1) * 3), 3)),
                        (this.verts = this.geo.attributes.position.array),
                        this.geo.attributes.position.setUsage(r.l);
                    let i = rl.getUVs(e);
                    this.geo.setAttribute("uv", new r.o(new Float32Array(i), 2)), (this.mesh = new r.B(this.geo, Qt)), (this.mesh.matrixAutoUpdate = !1), (this.mesh.receiveShadow = !0), (this.mesh.visible = !1);
                }
                initialise(e) {
                    for (this.initGeneration(e); !this.generate(); );
                    this.display();
                }
                initGeneration(e, t = 0) {
                    (this.midlineNode = e), (this.genNode = e), this.originPos.copy(e.p), this.mesh.position.copy(this.originPos), (this.genIndex = 0), (this.nodeIndex = 0);
                }
                generate() {
                    let e, t;
                    this.isCoarse
                        ? (this.p.copy(this.genNode.p).sub(this.originPos), (e = this.genNode.n), (t = this.genNode.w))
                        : (this.nodeIndex >= this.genNode.ps.length && ((this.nodeIndex = 0), (this.genNode = this.genNode.next)),
                          this.p.copy(this.genNode.ps[this.nodeIndex]).sub(this.originPos),
                          (e = this.genNode.ns[this.nodeIndex]),
                          (t = this.genNode.w));
                    let i = 6 * this.genIndex;
                    return (
                        (this.verts[i] = this.p.x + e.x * t),
                        (this.verts[i + 1] = this.p.y + 0.01),
                        (this.verts[i + 2] = this.p.z + e.z * t),
                        (this.verts[i + 3] = this.p.x - e.x * t),
                        (this.verts[i + 4] = this.p.y + 0.01),
                        (this.verts[i + 5] = this.p.z - e.z * t),
                        this.genIndex++,
                        this.isCoarse ? this.genIndex <= this.numPoints && (this.genNode = this.genNode.next) : (this.nodeIndex += 1),
                        this.genIndex == this.numPoints + 1
                    );
                }
                display() {
                    (this.geo.attributes.position.needsUpdate = !0), this.geo.computeVertexNormals(), this.geo.computeBoundingSphere(), this.mesh.updateMatrix(), this.show();
                }
                show() {
                    this.mesh.visible = !0;
                }
                hide() {
                    this.mesh.visible = !1;
                }
                retire() {
                    this.hide();
                }
                static getIndex(e) {
                    let t,
                        i,
                        s,
                        n,
                        a = [];
                    for (let o = 0; o < e - 1; o++) (t = 2 * o), (i = t + 1), (s = 2 * (o + 1)), (n = s + 1), a.push(t, s, i), a.push(i, s, n);
                    return a;
                }
            }
            rl.mat = new r.D({ color: 8947848 });
            var hl = class {
                constructor() {
                    (this.nearSegs = []),
                        (this.farSegs = []),
                        (this.seenIndex = 0),
                        (this.nearIndex = 0),
                        (this.nearCheck = 15),
                        (this.nextNearReady = !1),
                        (this.farIndex = 0),
                        (this.farCheck = 45),
                        (this.nextFarReady = !1),
                        (this.container = new r.G()),
                        this.initSegs(),
                        (this.nearIndex = 0),
                        (this.farIndex = 0);
                }
                destroy() {
                    for (
                        this.container.traverse((e) => {
                            e.isMesh && e.geometry.dispose();
                        });
                        this.container.children.length;

                    )
                        this.container.remove(this.container.children[0]);
                }
                handleMidlineReset() {
                    $t.tail.i < this.farIndex && console.error("Road controller cannot handle reset gracefully");
                }
                initSegs() {
                    let e;
                    for (e = 0; e < 10; e++) {
                        let e = new rl(10, !0);
                        this.container.add(e.mesh), this.farSegs.push(e);
                    }
                    for (this.farSegs[1].initialise($t.head), this.farSegs[0].initialise(this.farSegs[1].genNode), this.farSegs[0].hide(), this.farSegs[1].hide(), this.farSegs[9].initGeneration(this.farSegs[0].genNode), e = 0; e < 4; e++) {
                        let e = new rl(100);
                        this.container.add(e.mesh), this.nearSegs.push(e);
                    }
                    this.nearSegs[1].initialise($t.head), this.nearSegs[0].initialise(this.nearSegs[1].genNode), this.nearSegs[3].initGeneration(this.nearSegs[0].genNode);
                }
                update() {
                    if ((this.nextNearReady || (this.nextNearReady = this.nearSegs[3].generate()), this.nearIndex - $t.vehicleIndex < this.nearCheck)) {
                        for (; !this.nextNearReady; ) this.nextNearReady = this.nearSegs[3].generate();
                        this.nearSegs.unshift(this.nearSegs.pop()),
                            this.nearSegs[0].display(),
                            (this.nearIndex = this.nearSegs[0].genNode.i),
                            this.nearSegs[3].retire(),
                            this.nearSegs[3].initGeneration(this.nearSegs[0].genNode),
                            (this.nextNearReady = !1);
                    }
                    if (this.nextFarReady) {
                        if (this.farIndex - $t.vehicleIndex < this.farCheck) {
                            this.farSegs.unshift(this.farSegs.pop()),
                                this.farSegs[0].display(),
                                (this.farIndex = this.farSegs[0].genNode.i),
                                this.farSegs[9].retire(),
                                this.farSegs[9].initGeneration(this.farSegs[0].genNode),
                                (this.nextFarReady = !1);
                            let e = Math.floor(4.5) - 1;
                            this.farSegs[e].hide(), this.farSegs[e + 3].show();
                        }
                    } else this.nextFarReady = this.farSegs[9].generate();
                }
            };
            var ll = window;
            var dl = "slowroads.io";
            class cl extends r.g {
                updateHeights() {
                    this.attributes.heightOffset.needsUpdate = !0;
                }
                drawCount(e) {
                    this.setDrawRange(0, e * this.res * this.res * 6),
                        (this.attributes.position.needsUpdate = !0),
                        (this.attributes.normal.needsUpdate = !0),
                        (this.attributes.heightOffset.needsUpdate = !0),
                        (this.attributes.roadProximity.needsUpdate = !0),
                        (this.attributes.treeMask.needsUpdate = !0),
                        (this.attributes.curvature.needsUpdate = !0);
                }
                constructor(e, t, i) {
                    super(), (this.tileIndexSize = 0), (this.centroid = new r.W());
                    let s = t + 1;
                    this.res = t;
                    let n,
                        a,
                        o,
                        h,
                        l = s * s * i,
                        d = [],
                        c = [],
                        p = [],
                        u = 0;
                    for (let r = 0; r < i; r++) {
                        for (let e = 0; e <= t; e++)
                            for (let i = 0; i <= t; i++)
                                d.push(i / t, e / t),
                                    c.push(i / t / 10, e / t / 10),
                                    e < t && i < t && ((n = e * s + i + u), (a = e * s + (i + 1) + u), (o = (e + 1) * s + i + u), (h = (e + 1) * s + (i + 1) + u), p.push(n, a, o), p.push(a, h, o));
                        u += s * s;
                    }
                    this.setIndex(p),
                        this.setAttribute("position", new r.o(new Float32Array(3 * l), 3)),
                        this.attributes.position.setUsage(r.l),
                        this.setAttribute("normal", new r.o(new Float32Array(3 * l), 3)),
                        this.attributes.normal.setUsage(r.l),
                        this.setAttribute("heightOffset", new r.o(new Float32Array(l), 1)),
                        this.attributes.heightOffset.setUsage(r.l),
                        this.setAttribute("roadProximity", new r.o(new Float32Array(l), 1)),
                        this.attributes.roadProximity.setUsage(r.l),
                        this.setAttribute("treeMask", new r.o(new Float32Array(l), 1)),
                        this.attributes.treeMask.setUsage(r.l),
                        this.setAttribute("curvature", new r.o(new Float32Array(l), 1)),
                        this.attributes.curvature.setUsage(r.l),
                        this.setAttribute("uv", new r.o(new Float32Array(d), 2)),
                        this.setAttribute("wuv", new r.o(new Float32Array(c), 2));
                }
                computeBoundingSphere(e = null) {
                    if ((null == this.boundingSphere && (this.boundingSphere = new r.R(new r.W(), 0)), null == e)) return;
                    let t;
                    for (t of (this.boundingSphere.center.set(0, 0, 0), e)) t && this.boundingSphere.center.add(t);
                    this.boundingSphere.center.multiplyScalar(1 / e.length);
                    let i,
                        s = 0;
                    for (t of e) (i = t.distanceToSquared(this.boundingSphere.center)), i > s && (s = i);
                    this.boundingSphere.radius = Math.sqrt(s) + 10;
                }
            }
            var pl = class {
                    constructor(e, t, i, s, n) {
                        (this.indexCallbacks = []),
                            (this.redrawTilesets = {}),
                            (this.redrawCells = []),
                            (this.centroids = []),
                            (this.centroid = new r.W()),
                            (this.origin = new r.W()),
                            (this.lod = e),
                            (this.res = t),
                            (this.id = s),
                            0 == this.lod ? (this.tileCount = i * i * 4) : (this.tileCount = i * i * 1),
                            (this.vertexCount = (t + 1) * (t + 1)),
                            (this.nextTileIndex = 0),
                            (this.maxTileIndex = this.tileCount - 1),
                            (this.readyCount = 0),
                            (this.drawCount = 0),
                            (this.retireIndex = Nt),
                            (this.geo = new cl(e, t, this.tileCount)),
                            (this.mesh = new r.B(this.geo, n)),
                            (this.showHeight = new Float32Array((t + 1) * (t + 1))),
                            (this.hideHeight = new Float32Array((t + 1) * (t + 1)));
                        for (let a = 0; a < this.hideHeight.length; a++) (this.hideHeight[a] = -5), (this.showHeight[a] = 0);
                        (this.mesh.visible = !1),
                            (this.mesh.receiveShadow = !0),
                            (this.mesh.matrixAutoUpdate = !1),
                            (this.posArr = this.geo.attributes.position.array),
                            (this.normArr = this.geo.attributes.normal.array),
                            (this.curveArr = this.geo.attributes.curvature.array),
                            (this.heightOffsetArr = this.geo.attributes.heightOffset.array),
                            (this.roadProxArr = this.geo.attributes.roadProximity.array),
                            (this.treeMaskArr = this.geo.attributes.treeMask.array),
                            (this.vec3Count = 3 * this.vertexCount),
                            (this.floatCount = this.vertexCount);
                    }
                    reset() {
                        (this.nextTileIndex = 0),
                            (this.retireIndex = Nt),
                            (this.readyCount = 0),
                            (this.drawCount = 0),
                            (this.indexCallbacks.length = 0),
                            (this.mesh.visible = !1),
                            (this.redrawTilesets = {}),
                            (this.redrawCells.length = 0),
                            (this.centroids.length = 0),
                            this.geo.drawCount(this.nextTileIndex);
                    }
                    registerCallback(e, t) {
                        this.indexCallbacks[e] = t;
                    }
                    setOrigin(e) {
                        this.origin.copy(e), this.mesh.position.copy(this.origin);
                    }
                    setRetireIndex(e) {
                        this.retireIndex = Math.max(this.retireIndex, e + Nt);
                    }
                    tileReady(e, t, i, s, n, a, o, r) {
                        this.posArr.set(t, e * t.length),
                            this.normArr.set(i, e * i.length),
                            this.curveArr.set(s, e * s.length),
                            this.heightOffsetArr.set(this.showHeight, e * this.showHeight.length),
                            this.roadProxArr.set(n, e * n.length),
                            this.treeMaskArr.set(a, e * a.length),
                            (this.centroids[e] = o),
                            this.readyCount++,
                            this.drawCount++,
                            (this.readyCount == this.tileCount || r) && this.draw();
                    }
                    registerRedrawCell(e) {
                        this.redrawCells.push(e);
                    }
                    registerRedraw(e) {
                        e.id in this.redrawTilesets || (this.redrawTilesets[e.id] = e);
                    }
                    hideTile(e) {
                        this.heightOffsetArr.set(this.hideHeight, e * this.floatCount);
                    }
                    draw() {
                        if (this.redrawCells.length) {
                            let e;
                            for (e of this.redrawCells) e.retire(), this.registerRedraw(e.tileset);
                            for (e in this.redrawTilesets) this.redrawTilesets[e].update();
                        }
                        (this.mesh.visible = !0), this.geo.drawCount(this.drawCount), this.geo.computeBoundingSphere(this.centroids), this.mesh.updateMatrix();
                    }
                    update() {
                        this.geo.updateHeights();
                    }
                },
                ul = i.p + "static/media/road-despawns.677d3840.webp";
            const gl = {};
            var ml = class {
                constructor(e, t, i) {
                    (this.cells = [[], []]),
                        (this.lods = [
                            { res: Ct, node: null, horizon: jt, tileSize: 5, tiles: Math.floor(2.5), prevCheck: { x: 0, z: 0 } },
                            { res: Ot, node: null, horizon: Lt, tileSize: 3, tiles: Math.floor(1.5), prevCheck: { x: 0, z: 0 } },
                        ]),
                        (this.tilesets = [[], []]),
                        (this.stagedCells = []),
                        (this.loadedCells = {}),
                        (this.activeCells = {}),
                        (this.counts = [0, 0]),
                        (this.nearNode = null),
                        (this.medIndex = 0),
                        (this.medNode = null),
                        (this.seenIndex = -1),
                        (this.rearNode = null),
                        (this.prevCheckCell = { x: 0, z: 0 }),
                        (this.heightmap = e),
                        (this.container = new r.G()),
                        (this.container.matrixAutoUpdate = !1),
                        (this.despawnBarrier = new r.B(new r.J(4, 1), new r.C({ map: et(ul, 16), alphaTest: 0.5 }))),
                        this.container.add(this.despawnBarrier),
                        (this.groundMaterial = t),
                        this.resetLodConfig(),
                        (this.cellClass = i),
                        this.cellClass.initialise(() => {
                            this.initialise();
                        }),
                        ll.location.host.indexOf(dl) < 0 || ll.location.host.length,
                        (this.seenIndex = $t.head.i);
                }
                preInit() {
                    let e = ll.location.host.indexOf(dl);
                    e < 0 || ll.location.host.length;
                }
                destroy() {
                    for (
                        this.container.traverse((e) => {
                            e.isMesh && e.geometry.dispose();
                        });
                        this.container.children.length;

                    )
                        this.container.remove(this.container.children[0]);
                }
                loader() {
                    return this.progressNodes(!0, 1) ? ((this.lods[1].node.i - this.seenIndex) / this.lods[1].horizon) * 0.5 : this.progressNodes(!0, 0, 0) ? 0.5 + ((this.lods[0].node.i - this.seenIndex) / this.lods[0].horizon) * 0.5 : 1;
                }
                resetLodConfig() {
                    this.lods = [
                        { res: Ct, node: null, horizon: jt, tileSize: 5, tiles: Math.floor(2.5), prevCheck: { x: 0, z: 0 } },
                        { res: Ot, node: null, horizon: Lt, tileSize: 3, tiles: Math.floor(1.5), prevCheck: { x: 0, z: 0 } },
                    ];
                }
                reset(e) {
                    (this.heightmap = e), (this.nearNode = $t.head), (this.seenIndex = $t.head.i), this.resetLodConfig();
                    for (let t of this.cells) for (let e of t) e.retire();
                    for (let t of this.stagedCells) t.retire(), this.cells[t.lod].push(t);
                    (this.stagedCells.length = 0), delete this.activeCells, (this.activeCells = {}), delete this.loadedCells, (this.loadedCells = {});
                    for (let t of this.tilesets) for (let e of t) e.reset();
                    this.initialise();
                }
                handleMidlineReset() {
                    $t.tail.i < this.lods[0].node.i && console.error("Near grid cannot reset gracefully");
                }
                testGround(e, t, i) {
                    let s = Math.floor(e / zt),
                        n = Math.floor(t / zt);
                    if ((null == i && (i = { n: [0, 1, 0] }), (i.f = Wt), (i.r = !1), (i.w = !1), this.activeCells[s] && this.activeCells[s][n])) {
                        i.n = this.loadedCells[s][n].getNormal(e, t);
                        let a = _t(e, t, this.loadedCells[s][n].originNode, !0);
                        return (
                            a.n.lWallDist &&
                                1 == a.s &&
                                ((i.w = !0),
                                (i.wi = Math.floor(100 * a.n.lWallDist)),
                                !0 === i.insideWall ? (i.wd = a.d - (a.n.lWallDist - 0.2)) : !1 === i.insideWall ? (i.wd = a.d - (a.n.lWallDist + 0.2)) : (i.wd = a.d - a.n.lWallDist),
                                (i.ws = a.s),
                                (i.wn = a.n.n)),
                            a.n.rWallDist &&
                                -1 == a.s &&
                                ((i.w = !0),
                                (i.wi = -1 * Math.floor(100 * a.n.rWallDist)),
                                !0 === i.insideWall ? (i.wd = a.d - (a.n.rWallDist - 0.2)) : !1 === i.insideWall ? (i.wd = a.d - (a.n.rWallDist + 0.2)) : (i.wd = a.d - a.n.rWallDist),
                                (i.wn = a.n.n),
                                (i.ws = a.s)),
                            a.d < a.w ? (this.cellClass.paved ? (i.h = a.y) : (i.h = this.loadedCells[s][n].lookupHeight(e, t)), (i.f = Tt), (i.r = !0)) : (a.d < a.w + Ht && (i.f = Gt), (i.h = this.loadedCells[s][n].lookupHeight(e, t))),
                            i
                        );
                    }
                    return (i.h = this.heightmap.getXZ(e, t)), (i.n.length = 0), i.n.push(0, 1, 0), i;
                }
                testHeight(e, t) {
                    let i = Math.floor(e / zt),
                        s = Math.floor(t / zt);
                    if (this.loadedCells[i] && this.loadedCells[i][s]) {
                        let n = _t(e, t, this.loadedCells[i][s].originNode, !0);
                        return n.d < n.w ? n.y : this.loadedCells[i][s].lerpHeight(e, t, n);
                    }
                    return this.heightmap.getXZ(e, t);
                }
                getCoords(e) {
                    return { x: Math.floor(e.x / zt), y: 0, z: Math.floor(e.z / zt) };
                }
                getOrigin(e) {
                    return { x: Math.floor(e.x / zt) * zt, y: 0, z: Math.floor(e.z / zt) * zt };
                }
                getCell(e, t) {
                    let i = this.cells[e];
                    if (i.length && (i[i.length - 1].retired || this.seenIndex - i[i.length - 1].originIndex > Rt)) {
                        var s, n;
                        let e = i.pop();
                        return (
                            (null === (s = this.loadedCells[e.coords.x]) || void 0 === s ? void 0 : s[e.coords.z]) &&
                                this.loadedCells[e.coords.x][e.coords.z].lod == e.lod &&
                                (delete this.loadedCells[e.coords.x][e.coords.z], t != e.coords.x && 0 == Object.keys(this.loadedCells[e.coords.x]).length && delete this.loadedCells[e.coords.x]),
                            (null === (n = this.activeCells[e.coords.x]) || void 0 === n ? void 0 : n[e.coords.z]) &&
                                this.activeCells[e.coords.x][e.coords.z].lod == e.lod &&
                                ((!this.rearNode || e.originNode.i > this.rearNode.i) &&
                                    ((this.rearNode = e.originNode), this.despawnBarrier.position.copy(this.rearNode.next.p), (this.despawnBarrier.position.y += 1), (this.despawnBarrier.rotation.y = 0.5 * Math.PI - this.rearNode.next.a)),
                                delete this.activeCells[e.coords.x][e.coords.z],
                                t !== e.coords.x && 0 == Object.keys(this.activeCells[e.coords.x]).length && delete this.activeCells[e.coords.x]),
                            e
                        );
                    }
                    {
                        let t = new this.cellClass(e, this.lods[e].res, this.heightmap);
                        return this.counts[e]++, t;
                    }
                }
                getTileset(e) {
                    let t,
                        i = this.tilesets[e];
                    if (i.length) {
                        if (((t = i[0]), t.nextTileIndex <= t.maxTileIndex)) return t;
                        if (i.length > 1 && ((t = i[i.length - 1]), this.seenIndex >= t.retireIndex)) return i.unshift(i.pop()), i[0].reset(), i[0];
                    }
                    return (t = new pl(e, this.lods[e].res, this.lods[e].tileSize, i.length, this.groundMaterial)), this.container.add(t.mesh), i.unshift(t), (en["nearcell-" + e] = i.length), i[0];
                }
                initialise() {
                    let e, t;
                    for (this.despawnBarrier.position.copy($t.head.p), this.despawnBarrier.position.y += 1, this.despawnBarrier.rotation.y = 0.5 * Math.PI - $t.head.a, e = 1; e >= 0; e--) {
                        let i, s, n, a, o, r;
                        (t = this.lods[e]), (t.node = $t.head), (i = this.getCoords(t.node.p));
                        let h = t.tiles;
                        for (s = -h; s <= h; s++)
                            for (a = i.x + s, n = -h; n <= h; n++)
                                (o = i.z + n),
                                    a in this.loadedCells || (this.loadedCells[a] = {}),
                                    o in this.loadedCells[a] && this.loadedCells[a][o].lod,
                                    (r = this.getCell(e)),
                                    r.initGeneration(t.node, { x: a, z: o }, this.getTileset(e), !0, this.heightmap),
                                    this.cells[e].unshift(r),
                                    (this.loadedCells[a][o] = r),
                                    a in this.activeCells || (this.activeCells[a] = {}),
                                    (this.activeCells[a][o] = r);
                        (t.prevCheck.x = i.x), (t.prevCheck.z = i.z);
                    }
                }
                progressNodes(e = !1, t = 0, i = 1) {
                    let s, n;
                    for (gl.finished = 0, gl.l = i; gl.l >= t; gl.l--)
                        if (((gl.lod = this.lods[gl.l]), gl.lod.node.i >= this.seenIndex + gl.lod.horizon)) gl.finished++;
                        else if (((gl.lod.node = gl.lod.node.next), (gl.cs = this.getCoords(gl.lod.node.p)), gl.cs.x != gl.lod.prevCheck.x || gl.cs.z != gl.lod.prevCheck.z)) {
                            for (gl.dx = gl.cs.x - gl.lod.prevCheck.x, gl.dz = gl.cs.z - gl.lod.prevCheck.z, gl.tf = gl.lod.tiles, gl.i = -gl.tf; gl.i <= gl.tf; gl.i++)
                                0 !== gl.dx &&
                                    ((s = gl.cs.x + gl.dx * gl.tf),
                                    (n = gl.cs.z + gl.i),
                                    s in this.loadedCells || (this.loadedCells[s] = {}),
                                    (!(n in this.loadedCells[s]) || this.loadedCells[s][n].lod < gl.l) &&
                                        ((gl.c = this.getCell(gl.l, s)),
                                        gl.c.initGeneration(gl.lod.node, { x: s, z: n }, this.getTileset(gl.l), e, this.heightmap),
                                        (this.hadLoadedLod = !1),
                                        this.loadedCells[s][n] && this.loadedCells[s][n].lod < gl.l && (this.hadLoadedLod = !0),
                                        (this.loadedCells[s][n] = gl.c),
                                        e
                                            ? (this.hadLoadedLod,
                                              this.cells[gl.l].unshift(gl.c),
                                              s in this.activeCells ? this.activeCells[s][n] && gl.c.tileset.registerRedrawCell(this.activeCells[s][n]) : (this.activeCells[s] = {}),
                                              (this.activeCells[s][n] = gl.c))
                                            : this.stagedCells.unshift(gl.c))),
                                    0 !== gl.dz &&
                                        ((s = gl.cs.x + gl.i),
                                        (n = gl.cs.z + gl.dz * gl.tf),
                                        s in this.loadedCells || (this.loadedCells[s] = {}),
                                        (!(n in this.loadedCells[s]) || this.loadedCells[s][n].lod < gl.l) &&
                                            ((gl.c = this.getCell(gl.l, s)),
                                            gl.c.initGeneration(gl.lod.node, { x: s, z: n }, this.getTileset(gl.l), e, this.heightmap),
                                            (this.hadLoadedLod = !1),
                                            this.loadedCells[s][n] && this.loadedCells[s][n].lod < gl.l && (this.hadLoadedLod = !0),
                                            (this.loadedCells[s][n] = gl.c),
                                            e
                                                ? (this.hadLoadedLod,
                                                  this.cells[gl.l].unshift(gl.c),
                                                  s in this.activeCells ? this.activeCells[s][n] && gl.c.tileset.registerRedrawCell(this.activeCells[s][n]) : (this.activeCells[s] = {}),
                                                  (this.activeCells[s][n] = gl.c))
                                                : this.stagedCells.unshift(gl.c)));
                            (gl.lod.prevCheck.x = gl.cs.x), (gl.lod.prevCheck.z = gl.cs.z);
                        }
                    return gl.finished < 2 - t;
                }
                update() {
                    if (this.seenIndex < $t.vehicleIndex) this.seenIndex++, this.progressNodes();
                    else if (this.stagedCells.length)
                        for (gl.canPop = !0, gl.max = this.stagedCells.length / 2 + 3, gl.s = this.stagedCells.length - 1; gl.s >= 0 && !(--gl.max <= 0); gl.s--)
                            if (this.stagedCells[gl.s].generate() && gl.canPop) {
                                if (((gl.c = this.stagedCells.pop()), this.cells[gl.c.lod].unshift(gl.c), this.activeCells[gl.c.coords.x])) {
                                    if (this.activeCells[gl.c.coords.x][gl.c.coords.z]) {
                                        if (!(this.activeCells[gl.c.coords.x][gl.c.coords.z].lod < gl.c.lod)) {
                                            gl.c.retire();
                                            continue;
                                        }
                                        gl.c.tileset.registerRedrawCell(this.activeCells[gl.c.coords.x][gl.c.coords.z]);
                                    }
                                } else this.activeCells[gl.c.coords.x] = {};
                                gl.c.display(), (this.activeCells[gl.c.coords.x][gl.c.coords.z] = gl.c);
                            } else gl.canPop = !1;
                    en["nearcell-staged"] = this.stagedCells.length;
                }
            };
            let xl = 250,
                vl = 50;
            const fl = Math.floor(2),
                wl = {},
                bl = {},
                Al = {},
                yl = {};
            class Il {
                constructor(e, t, i) {
                    (this.retiredCells = []),
                        (this.loadedCells = {}),
                        (this.seenCells = {}),
                        (this.tf = Math.floor(2.5)),
                        (this.prevTile = { x: -99999, z: -99999 }),
                        (this.overlapCheckTile = { x: 0, z: 0 }),
                        (this.overlapPrevCheck = { x: -99999, z: -99999 }),
                        (this.overlapRedrawTiles = []),
                        (this.stagedTilesets = []),
                        (this.stagingCells = []),
                        (this.preStagedCells = []),
                        (this.upcomingTilesets = []),
                        (this.loadState = { init: !1, overlap: !1, tileset: !1 }),
                        (this.preStagedCellMap = {}),
                        (this.cellCount = 0),
                        (this.heightmap = e),
                        (this.groundMaterial = t),
                        (this.container = new r.G()),
                        (this.cellClass = i),
                        (this.container.matrixAutoUpdate = !1),
                        (this.seenIndex = $t.vehicleIndex - 1),
                        this.initialise();
                }
                destroy() {
                    this.container.traverse((e) => {
                        e.isMesh && e.geometry.dispose();
                    }),
                        this.container.clear();
                }
                reset(e) {
                    (this.heightmap = e), (this.seenIndex = $t.head.i);
                    let t = Object.keys(wl);
                    for (let s of t) delete wl[s];
                    (this.upcomingTilesets.length = 0), (this.stagedTilesets.length = 0), (this.prevTile.x = -9999), (this.prevTile.z = -9999);
                    let i = Object.keys(this.loadedCells);
                    for (let s of i) {
                        let e = Object.keys(this.loadedCells[s]);
                        for (let t of e) this.retireCell(s, t);
                    }
                    (this.stagingCells.length = 0), this.initialise();
                }
                loader() {
                    return this.stagingCells.length ? (this.stagingCells[0].generate() && this.stagingCells.shift(), (this.stageInitCount - this.stagingCells.length) / this.stageInitCount) : 1;
                }
                initialise() {
                    (xl = Math.min((At / 10) * 2.5, 990)), (vl = Math.max(10, xl / 4));
                    let e = Object.keys(wl);
                    for (let i of e) delete wl[i];
                    let t = Object.keys(bl);
                    for (let i of t) delete bl[i], delete Al[i];
                    for (
                        this.checkNode = $t.vehicleNode, this.checkIndex = this.checkNode.i, this.seenIndex = $t.vehicleIndex - 1, this.initialiseOverlapMap(), this.checkInitialTileset(this.checkNode), this.checkStageTileset();
                        this.preStagedCells.length;

                    )
                        (yl.psc = this.preStagedCells.shift()), delete this.preStagedCellMap[this.getCellKey(yl.psc[0], yl.psc[1])], this.stageCell(yl.psc);
                    (this.stageInitCount = this.stagingCells.length), this.checkDrawTileset();
                }
                handleMidlineReset() {
                    if (this.checkIndex > $t.tail.i)
                        throw (console.error("Midline reset will affect fargrid lookahead"), (this.checkNode = $t.vehicleNode), (this.checkIndex = $t.vehicleIndex), new Error("Midline stuck at node " + $t.tail.i));
                    if (this.overlapCheckNode.i >= $t.tail.i) {
                        let e = Object.keys(bl);
                        for (let t of e) {
                            let e = Object.keys(bl[t]);
                            for (let i of e) bl[t][i].i > $t.tail.i && (delete bl[t][i], delete Al[t][i]);
                        }
                        this.overlapCheckNode = $t.tail;
                    }
                    this.seenIndex = Math.min($t.vehicleIndex, this.seenIndex);
                }
                retireCell(e, t) {
                    this.seenCells[e] && (delete this.seenCells[e][t], 0 == Object.keys(this.seenCells[e]).length && delete this.seenCells[e]);
                    let i = this.loadedCells[e][t];
                    delete this.loadedCells[e][t], 0 == Object.keys(this.loadedCells[e]).length && delete this.loadedCells[e], i.retire(), this.retiredCells.push(i);
                }
                checkActiveCell(e, t) {
                    var i, s;
                    let n = Math.floor(e / At),
                        a = Math.floor(t / At);
                    return !!(null === (i = this.loadedCells[n]) || void 0 === i || null === (s = i[a]) || void 0 === s ? void 0 : s.mesh.visible);
                }
                addOverlap(e, t, i, s, n = null, a = 1) {
                    wl[e] || (wl[e] = {}),
                        wl[e][t] || (wl[e][t] = {}),
                        wl[e][t][i] || (wl[e][t][i] = {}),
                        (!wl[e][t][i][s] || wl[e][t][i][s] < a) && (wl[e][t][i][s] = a),
                        null !== n && (!wl[e][t][i][n] || wl[e][t][i][n] < a) && (wl[e][t][i][n] = a),
                        bl[e] || ((bl[e] = {}), (Al[e] = {})),
                        bl[e][t] || (bl[e][t] = this.overlapCheckNode),
                        (Al[e][t] = this.overlapCheckNode);
                }
                applyTileOverlap(e, t, i, s, n) {
                    let a = i + 1,
                        o = s + 1;
                    this.addOverlap(e, t, i, s, o, n),
                        this.addOverlap(e, t, a, s, o, n),
                        0 == i
                            ? (this.addOverlap(e - 1, t, yt, s, s + 1, n), 0 == s ? this.addOverlap(e - 1, t - 1, yt, yt, null, n) : o == yt && this.addOverlap(e - 1, t + 1, yt, 0, null, n))
                            : a == yt && (this.addOverlap(e + 1, t, 0, s, s + 1, n), 0 == s ? this.addOverlap(e + 1, t - 1, 0, yt, null, n) : o == yt && this.addOverlap(e + 1, t + 1, 0, 0, null, n)),
                        0 == s ? (this.addOverlap(e, t - 1, i, yt, null, n), this.addOverlap(e, t - 1, i + 1, yt, null, n)) : o == yt && (this.addOverlap(e, t + 1, i, 0, null, n), this.addOverlap(e, t + 1, i + 1, 0, null, n));
                }
                initialiseOverlapMap() {
                    this.overlapCheckNode = $t.head;
                    let e = Math.floor(this.overlapCheckNode.p.x / kt),
                        t = Math.floor(this.overlapCheckNode.p.z / kt);
                    (this.overlapPrevCheck.x = e), (this.overlapPrevCheck.z = t);
                    let i,
                        s,
                        n,
                        a,
                        o,
                        r,
                        h = Math.floor(2);
                    for (let l = -h; l <= h; l++)
                        for (let d = -h; d <= h; d++)
                            (i = ((e + l) * kt) / At),
                                (s = ((t + d) * kt) / At),
                                (n = Math.floor(i)),
                                (a = Math.floor(s)),
                                (o = (e + l) % yt),
                                (r = (t + d) % yt),
                                o < 0 && (o += yt),
                                r < 0 && (r += yt),
                                l == -h || l == h || d == -h || d == h ? this.applyTileOverlap(n, a, o, r, -1) : this.applyTileOverlap(n, a, o, r, Math.abs(this.overlapCheckNode.g));
                    for (this.overlapCheckNode = this.overlapCheckNode.next; this.overlapCheckNode.i < $t.vehicleIndex + 1e3; ) this.updateOverlapMap();
                }
                updateOverlapRedraw() {
                    for (yl.fz2 = At / 2, yl.oci = this.overlapRedrawTiles.length - 1; yl.oci >= 0; yl.oci--) {
                        var e, t, i, s, n;
                        if (
                            ((yl.ocx = this.overlapRedrawTiles[yl.oci][0]),
                            (yl.ocz = this.overlapRedrawTiles[yl.oci][1]),
                            (yl.cx = Al[yl.ocx][yl.ocz].p.x),
                            (yl.cz = Al[yl.ocx][yl.ocz].p.z),
                            (yl.cx - this.overlapCheckNode.p.x) * (yl.cx - this.overlapCheckNode.p.x) + (yl.cz - this.overlapCheckNode.p.z) * (yl.cz - this.overlapCheckNode.p.z) > 4e4)
                        )
                            if ((this.overlapRedrawTiles.splice(yl.oci, 1), null === (e = this.loadedCells[yl.ocx]) || void 0 === e ? void 0 : e[yl.ocz]))
                                if (
                                    (this.loadedCells[yl.ocx][yl.ocz].resetOverlapMap(null === (t = Al[yl.ocx]) || void 0 === t ? void 0 : t[yl.ocz], null === (i = wl[yl.ocx]) || void 0 === i ? void 0 : i[yl.ocz]),
                                    this.loadedCells[yl.ocx][yl.ocz].ready)
                                )
                                    this.stagingCells.push(this.loadedCells[yl.ocx][yl.ocz]);
                                else {
                                    let e = this.loadedCells[yl.ocx][yl.ocz];
                                    console.log(e.genRow, e.overlapIndex, e.treeGenIndex, e.farWallRenderer.ready);
                                }
                            else console.log(null === (s = this.loadedCells[yl.ocx]) || void 0 === s || null === (n = s[yl.ocz]) || void 0 === n ? void 0 : n.ready);
                    }
                }
                updateOverlapMap() {
                    if (((yl.nx = Math.floor(this.overlapCheckNode.p.x / kt)), (yl.nz = Math.floor(this.overlapCheckNode.p.z / kt)), yl.nx == this.overlapPrevCheck.x && yl.nz == this.overlapPrevCheck.z && this.overlapCheckNode.next))
                        return void (this.overlapCheckNode = this.overlapCheckNode.next);
                    let e, t, i, s;
                    this.overlapRedrawTiles.length && this.updateOverlapRedraw(), (yl.dx = yl.nx - this.overlapPrevCheck.x), (yl.dz = yl.nz - this.overlapPrevCheck.z), (this.overlapPrevCheck.x = yl.nx), (this.overlapPrevCheck.z = yl.nz);
                    let n,
                        a,
                        o,
                        r = fl;
                    for (o = 1 - r; o <= r; o++) {
                        var h, l;
                        if (0 != yl.dx)
                            (n = this.overlapCheckNode.p.x + yl.dx * r * kt),
                                (a = this.overlapCheckNode.p.z + o * kt),
                                (e = Math.floor(n / At)),
                                (t = Math.floor(a / At)),
                                e in this.seenCells || (this.seenCells[e] = {}),
                                (this.seenCells[e][t] = this.overlapCheckNode.i),
                                (null === (h = this.loadedCells[e]) || void 0 === h ? void 0 : h[t]) && !this.loadedCells[e][t].needsOverlapRedraw && ((this.loadedCells[e][t].needsOverlapRedraw = !0), this.overlapRedrawTiles.push([e, t])),
                                (i = Math.floor((n - e * At) / kt)),
                                (s = Math.floor((a - t * At) / kt)),
                                this.applyTileOverlap(e, t, i, s, -1);
                        if (0 !== yl.dz)
                            (n = this.overlapCheckNode.p.x + o * kt),
                                (a = this.overlapCheckNode.p.z + yl.dz * r * kt),
                                (e = Math.floor(n / At)),
                                (t = Math.floor(a / At)),
                                e in this.seenCells || (this.seenCells[e] = {}),
                                (this.seenCells[e][t] = this.overlapCheckNode.i),
                                (null === (l = this.loadedCells[e]) || void 0 === l ? void 0 : l[t]) && !this.loadedCells[e][t].needsOverlapRedraw && ((this.loadedCells[e][t].needsOverlapRedraw = !0), this.overlapRedrawTiles.push([e, t])),
                                (i = Math.floor((n - e * At) / kt)),
                                (s = Math.floor((a - t * At) / kt)),
                                this.applyTileOverlap(e, t, i, s, -1);
                    }
                    for (r -= 1, o = -r; o <= r; o++)
                        0 != yl.dx &&
                            ((n = this.overlapCheckNode.p.x + yl.dx * r * kt),
                            (a = this.overlapCheckNode.p.z + o * kt),
                            (e = Math.floor(n / At)),
                            (t = Math.floor(a / At)),
                            e in this.seenCells || (this.seenCells[e] = {}),
                            (this.seenCells[e][t] = this.overlapCheckNode.i),
                            (i = Math.floor((n - e * At) / kt)),
                            (s = Math.floor((a - t * At) / kt)),
                            this.applyTileOverlap(e, t, i, s, Math.abs(this.overlapCheckNode.g))),
                            0 !== yl.dz &&
                                ((n = this.overlapCheckNode.p.x + o * kt),
                                (a = this.overlapCheckNode.p.z + yl.dz * r * kt),
                                (e = Math.floor(n / At)),
                                (t = Math.floor(a / At)),
                                e in this.seenCells || (this.seenCells[e] = {}),
                                (this.seenCells[e][t] = this.overlapCheckNode.i),
                                (i = Math.floor((n - e * At) / kt)),
                                (s = Math.floor((a - t * At) / kt)),
                                this.applyTileOverlap(e, t, i, s, Math.abs(this.overlapCheckNode.g)));
                    this.overlapCheckNode.next && (this.overlapCheckNode = this.overlapCheckNode.next);
                }
                checkInitialTileset(e) {
                    let t,
                        i,
                        s,
                        n,
                        a = this.getCoords(e.p),
                        o = a.x,
                        r = a.z,
                        h = { node: e, originIndex: e.i, newTiles: [], deadTiles: [] };
                    for (t = -this.tf; t <= this.tf; t++)
                        for (s = t + o, i = -this.tf; i <= this.tf; i++)
                            (n = i + r), h.newTiles.push([s, n]), s in this.seenCells || (this.seenCells[s] = {}), (!(n in this.seenCells) || e.i > this.seenCells[s][n]) && (this.seenCells[s][n] = e.i);
                    this.upcomingTilesets.push(h), (this.prevTile.x = o), (this.prevTile.z = r);
                }
                checkTilesetForNode(e) {
                    let t = this.getCoords(e.p),
                        i = t.x,
                        s = t.z;
                    if (i === this.prevTile.x && s === this.prevTile.z) return;
                    let n,
                        a,
                        o,
                        r,
                        h,
                        l,
                        d,
                        c,
                        p = i - this.prevTile.x,
                        u = s - this.prevTile.z,
                        g = { node: e, originIndex: this.checkIndex, newTiles: [], deadTiles: [] };
                    for (
                        0 !== p && ((h = this.prevTile.x + p * (this.tf + 1)), (l = this.prevTile.x - p * this.tf)), 0 !== u && ((d = this.prevTile.z + u * (this.tf + 1)), (c = this.prevTile.z - u * this.tf)), n = -this.tf;
                        n <= this.tf;
                        n++
                    )
                        for (o = n + i, a = -this.tf; a <= this.tf; a++)
                            (r = a + s),
                                0 !== p && (o == h && g.newTiles.push([h, r]), o - p == l && g.deadTiles.push([l, r - u])),
                                0 !== u && (r == d && g.newTiles.push([o, d]), r - u == c && ((void 0 !== l && o - p === l) || g.deadTiles.push([o - p, c]))),
                                o in this.seenCells || (this.seenCells[o] = {}),
                                (!(r in this.seenCells[o]) || this.checkIndex > this.seenCells[o][r]) && (this.seenCells[o][r] = this.checkIndex);
                    this.upcomingTilesets.push(g), (this.prevTile.x = i), (this.prevTile.z = s);
                }
                getCellKey(e, t) {
                    return e + ":" + t;
                }
                checkStageTileset() {
                    if (this.upcomingTilesets[0].originIndex < $t.vehicleIndex + vl) {
                        let e,
                            t,
                            i,
                            s,
                            n = this.upcomingTilesets.shift();
                        for (i of n.newTiles)
                            (e = i[0]), (t = i[1]), (s = this.getCellKey(e, t)), (e in this.loadedCells && t in this.loadedCells[e]) || s in this.preStagedCellMap || ((this.preStagedCellMap[s] = !0), this.preStagedCells.push([e, t]));
                        this.stagedTilesets.push(n);
                    }
                }
                stageCell(e) {
                    var t, i, s, n;
                    (yl.c = this.getCell()),
                        (yl.x = e[0]),
                        (yl.z = e[1]),
                        yl.x in this.loadedCells || (this.loadedCells[yl.x] = {}),
                        (yl.redraw = !!(null === (t = this.loadedCells[yl.x][yl.z]) || void 0 === t ? void 0 : t.needsOverlapRedraw)),
                        yl.c.initGeneration(
                            yl.x,
                            yl.z,
                            null === (i = bl[yl.x]) || void 0 === i ? void 0 : i[yl.z],
                            null === (s = Al[yl.x]) || void 0 === s ? void 0 : s[yl.z],
                            null === (n = wl[yl.x]) || void 0 === n ? void 0 : n[yl.z],
                            this.heightmap,
                            yl.redraw
                        ),
                        (this.loadedCells[yl.x][yl.z] = yl.c),
                        this.stagingCells.push(yl.c);
                }
                checkDrawTileset() {
                    if ($t.vehicleIndex >= this.stagedTilesets[0].originIndex) {
                        let i,
                            s = this.stagedTilesets[0];
                        for (i of s.newTiles) {
                            var e, t;
                            if (!(null === (e = this.loadedCells[i[0]]) || void 0 === e || null === (t = e[i[1]]) || void 0 === t ? void 0 : t.ready)) return;
                            this.loadedCells[i[0]][i[1]].display();
                        }
                        for (i of s.deadTiles) {
                            let e = i[0],
                                t = i[1];
                            e in this.seenCells && this.seenCells[e][t] < s.originIndex
                                ? (this.retireCell(e, t),
                                  wl[e] && (delete wl[e][t], 0 == Object.keys(wl[e]).length && delete wl[e]),
                                  bl[e] && (delete bl[e][t], delete Al[e][t], 0 == Object.keys(bl[e]).length && (delete bl[e], delete Al[e])))
                                : this.loadedCells[e][t].hide();
                        }
                        this.stagedTilesets.shift();
                    }
                }
                update() {
                    if (this.checkIndex < $t.vehicleIndex + xl && this.checkNode.next) (this.checkNode = this.checkNode.next), (this.checkIndex = this.checkNode.i), this.checkTilesetForNode(this.checkNode);
                    else if (this.overlapCheckNode.i < $t.vehicleIndex + 1e3) this.updateOverlapMap();
                    else if (this.preStagedCells.length) (yl.psc = this.preStagedCells.shift()), delete this.preStagedCellMap[this.getCellKey(yl.psc[0], yl.psc[1])], this.stageCell(yl.psc);
                    else if (this.stagingCells.length) {
                        for (yl.max = this.stagingCells.length / 2 + 2, yl.c = 0; yl.c < this.stagingCells.length && !(--yl.max <= 0); yl.c++) this.stagingCells[yl.c].generate() && (this.stagingCells.splice(yl.c, 1), yl.c--);
                        en["farcells-staged"] = this.stagingCells.length;
                    }
                    this.seenIndex < $t.vehicleIndex && (this.upcomingTilesets.length && this.checkStageTileset(), this.stagedTilesets.length && this.checkDrawTileset(), this.seenIndex++);
                }
                getCoords(e) {
                    return { x: Math.floor(e.x / At), y: 0, z: Math.floor(e.z / At) };
                }
                getOrigin(e) {
                    return { x: Math.floor(e.x / At) * At, y: 0, z: Math.floor(e.z / At) * At };
                }
                getCell() {
                    if (this.retiredCells.length) return this.retiredCells.pop();
                    this.cellCount++;
                    let e = new this.cellClass(this.heightmap, this.groundMaterial);
                    return (en.farcells = this.cellCount), this.container.add(e.mesh), e;
                }
            }
            var Sl = new (class {
                constructor() {
                    (this.arng = new window.alea(Be)),
                        (this.container = new r.G()),
                        (this.scene = null),
                        (this.envLayer = new r.G()),
                        (this.vehicleOrigin = new r.W()),
                        (this.loadProg = 0),
                        (this.sceneReady = !1),
                        (this.checkPerformance = !1),
                        (this.topographyLoaderInit = this._topographyLoaderInit.bind(this)),
                        (this.topographyReset = this._topographyReset.bind(this)),
                        (this.topographyLoader = this._topographyLoader.bind(this)),
                        (this.sceneReset = this._sceneReset.bind(this)),
                        (this.sceneLoaderInit = this._sceneLoaderInit.bind(this)),
                        (this.sceneLoader = this._sceneLoader.bind(this)),
                        (this.updateConfig = this._updateConfig.bind(this)),
                        (this.farGridLoaderInit = this._farGridLoaderInit.bind(this)),
                        (this.farGridReset = this._farGridReset.bind(this)),
                        (this.farGridLoader = this._farGridLoader.bind(this)),
                        (this.nearGridReset = this._nearGridReset.bind(this)),
                        (this.nearGridLoaderInit = this._nearGridLoaderInit.bind(this)),
                        (this.nearGridLoader = this._nearGridLoader.bind(this)),
                        (this.postGridLoader = this._postGridLoader.bind(this)),
                        (this.setSceneTopographyBound = this.setSceneToplogy.bind(this)),
                        (this.setSceneSkinBound = this.setSceneSkin.bind(this)),
                        (this.setSceneWeatherIndexBound = this.setSceneWeatherIndex.bind(this)),
                        (this.sunOffset = new r.W()),
                        (this.checkTimer = 0.2),
                        (this.lastCheckTime = -1),
                        (this.skySpeed = 5),
                        (this.skyOffset = 225),
                        Ih.addListener("topography", this.setSceneTopographyBound),
                        Ih.addListener("skin", this.setSceneSkinBound),
                        Ih.addListener("weatherIndex", this.setSceneWeatherIndexBound),
                        this.container.add(this.envLayer),
                        rt(Ih.value.viewLodIndex),
                        ht(Ih.value.detailLodIndex);
                }
                nextSkin() {
                    let e = Ih.value.sceneName,
                        t = Ih.value.skin,
                        i = Ih.value.weatherIndex,
                        s = Ih.sceneMeta.scenes[e];
                    if ((i++, s.skinWeathers[t].length > i)) Ih.set("weatherIndex", i);
                    else {
                        let e = s.skins.indexOf(t);
                        Ih.set("weatherIndex", 0), Ih.set("skin", s.skins[(e + 1) % s.skins.length]);
                    }
                }
                prevSkin() {
                    let e = Ih.value.sceneName,
                        t = Ih.value.skin,
                        i = Ih.value.weatherIndex,
                        s = Ih.sceneMeta.scenes[e],
                        n = s.skinWeathers[t];
                    if ((i--, i >= 0)) Ih.set("weatherIndex", i);
                    else {
                        let e = s.skins.indexOf(t) - 1;
                        e < 0 && (e = s.skins.length - 1), Ih.set("weatherIndex", n.length - 1), Ih.set("skin", s.skins[e]);
                    }
                }
                initScene(e) {
                    let t = e;
                    this.scene && (this.envLayer.remove(this.scene.container), this.scene.destroy(), delete this.scene),
                        (this.scene = new t(this.getNearGridHeightAt.bind(this))),
                        this.envLayer.add(this.scene.container),
                        this.scene.sanitiseConfig(Ih),
                        this.scene.initialise(Be, Ih.value, () => this.onSceneReady());
                }
                onSceneReady() {
                    (this.loadProg = 0),
                        (this.sceneReady = !0),
                        (this.heightmap = this.scene.heightmap),
                        this.midline && (this.container.remove(this.midline.container), this.midline.destroy()),
                        (this.midline = new ol()),
                        this.getOriginPose(),
                        this.midline.initialise(Be, this.heightmap, this.vehicleOrigin),
                        (this.midlineAttempts = 0),
                        (function () {
                            let e = window,
                                t = atob("c2xvd3JvYWRzLmlv");
                            e.location.host.indexOf(t) < 0 || (e.location.host.length, t.length);
                        })(),
                        Uh.sendUpdate("skinChange", this.scene.getSkinName(Ih.value.skin));
                }
                _topographyLoaderInit() {
                    (this.sceneReady = !1),
                        (this.loadProg = 0),
                        (this.loadTime = Date.now()),
                        window.localStorage.getItem("seed_failed") && (console.log("BAD SEED"), window.localStorage.removeItem("seed_failed")),
                        (this.checkPerformance = !1),
                        window.localStorage.getItem("analytics_returningPlayer") || (console.log("Env: Analysing performance for dynamic config"), (this.checkPerformance = !0)),
                        this.initScene(mh[Ih.value.sceneName]);
                }
                _topographyReset() {
                    (this.sceneReady = !1), this.scene.reset(Be, Ih.value, () => this.onSceneReady);
                }
                _topographyLoader() {
                    return this.sceneReady ? this.buildMidline() : 0;
                }
                _sceneReset() {}
                _sceneLoaderInit() {
                    console.log(" - Topography initialised in", Date.now() - this.loadTime), (Uh.midlineLoadTime = Date.now() - this.loadTime), Uh.playerProfile && (Uh.playerProfile.midlineLoadTime = Uh.midlineLoadTime);
                }
                _sceneLoader() {
                    return (this.loadProg = this.scene.loader()), this.loadProg >= 1 && (this.scene.setScene(Ih.value), this.initSky(), this.initRoad()), this.loadProg;
                }
                _updateConfig() {
                    rt(Ih.value.viewLodIndex), ht(Ih.value.detailLodIndex), this.scene.updateConfig(Ih.value.viewLodIndex, Ih.value.detailLodIndex), this.scene.setScene(Ih.value);
                    let e = 2 * Mt;
                    this.sky.scale.set(e, e, e), Ih.value.detailLodIndex * Ih.value.viewLodIndex == 0 ? (this.sky.visible = !1) : (this.sky.visible = !0), (Hs.far = Mt), Hs.updateProjectionMatrix();
                }
                _farGridLoaderInit() {
                    (this.loadTime = Date.now()),
                        this.farGrid && (this.farGrid.destroy(), this.envLayer.remove(this.farGrid.container), delete this.farGrid),
                        (this.farGrid = new Il(this.heightmap, this.scene.groundMaterial, this.scene.farGridCell)),
                        this.envLayer.add(this.farGrid.container);
                }
                _farGridReset() {
                    this.farGrid.reset(this.heightmap);
                }
                _farGridLoader() {
                    return (this.loadProg = this.farGrid.loader()), this.loadProg;
                }
                _nearGridReset() {
                    this.nearGrid.reset(this.heightmap);
                }
                _nearGridLoaderInit() {
                    console.log(" - Far grid initialised in", Date.now() - this.loadTime),
                        this.nearGrid && (this.nearGrid.destroy(), this.envLayer.remove(this.nearGrid.container), delete this.nearGrid),
                        (this.nearGrid = new ml(this.heightmap, this.scene.groundMaterial, this.scene.nearGridCell)),
                        this.envLayer.add(this.nearGrid.container);
                }
                _nearGridLoader() {
                    return (
                        (this.loadProg = this.nearGrid.loader()),
                        1 == this.loadProg &&
                            (console.log(" - Both grids initialised in", Date.now() - this.loadTime),
                            (Uh.envLoadTime = Date.now() - this.loadTime),
                            Uh.playerProfile && (Uh.playerProfile.envLoadTime = Uh.envLoadTime),
                            Uh.sendUpdate("loadTimes", { midline: Uh.midlineLoadTime, env: Uh.envLoadTime })),
                        this.loadProg
                    );
                }
                _postGridLoader() {
                    return this.scene.onGridReady(), 1;
                }
                buildMidline() {
                    return (
                        (this.loadProg = this.midline.loader()),
                        this.loadProg < 1
                            ? this.loadProg < 0
                                ? (this.midlineAttempts++,
                                  this.midlineAttempts >= 25 || (0 == Ih.initialNode && this.midlineAttempts >= 4)
                                      ? (console.log("Too many failed - reloading"), void Ze(Date.now(), !0))
                                      : (this.getOriginPose(this.midlineAttempts), this.vehicleOrigin.x + this.vehicleOrigin.z > 1e6 ? void Ze(Date.now(), !0) : (this.midline.initialise(Be, this.heightmap, this.vehicleOrigin), 0)))
                                : this.loadProg
                            : (this.midline.finalise(), this.scene.onMidlineReady(), (this.loadProg = 0), 1)
                    );
                }
                setSceneToplogy(e) {
                    this.scene.setTopography(e);
                }
                setSceneSkin(e) {
                    this.scene.setSkin(e), Uh.sendUpdate("skinChange", this.scene.getSkinName(e));
                }
                setSceneWeatherIndex(e) {
                    this.scene.setWeatherIndex(e), Uh.sendUpdate("weatherChange", e);
                }
                initSky() {
                    if (this.sky) return;
                    let e = 2 * Mt;
                    (this.sky = new r.B(new r.J(1, 1, 10, 10), Xt)),
                        (this.sky.rotation.x = Math.PI / 2),
                        (this.sky.position.y = 200),
                        (this.sky.renderOrder = -100),
                        this.sky.scale.set(e, e, e),
                        (this.sky.frustumCulled = !1),
                        this.envLayer.add(this.sky);
                }
                initRoad() {
                    this.roadController && (this.roadController.destroy(), this.container.remove(this.roadController.container), delete this.roadController),
                        (this.roadController = new hl()),
                        this.container.add(this.roadController.container);
                }
                getHeightAt(e, t, i) {
                    return this.heightmap.getXZ(e, t, i);
                }
                getNearGridHeightAt(e, t) {
                    return this.nearGrid.testHeight(e, t);
                }
                testGround(e, t) {
                    return this.nearGrid.testGround(e.x, e.z, t);
                }
                testFarGrid(e, t) {
                    return this.farGrid.checkActiveCell(e, t);
                }
                getHeight(e, t, i) {
                    let s = this.nearGrid.testHeight(e.x, e.z);
                    return s || this.heightmap.getXZ(e.x, e.z, i);
                }
                getOriginPose(e = 0) {
                    let t = new window.alea(Be),
                        i = 0 + 500 * e,
                        s = 500 * e,
                        n = this.getHeightAt(i, s),
                        a = this.getHeightAt(i + 1, s + 1),
                        o = Math.abs((a - n) / 1.414);
                    for (; n < 20 || o > 0.5; ) (i += 100 * Math.abs(t())), (s += 100 * Math.abs(t())), (n = this.getHeightAt(i, s)), (a = this.getHeightAt(i + 1, s + 1)), (o = Math.abs((a - n) / 1.414));
                    return (n = this.getHeightAt(i, s)), this.vehicleOrigin.set(i, n, s), this.vehicleOrigin;
                }
                update(e, t) {
                    if (this.midline.update()) {
                        try {
                            this.roadController.update();
                        } catch (Au) {
                            throw ((Au.cause = "roadController"), Au);
                        }
                        try {
                            this.scene.update(e, t);
                        } catch (Au) {
                            throw ((Au.cause = "sceneController"), Au);
                        }
                        try {
                            this.nearGrid.update();
                        } catch (Au) {
                            throw ((Au.cause = "nearGrid"), Au);
                        }
                        try {
                            this.farGrid.update();
                        } catch (Au) {
                            throw ((Au.cause = "farGrid"), Au);
                        }
                    } else this.roadController.handleMidlineReset(), this.scene.handleMidlineReset(), this.nearGrid.handleMidlineReset(), this.farGrid.handleMidlineReset();
                    this.scene.updateAudio(), this.updateSky(e, t);
                }
                updateSky(e, t) {
                    (wt.position.x = fe.position.x + wt.sunOffset.x),
                        (wt.position.y = fe.position.y + wt.sunOffset.y),
                        (wt.position.z = fe.position.z + wt.sunOffset.z),
                        (this.sky.position.x = fe.position.x),
                        (this.sky.position.y = fe.position.y + this.skyOffset),
                        (this.sky.position.z = fe.position.z),
                        (Xt.userData.time.value = t * this.skySpeed),
                        (Xt.uniformsNeedUpdate = !0);
                }
            })();
            const Ml = {
                Chase: { name: "Near Chase", i: 0, pitch: { near: 0.3, far: 0.2 }, yOffset: { near: 0.8, far: 1 }, posOffset: new r.W(0, 0, 1.4), range: { near: 3.5, far: 4.5 }, farSpeed: 45, smoothFactor: 1.5 },
                ChaseFar: { name: "Far Chase", i: 1, pitch: { near: 0.25, far: 0.15 }, yOffset: { near: 1, far: 2 }, posOffset: new r.W(0, 0, 0), range: { near: 7, far: 10 }, farSpeed: 45, smoothFactor: 1.25 },
                FirstPerson: {
                    name: "First Person",
                    i: 2,
                    pitch: { near: 0.05, far: 0.05 },
                    yOffset: { near: 0.7, far: 0.7 },
                    posOffset: new r.W(0, 0.6, 1.4),
                    smoothFactor: 0.33,
                    range: { near: 0.75, far: 0.75 },
                    farSpeed: 45,
                    rollFactor: -0.75,
                },
                Hood: { name: "Hood", i: 5, pitch: { near: 0.05, far: 0.05 }, yOffset: { near: 0.7, far: 0.7 }, posOffset: new r.W(0, 0.45, 3.2), range: { near: 0.75, far: 0.75 }, farSpeed: 45, smoothFactor: 0.3 },
                Bonnet: { name: "Bonnet", i: 3, posOffset: new r.W(), rollFactor: -0.75 },
                Debug: { name: "Debug", i: 4, pitch: { near: 0.5, far: 0.5 }, yOffset: { near: 10, far: 20 }, posOffset: new r.W(0, 0, 0), smoothFactor: 1.5, range: { near: 40, far: 40 }, farSpeed: 45 },
            };
            let Dl = ["Chase", "ChaseFar", "FirstPerson"];
            const kl = "config-camera-mode";
            var Cl = class {
                smoothLerp(e) {
                    return -1 * (3 - 2 * (e = Math.min(1, e))) * e * e + 1;
                }
                smootherLerp(e) {
                    return ((e = Math.min(1, e)) * (6 * e - 15) + 10) * e * e * e * -1 + 1;
                }
                constructor(e) {
                    if (
                        ((this.onViewChange = () => {}),
                        (this.mode = Ml[Dl[Mh]]),
                        (this.modeIndex = 0),
                        (this.boosting = !1),
                        (this.targetFOV = 0),
                        (this.curFOV = It),
                        (this.boostFOV = It + 3),
                        (this.onFovBound = this.onFov.bind(this)),
                        (this.posOffsetX = 1),
                        (this.setVehicleSideBound = this.setVehicleSide.bind(this)),
                        (this.orientation = new r.m(0, 0, 0, "YXZ")),
                        (this.targets = { y: 0, x: 0 }),
                        (this.vCenter = new r.W()),
                        (this.camFwd = new r.W()),
                        (this.uLerpA = 0),
                        (this.uLerpB = 0),
                        (this.uDist = 0),
                        (this.uSmoothA = 0),
                        (this.uSmoothB = 0),
                        (this.uH = 0),
                        (this.uCollisionCheck = 1),
                        (this.randFrame = !1),
                        (this.onViewChange = e),
                        (this.camera = Hs),
                        (this.camera.zoom = 1),
                        this.camera.updateProjectionMatrix(),
                        this.camera.add(ue.listener),
                        fe.addListener(ge, this.reset.bind(this)),
                        fe.addListener(me, this.initVehicleAngles.bind(this)),
                        Pe.addListener("side", this.setVehicleSideBound),
                        this.setVehicleSide(Pe.value.side),
                        Ih.addListener("verticalFov", this.onFovBound),
                        window.localStorage.getItem(kl))
                    )
                        try {
                            this.modeIndex = JSON.parse(window.localStorage.getItem(kl));
                        } catch {
                            console.log("Camera: Failed to load mode from memory");
                        }
                    this.initVehicleAngles(!0);
                }
                onFov() {
                    (this.camera.fov = It), this.camera.updateProjectionMatrix();
                }
                setVehicleSide(e) {
                    this.posOffsetX = 0 == e ? -1 : 1;
                }
                initVehicleAngles(e = !1) {
                    if (!fe.cameras) return;
                    Dl = Object.keys(fe.cameras);
                    let t = fe.cameras;
                    for (let i in t) {
                        let e = Ml[i],
                            s = t[i];
                        (e.isFirstPerson = !!s.isFirstPerson),
                            (e.nearPlane = s.nearPlane || 0.35),
                            (e.pitch = s.pitch),
                            (e.yOffset = s.yOffset),
                            e.posOffset.fromArray(s.posOffset),
                            (e.range = s.range),
                            (e.farSpeed = s.farSpeed),
                            (e.smoothFactor = s.smoothFactor),
                            (e.hideVehicle = s.hideVehicle);
                    }
                    (this.modeIndex %= Dl.length), (this.mode = Ml[Dl[this.modeIndex]]), e || window.localStorage.setItem(kl, this.modeIndex), this.reset();
                }
                updateViewDist() {
                    (this.camera.far = St), this.camera.updateProjectionMatrix();
                }
                reset() {
                    let e = 0;
                    isNaN(this.orientation.y + this.targets.y) || (e = this.targets.y - this.orientation.y),
                        (e %= 2 * Math.PI),
                        (this.uLerpA = this.smoothLerp(fe.speed / this.mode.farSpeed)),
                        (this.uLerpB = 1 - this.uLerpA),
                        (this.targets.x = this.mode.pitch.near * this.uLerpA + this.mode.pitch.far * this.uLerpB + fe.pitch),
                        (this.targets.x *= -1),
                        (this.targets.y = fe.heading - Math.PI),
                        (this.targets.z = 0),
                        this.mode.rollFactor && (this.targets.z = fe.roll * this.mode.rollFactor),
                        (this.orientation.x = this.targets.x),
                        (this.orientation.y = this.targets.y - e),
                        (this.orientation.z = this.targets.z),
                        (fe.geo.visible = !this.mode.hideVehicle),
                        (this.camera.near = this.mode.nearPlane || 0.35),
                        (this.camera.fov = It),
                        this.mode.isFirstPerson ? (Qs.set(!0), (this.camera.fov *= 0.95)) : Qs.set(!1),
                        this.camera.updateProjectionMatrix();
                }
                setSize(e, t) {
                    (this.camera.aspect = e / t), this.camera.updateProjectionMatrix(), this.onViewChange();
                }
                updateFirstPerson(e) {
                    this.camera.position
                        .set(this.mode.posOffset.x * this.posOffsetX, this.mode.posOffset.y, this.mode.posOffset.z)
                        .applyQuaternion(fe.quaternion)
                        .add(fe.position);
                    let t = fe.heading - Math.PI;
                    f.mouseAxis.y > 0 && 1 != D.value && ie.value.MouseLook && (Math.sign(this.posOffsetX) == Math.sign(f.mouseScreen.x) ? (t -= 0.8 * f.mouseScreen.x) : (t -= 1 * f.mouseScreen.x)),
                        this.targets.y < -2 && t > 2 ? (this.orientation.y += 2 * Math.PI) : this.targets.y > 2 && t < -2 && (this.orientation.y -= 2 * Math.PI),
                        (this.targets.y = t),
                        (this.orientation.y = 0.8 * this.orientation.y + 0.2 * this.targets.y),
                        (this.orientation.x = 0.9 * this.orientation.x + 0.8 * -fe.pitch * 0.1),
                        (this.orientation.z = 0.9 * this.orientation.z + 0.5 * -fe.roll * 0.1),
                        this.updateCamState();
                }
                update(e) {
                    if (
                        (Y.signal.CameraMode &&
                            ((this.modeIndex = (this.modeIndex + 1) % Dl.length), (this.mode = Ml[Dl[this.modeIndex]]), window.localStorage.setItem(kl, this.modeIndex), this.reset(), Uh.sendUpdate("cameraChange", Dl[this.modeIndex])),
                        this.mode.isFirstPerson)
                    )
                        return this.updateFirstPerson(e);
                    (this.uLerpA = this.smoothLerp(fe.speed / this.mode.farSpeed)),
                        (this.uLerpB = 1 - this.uLerpA),
                        (this.uSmoothA = Math.min(e / (Sh * this.mode.smoothFactor), 1)),
                        (this.uSmoothC = this.uSmoothA / 2),
                        (this.uSmoothB = 1 - this.uSmoothA),
                        (this.uSmoothD = 1 - this.uSmoothC),
                        this.vCenter
                            .set(this.mode.posOffset.x * this.posOffsetX, this.mode.posOffset.y, this.mode.posOffset.z)
                            .applyQuaternion(fe.quaternion)
                            .add(fe.position),
                        (this.vCenter.y += this.mode.yOffset.near * this.uLerpA + this.mode.yOffset.far * this.uLerpB),
                        this.camera.position.copy(this.vCenter);
                    let t = fe.heading - Math.PI;
                    this.targets.y < -2 && t > 2 ? (this.orientation.y += 2 * Math.PI) : this.targets.y > 2 && t < -2 && (this.orientation.y -= 2 * Math.PI),
                        (this.targets.y = t),
                        this.mode.rollFactor
                            ? ((this.targets.x = this.mode.pitch.near * this.uLerpA + this.mode.pitch.far * this.uLerpB + fe.pitch),
                              (this.targets.z = fe.roll * this.mode.rollFactor),
                              (this.orientation.z = this.targets.z * this.uSmoothA + this.orientation.z * this.uSmoothB))
                            : ((this.targets.x = this.mode.pitch.near * this.uLerpA + this.mode.pitch.far * this.uLerpB + fe.pitch), (this.targets.x = Math.max(-0.2, this.targets.x))),
                        (this.targets.x *= -1),
                        (this.orientation.x = this.targets.x * this.uSmoothC + this.orientation.x * this.uSmoothD),
                        (this.orientation.y = this.targets.y * this.uSmoothA + this.orientation.y * this.uSmoothB),
                        this.updateCamState(),
                        (this.uDist = this.mode.range.near * this.uLerpA + this.mode.range.far * this.uLerpB),
                        this.camera.position.add(this.camFwd.multiplyScalar(-this.uDist)),
                        (this.uCollisionCheck -= e),
                        this.mode.i < 2 &&
                            this.uCollisionCheck < 0 &&
                            ((this.uH = Sl.getHeight(this.camera.position) + 1.5),
                            this.uH > this.camera.position.y
                                ? ((this.camera.position.y = this.uH), this.camera.lookAt(this.vCenter))
                                : this.uH < this.camera.position.y + 2
                                ? (this.uCollisionCheck = (this.uH - this.camera.position.y) / 2)
                                : (this.collisionCheck = 1));
                }
                updateCamState() {
                    this.camera.setRotationFromEuler(this.orientation), this.camera.getWorldDirection(this.camFwd), Hs.fwd.copy(this.camFwd).normalize().multiplyScalar(-1), (this.camera.speed = fe.speed);
                }
                updateConfig() {}
                destroy() {
                    this.camera.clear(), (fe.geo.visible = !0), Pe.removeListener("side", this.setVehicleSideBound), Ih.removeListener("verticalFov", this.onFovBound);
                }
            };
            const jl = 75,
                Nl = 0.001,
                zl = 2.5;
            var Ol = class {
                smoothLerp(e) {
                    return -1 * (3 - 2 * (e = Math.min(1, e))) * e * e + 1;
                }
                smootherLerp(e) {
                    return ((e = Math.min(1, e)) * (6 * e - 15) + 10) * e * e * e * -1 + 1;
                }
                constructor(e, t) {
                    (this.onViewChange = () => {}),
                        (this.modeIndex = 0),
                        (this.onSettingsChangedBound = this.onSettingsChanged.bind(this)),
                        (this.lockChangeAlertBound = this.lockChangeAlert.bind(this)),
                        (this.onMouseMoveBound = this.onMouseMove.bind(this)),
                        (this.orientation = new r.m(0, 0, 0, "YXZ")),
                        (this.targets = { y: 0, x: 0 }),
                        (this.vCenter = new r.W()),
                        (this.camFwd = new r.W()),
                        (this.uLerpA = 0),
                        (this.uLerpB = 0),
                        (this.uDist = 0),
                        (this.uSmoothA = 0),
                        (this.uSmoothB = 0),
                        (this.uH = 0),
                        (this.uCollisionCheck = 1),
                        (this.randFrame = !1),
                        (this.dir = new r.W()),
                        (this.leftVec = new r.W(0, 0, 1)),
                        (this.upVec = new r.W(0, 1, 0)),
                        (this.camUp = new r.W()),
                        (this.camLeft = new r.W()),
                        (this.trackPosition = new r.W()),
                        (this.targetPosition = new r.W()),
                        (this.targetSmoothing = 0.025),
                        (this.posVec = new r.W()),
                        (this.sX = 0),
                        (this.sZ = 1),
                        (this.targetSpeed = 0),
                        (this.speed = 0),
                        (this.baseSpeed = 75),
                        (this.targetElevSpeed = 0),
                        (this.elevSpeed = 0),
                        (this.baseElevSpeed = 25),
                        (this.targetRotSpeed = 0),
                        (this.rotSpeed = 0),
                        (this.baseRotSpeed = 1),
                        (this.targetRotX = 0),
                        (this.targetRotY = 0),
                        (this.mouseSense = 0.001),
                        (this.targetZoom = 1),
                        (this.curZoom = 1),
                        (this.maxZoom = Math.sqrt(8)),
                        (this.minZoom = Math.sqrt(0.75)),
                        (this.zoomSpeed = 2.5),
                        (this.xSmooth = 0.003),
                        (this.rotSmooth = 0.02),
                        (this.scrollInput = 0),
                        (this.matchSpeed = !1),
                        (this.track = !1),
                        (this.camPrevPos = new r.W()),
                        (this.onViewChange = e),
                        (this.camera = Hs),
                        (this.camContainer = new r.G()),
                        this.camContainer.add(this.camera),
                        (this.camContainer.rotation.order = "ZYX"),
                        this.camera.rotation.set(0, 0, 0),
                        (this.camera.rotation.y = Math.PI),
                        (this.camera.fov = 68),
                        this.camera.updateProjectionMatrix(),
                        this.camera.position.set(0, 0, 0),
                        (this.camera.speed = 0),
                        (this.canvas = t),
                        (this.canvas.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock),
                        (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock),
                        (this.canvas.onclick = () => {
                            this.canvas.requestPointerLock();
                        }),
                        document.addEventListener("pointerlockchange", this.lockChangeAlertBound, !1),
                        (ue.listener.frustumCulled = !1),
                        f.lockScroll("cinecam"),
                        C.addListener("any", this.onSettingsChangedBound),
                        this.onSettingsChanged(),
                        this.camera.add(ue.listener),
                        this.reset();
                }
                onSettingsChanged() {
                    (this.baseSpeed = jl * C.value.baseSpeed),
                        (this.baseElevSpeed = jl * C.value.elevationSpeed),
                        (this.mouseSense = Nl * C.value.mouseSense),
                        (this.zoomSpeed = zl * C.value.zoomSpeed),
                        0 == C.value.smoothing ? (this.rotSmooth = 0) : (this.rotSmooth = 0.84 + 0.15 * Math.cbrt(C.value.smoothing)),
                        (this.boostFactor = C.value.boostFactor);
                }
                lockChangeAlert() {
                    document.pointerLockElement === this.canvas || document.mozPointerLockElement === this.canvas
                        ? document.addEventListener("mousemove", this.onMouseMoveBound, !1)
                        : document.removeEventListener("mousemove", this.onMouseMoveBound, !1);
                }
                onMouseMove(e) {
                    (this.targetRotY -= (e.movementX * this.mouseSense) / this.curZoom), (this.targetRotX += (e.movementY * this.mouseSense * this.camera.aspect) / this.curZoom);
                }
                updateViewDist() {
                    (this.camera.far = St), this.camera.updateProjectionMatrix();
                }
                reset() {
                    this.camContainer.position.copy(fe.position),
                        (this.camContainer.position.y += 5),
                        (this.camContainer.rotation.y = fe.heading),
                        (this.camContainer.rotation.x = 0.2),
                        (this.curZoom = 1),
                        (this.targetZoom = 1),
                        (this.sX = Math.sin(this.camContainer.rotation.y + Math.PI)),
                        (this.sZ = Math.cos(this.camContainer.rotation.y + Math.PI)),
                        this.targetPosition.copy(this.camContainer.position),
                        (this.targetRotX = this.camContainer.rotation.x),
                        (this.targetRotY = this.camContainer.rotation.y);
                }
                setSize(e, t) {
                    (this.camera.aspect = e / t), this.camera.updateProjectionMatrix(), this.onViewChange();
                }
                update(e) {
                    f.key[V.CameraMatchSpeed] && ((f.key[V.CameraMatchSpeed] = !1), (this.matchSpeed = !this.matchSpeed)),
                        this.matchSpeed ? (this.targetSpeed = Math.max(1, fe.speed)) : ((this.speed = 0.9 * this.speed), (this.targetSpeed = 0)),
                        (this.targetElevSpeed = 0),
                        this.posVec.set(0, 0, 0),
                        (this.dir.x = 0),
                        (this.hadInput = !1),
                        f.key[V.Forward] && ((this.hadInput = !0), (this.posVec.x -= e * this.speed * this.sX), (this.posVec.z -= e * this.speed * this.sZ)),
                        f.key[V.Backward] && ((this.hadInput = !0), (this.posVec.x += e * this.speed * this.sX), (this.posVec.z += e * this.speed * this.sZ)),
                        (this.dir.z = 0),
                        f.key[V.Left] && ((this.hadInput = !0), (this.posVec.x -= e * this.speed * this.sZ), (this.posVec.z += e * this.speed * this.sX)),
                        f.key[V.Right] && ((this.hadInput = !0), (this.posVec.x += e * this.speed * this.sZ), (this.posVec.z -= e * this.speed * this.sX)),
                        (this.hadElev = !1),
                        f.click.right ? ((this.hadElev = !0), (this.posVec.y -= e * this.elevSpeed)) : f.click.left && ((this.hadElev = !0), (this.posVec.y += e * this.elevSpeed)),
                        this.hadInput && !this.matchSpeed && (this.targetSpeed = this.baseSpeed),
                        this.hadElev && (this.targetElevSpeed = this.baseElevSpeed),
                        (this.speedMult = 1),
                        f.key[V.BoostAccel] && ((this.speedMult = this.boostFactor), (this.targetSpeed *= this.boostFactor)),
                        (this.speed = 0.9 * this.speed + 0.1 * this.targetSpeed),
                        (this.elevSpeed = 0.95 * this.elevSpeed + 0.05 * this.targetElevSpeed),
                        (this.hadRot = !1),
                        (this.targetRotSpeed = 0),
                        f.key[V.LeftArrow] ? ((this.hadRot = !0), (this.targetRotY += e * this.rotSpeed)) : f.key[V.RightArrow] && ((this.hadRot = !0), (this.targetRotY -= e * this.rotSpeed)),
                        f.key[V.UpArrow] ? ((this.hadRot = !0), (this.targetRotX -= e * this.rotSpeed * 0.5)) : f.key[V.DownArrow] && ((this.hadRot = !0), (this.targetRotX += e * this.rotSpeed * 0.5)),
                        this.hadRot && (this.targetRotSpeed = (1 * this.baseRotSpeed) / this.curZoom),
                        (this.rotSpeed = 0.98 * this.rotSpeed + 0.02 * this.targetRotSpeed),
                        (this.camContainer.rotation.x = this.camContainer.rotation.x * this.rotSmooth + this.targetRotX * (1 - this.rotSmooth)),
                        (this.camContainer.rotation.y = this.camContainer.rotation.y * this.rotSmooth + this.targetRotY * (1 - this.rotSmooth)),
                        (this.sX = Math.sin(this.camContainer.rotation.y + Math.PI)),
                        (this.sZ = Math.cos(this.camContainer.rotation.y + Math.PI)),
                        (this.scrollInput = 0.9 * this.scrollInput + 0.1 * f.scrollDelta),
                        0 != this.scrollInput && ((this.targetZoom -= this.scrollInput * e * this.zoomSpeed * this.speedMult), (this.targetZoom = Math.max(Math.min(this.maxZoom, this.targetZoom), this.minZoom)), (f.scrollDelta = 0)),
                        (this.curZoom = 0.95 * this.curZoom + 0.05 * this.targetZoom),
                        this.curZoom != this.camera.zoom && ((this.camera.zoom = this.curZoom * this.curZoom), this.camera.updateProjectionMatrix()),
                        this.track && (this.trackPosition.copy(fe.frontAxlePosition), (this.trackPosition.y += 0.5), this.camContainer.lookAt(this.trackPosition)),
                        f.key[V.ResetCamera] && (this.reset(), (f.key[V.ResetCamera] = !1)),
                        this.camera.getWorldDirection(this.camFwd),
                        this.targetPosition.add(this.posVec),
                        this.camContainer.position.lerp(this.targetPosition, this.targetSmoothing),
                        this.camPrevPos.copy(this.camContainer.position),
                        (this.uCollisionCheck -= e),
                        this.uCollisionCheck < 0 &&
                            ((this.uH = Sl.getHeight(this.targetPosition) + 0.5),
                            this.uH > this.targetPosition.y ? (this.targetPosition.y = this.uH) : this.uH < this.targetPosition.y + 2 ? (this.uCollisionCheck = (this.uH - this.targetPosition.y) / 2) : (this.collisionCheck = 1));
                }
                updateConfig() {}
                destroy() {
                    this.camContainer.clear(),
                        this.camera.clear(),
                        document.removeEventListener("mousemove", this.onMouseMoveBound, !1),
                        document.exitPointerLock(),
                        (this.canvas.onclick = () => {}),
                        Xh.remove(this.debug),
                        C.removeListener(this.onSettingsChangedBound),
                        f.unlockScroll("cinecam");
                }
            };
            function Ll(e, t) {
                return 0 == t
                    ? e > 0
                        ? Math.PI / 2
                        : (3 * Math.PI) / 2
                    : 0 == e
                    ? t > 0
                        ? 0
                        : Math.PI
                    : e > 0
                    ? t > 0
                        ? Math.atan(e / t)
                        : Math.PI + Math.atan(e / t)
                    : t < 0
                    ? Math.PI + Math.atan(e / t)
                    : 2 * Math.PI + Math.atan(e / t);
            }
            var Rl = new (class extends l {
                constructor(...e) {
                    super(...e), (this.default = -9.81), (this.value = -9.81);
                }
            })();
            const Tl = [0.44704, 0.277778],
                Pl = [60 * Tl[0], 100 * Tl[1]],
                Gl = 0,
                Bl = 1;
            var Wl = new (class extends p {
                    getConversion(e) {
                        (this.conversion = Tl[e]), (this.default.speed = Pl[e]), null != this.value.speed && this.set("speed", 5 * Math.round(this.value.speed / this.conversion / 5) * this.conversion);
                    }
                    toggleMode() {
                        this.set("control", (this.value.control + 1) % 2);
                    }
                    constructor() {
                        super(),
                            (this.default = { enabled: !1, speed: Pl[0], control: Gl }),
                            (this.value = { enabled: !1, speed: Pl[0], control: Gl }),
                            (this.conversion = Tl[ie.Units]),
                            (this.getConversionBound = this.getConversion.bind(this)),
                            (this.vehicleTypeChangedBound = this.vehicleTypeChanged.bind(this));
                        try {
                            null !== window.localStorage.getItem("speed-control_enabled") && (this.value.enabled = !!JSON.parse(window.localStorage.getItem("speed-control_enabled"))),
                                null !== window.localStorage.getItem("speed-control_speed") && (this.value.speed = JSON.parse(window.localStorage.getItem("speed-control_speed"))),
                                null !== window.localStorage.getItem("speed-control_control") && (this.value.control = JSON.parse(window.localStorage.getItem("speed-control_control")));
                        } catch (Au) {
                            console.warn("Failed to load speed control settings");
                        }
                        le.cruisecontrol && !isNaN(le.cruisecontrol) && ((this.value.speed = le.cruisecontrol / 3.6), (this.value.enabled = !0), (this.value.control = Gl)),
                            ie.addListener(q.Units, this.getConversionBound),
                            Pe.addListener("type", this.vehicleTypeChangedBound);
                    }
                    vehicleTypeChanged(e) {
                        (this.default.speed = Math.min(Pl[ie.Units], ke[e].metrics.topSpeed)), this.set("speed", Math.min(ke[e].metrics.topSpeed, this.value.speed));
                    }
                    reset() {
                        this.setMany({ enabled: !0, speed: Pl[ie.Units] });
                    }
                    set(e, t, i = !1) {
                        if (e in this.value && this.value[e] !== t) {
                            if ("speed" == e) {
                                if (fe.metrics && t > fe.metrics.topSpeed) t = fe.metrics.topSpeed;
                                else if (t <= 0) return;
                                null != t && ((t = Math.max(Math.min(50, t), 0)), (t = 5 * Math.round(t / this.conversion / 5) * this.conversion)), window.localStorage.setItem("speed-control_speed", t);
                            } else "control" == e ? window.localStorage.setItem("speed-control_control", t) : "enabled" == e && window.localStorage.setItem("speed-control_enabled", t);
                            (this.value[e] = t), i || this.onChanged(e, this.value[e]);
                        }
                    }
                    inc5() {
                        this.set("speed", this.value.speed + 5 * this.conversion);
                    }
                    dec5() {
                        this.set("speed", this.value.speed - 5 * this.conversion);
                    }
                })(),
                El = i.p + "static/media/achievement.3ef707de.wav";
            const Fl = { edge: !1 },
                Zl = { edge: "achievement-edge" };
            var Hl = new (class extends p {
                constructor(...e) {
                    super(...e), (this.value = Fl), (this.hasLoaded = !1), (this.sound = null), this.loadAchievements(), (this.hasLoaded = !0), ue.hasInit ? this.onAudioInit() : ue.addInitListener(this.onAudioInit.bind(this));
                }
                onAudioInit() {
                    ue.getAudio(El, (e) => {
                        this.sound = e;
                    });
                }
                set(e, t) {
                    var i;
                    e in this.value && !this.value[e] && 1 == t && (null === (i = this.sound) || void 0 === i || i.play(), window.localStorage.setItem(Zl[e], t));
                    super.set(e, t);
                }
                loadAchievements() {
                    let e, t;
                    for (t in this.value) (e = JSON.parse(window.localStorage.getItem(Zl[t]) || Fl[t])), (this.value[t] = e);
                }
            })();
            const Ql = new p({ steerSpeedFactor: 0.75 }, "controls_global_settings"),
                Yl = { steerSpeedFactor: { readable: "Top speed steer limiter", desc: "Narrows the maximum steer angle as speed increases", type: u.FloatRange, default: 0.75, min: 0, max: 0.9, precision: 2 } };
            var Vl = Ql;
            const Ul = Object.keys(ke),
                Xl = () => ({ personal: Jl(), global: { daily: Jl(), allTime: Jl() } }),
                Jl = () => {
                    let e = {};
                    for (let t of vh) {
                        e[t] = {};
                        for (let i of Ul) e[t][i] = -1;
                    }
                    return e;
                },
                ql = Xl();
            var Kl = new (class extends p {})({ ...ql, key: "fastestMile", seconds: -1, live: { value: -1, progress: 0, prev: 0 }, liveInterval: { startTime: 0, startNode: 0, endNode: 160 } });
            const _l = [
                { key: "fastestMile", label: "Fastest Any Mile", unit: "seconds", state: Kl, stateKey: "seconds" },
                { key: "fastestFirstFive", label: "Fastest First Five Miles", unit: "seconds" },
                { key: "furthestJourney", label: "Furthest Single Journey", unit: "meters" },
                { key: "furthestOnRoad", label: "Furthest On-Road", unit: "meters" },
            ];
            var $l = new (class extends p {
                constructor(e) {
                    super(e), this.updateView(), this.loadRecords(), this.listenRecords(), Pe.addListener("type", this.onVehicleChanged.bind(this));
                }
                switchBoard() {
                    "global" == this.view.board ? this.set("view", { ...this.view, board: "personal" }) : this.set("view", { ...this.view, board: "global" });
                }
                switchTime() {
                    "daily" == this.view.time ? this.set("view", { ...this.view, time: "allTime" }) : this.set("view", { ...this.view, time: "daily" });
                }
                loadRecords() {
                    for (let e of _l) e.state && e.state.set("personal", this.getRecords("records_" + e.key));
                }
                updateView() {
                    this.set("view", { ...this.view, topography: Ih.initialValue.topography, vehicle: Pe.value.type });
                }
                onVehicleChanged(e) {
                    this.updateView();
                }
                listenRecords() {}
                getRecords(e) {
                    let t = null;
                    try {
                        t = JSON.parse(window.localStorage.getItem(e));
                    } catch (Au) {
                        console.warn("Could not load record " + e + " from local storage");
                    }
                    if (null == t) {
                        t = Xl().personal;
                    }
                    return t;
                }
                storeRecords(e, t) {
                    window.localStorage.setItem("records_" + e, JSON.stringify(t));
                }
                getStorage(e) {
                    let t = null;
                    try {
                        t = JSON.parse(window.localStorage.getItem(e));
                    } catch (Au) {
                        console.warn("Could not load record " + e + " from local storage");
                    }
                    return t;
                }
                encodeKey(e) {
                    return "records_" + Ih.initialValue.topography + "_" + Pe.value.type + "_" + e;
                }
                store(e, t) {
                    isNaN(t) ? console.warn("Avoiding record of NaN value ", t) : t < 0 ? console.warn("Avoiding record of default value ", t) : window.localStorage.setItem(this.encodeKey(e), t);
                }
            })({ view: { topography: "normal", vehicle: "Roadster", time: "daily", board: "personal" }, global: null });
            var ed = new (class extends l {
                constructor(...e) {
                    super(...e), (this.default = !1), (this.value = !1);
                }
            })();
            var td = new (class {
                constructor() {
                    (this.onDisplayBound = this.onDisplay.bind(this)),
                        (this.onSocketBound = this.onSocket.bind(this)),
                        (this.hasInit = !1),
                        (this.updateViewBound = this.updateView.bind(this)),
                        (this.seenIndex = 0),
                        (this.updateBound = this.update.bind(this)),
                        (this.endNodeOffset = 0),
                        (this.endNodeTracker = 0),
                        null !== Oh.value ? this.onSocket(Oh.value) : Oh.addListener(this.onSocketBound),
                        $l.addListener("view", this.updateViewBound),
                        ed.addListener(this.onDisplayBound);
                }
                onDisplay(e) {
                    e ? (this.resetFastestMile(), oe.addSlowListener(this.updateBound)) : oe.addSlowListener(this.updateBound);
                }
                onSocket(e) {
                    e.on("leaderboard", this.onNewLeaderboard.bind(this)), e.on("partialLeaderboard", this.onPartialLeaderboard.bind(this)), e.on("newRecord", this.onNewRecord.bind(this)), e.emit("requestLeaderboard");
                }
                onNewLeaderboard(e) {
                    $l.set("global", e);
                }
                onPartialLeaderboard(e) {}
                onNewRecord(e) {
                    console.log("Got a new record!");
                }
                submitRecord(e, t, i, s, n = "Anonymous") {
                    Oh.value && Oh.value.emit("challengeRecord", { key: i, topography: e, vehicle: t, value: s, name: n });
                }
                updateView(e) {
                    this.resetFastestMile();
                }
                pause() {
                    this.paused = !0;
                }
                resume() {
                    (this.paused = !1), this.hasInit || this.resetFastestMile(), (this.hasInit = !0);
                }
                init() {
                    $l.updateView(), this.resetFastestMile(), (this.paused = !0), (this.hasInit = !1);
                }
                resetFastestMile() {
                    Kl.set("liveInterval", { startTime: oe.playTime, startNode: $t.vehicleIndex, endNode: $t.vehicleIndex + 160 }), Kl.set("live", { value: 0, prev: Kl.live.prev, progress: 0 });
                }
                nodeDidChange() {
                    Ih.saveProgress($t.vehicleIndex);
                }
                update(e) {
                    this.paused || (this.updateFastestMile(e), (this.seenIndex = $t.vehicleIndex));
                }
                checkRecordBreak(e, t, i) {
                    return !(e < 1) && ((this.tr = t.personal[$l.view.topography][$l.view.vehicle]), (e < this.tr || this.tr < 0) && ((t.personal[$l.view.topography][$l.view.vehicle] = e), !0));
                }
                updateFastestMile(e) {
                    (Kl.live.value += (1e3 * e) / 1e3),
                        this.seenIndex !== $t.vehicleIndex &&
                            ((Kl.live.progress = ($t.vehicleIndex - Kl.liveInterval.startNode) / 160),
                            Kl.liveInterval.endNode <= $t.vehicleIndex &&
                                (this.checkRecordBreak(Kl.live.value, Kl) && (Kl.onChanged("personal", Kl.personal), $l.storeRecords(Kl.key, Kl.personal)),
                                this.submitRecord($l.view.topography, $l.view.vehicle, Kl.key, Kl.live.value),
                                Kl.set("liveInterval", { startTime: oe.playTime, startNode: $t.vehicleIndex, endNode: $t.vehicleIndex + 160 }),
                                (Kl.live.prev = Kl.live.value),
                                (Kl.live.value = 0),
                                (Kl.live.progress = 0))),
                        Kl.onChanged("live", Kl.live);
                }
            })();
            const id = { None: 0, Basic: 1, Reset: 2, Boost: 3, UTurn: 4, Reverse: 5 },
                sd = { Reset: "seen-reset", Boost: "seen-boost" },
                nd = { Basic: Nh.newUser, Reset: null == localStorage.getItem(sd.Reset), Boost: null == localStorage.getItem(sd.Boost) },
                ad = (e) => {
                    e in nd && ((nd[e] = !1), localStorage.setItem(sd[e], !0), od.value == id[e] && od.set(id.None));
                },
                od = new l(Nh.newUser ? id.Basic : id.None);
            var rd = od,
                hd = i.p + "static/media/tyres_01_m.2ec57852.mp3",
                ld = i.p + "static/media/tyres_01_m_int.5d27166a.mp3",
                dd = i.p + "static/media/sus_01.6624d5cb.mp3",
                cd = i.p + "static/media/veh_brake_02.4c95eb2a.mp3",
                pd = i.p + "static/media/rolling_offroad_04.e2ad11f4.mp3",
                ud = i.p + "static/media/rolling_offroad_04_int.be35fc69.mp3",
                gd = i.p + "static/media/rolling_06_int.95d70f91.mp3",
                md = i.p + "static/media/veh_scrape_01.3499a87a.mp3",
                xd = i.p + "static/media/hit_01.33777ad9.mp3",
                vd = i.p + "static/media/hit_02.c5bc2ff2.mp3",
                fd = i.p + "static/media/hit_03.43267a22.mp3",
                wd = i.p + "static/media/veh_scrape_01_int.2d544904.mp3",
                bd = i.p + "static/media/hit_01_int.770a6ac1.mp3",
                Ad = i.p + "static/media/hit_02_int.3dbdbc1c.mp3",
                yd = i.p + "static/media/hit_03_int.a625778d.mp3";
            const Id = "roll",
                Sd = "engine",
                Md = "engine2",
                Dd = "brake",
                kd = "boost",
                Cd = 0.8,
                jd = { brake: cd, boost: be, engine2: cd },
                Nd = { sus: dd, tyre: hd, tyreInt: ld, roll: null, rollInt: gd, offroad: pd, offroadInt: ud },
                zd = { hits: [xd, vd, fd], hitsInt: [bd, Ad, yd], scrape: md, scrapeInt: wd };
            var Od = class {
                constructor(e) {
                    (this.sounds = { tyres: [], tyresExt: [], tyresInt: [], sus: [], rolls: [], rollsExt: [], rollsInt: [], offroads: [], offroadsExt: [], offroadsInt: [] }),
                        (this.worldSounds = { hits: [], hitsInt: [], hitsExt: [], scrape: null, scapeInt: null, scrapeExt: null }),
                        (this.audioReady = !1),
                        (this.paved = !0),
                        (this.interior = !1),
                        (this.updateNull = () => {}),
                        (this.vol = 0),
                        (this.decel = !1),
                        (this.lerpTarget = 2),
                        (this.speedTarget = 0),
                        (this.accelPower = 0),
                        (this.boostT = 0),
                        (this.brakeT = 0),
                        (this.tls = [0, 0, 0, 0]),
                        (this.coll = !1),
                        (this.hitIndex = 0),
                        (this.vc = e),
                        (this.update = this.updateNull),
                        "Planet" == Ih.sceneName && (this.paved = !1),
                        Ih.addListener("sceneName", (e) => (this.paved = "Planet" !== e)),
                        Qs.addListener(this.onInteriorChanged.bind(this));
                }
                onInteriorChanged(e) {
                    if (this.audioReady)
                        if (e) {
                            for (let e of this.worldSounds.hits) e.setVolume(0);
                            (this.worldSounds.hits = this.worldSounds.hitsInt), this.worldSounds.scrape.setVolume(0), (this.worldSounds.scrape = this.worldSounds.scrapeInt);
                            for (let e of this.sounds.offroadsExt) e.setVolume(0);
                            this.sounds.offroads = this.sounds.offroadsInt;
                            for (let e of this.sounds.rollsExt) e.setVolume(0);
                            this.sounds.rolls = this.sounds.rollsInt;
                        } else {
                            for (let e of this.worldSounds.hits) e.setVolume(0);
                            (this.worldSounds.hits = this.worldSounds.hitsExt), this.worldSounds.scrape.setVolume(0), (this.worldSounds.scrape = this.worldSounds.scrapeExt);
                            for (let e of this.sounds.offroadsInt) e.setVolume(0);
                            this.sounds.offroads = this.sounds.offroadsExt;
                            for (let e of this.sounds.rollsInt) e.setVolume(0);
                            this.sounds.rolls = this.sounds.rollsExt;
                        }
                }
                suspend() {
                    var e;
                    for (let i in this.sounds) {
                        var t;
                        if (Array.isArray(this.sounds[i])) for (let e of this.sounds[i]) e.setVolume(0);
                        else null === (t = this.sounds[i]) || void 0 === t || t.setVolume(0);
                    }
                    for (let i of this.worldSounds.hits) i.setVolume(0);
                    null === (e = this.worldSounds.scrape) || void 0 === e || e.setVolume(0);
                }
                initForVehicle(e, t, i) {
                    (this.update = this.updateNull), (this.inputs = t), (this.wheels = i), (this.soundCount = 0), (this.soundLoaded = 0);
                    for (let o in e.audio) this.loadSound(o, e.audio[o]);
                    for (let o in jd) e.audio[o] || this.loadSound(o, jd[o]);
                    (Nd.roll = e.audio.roll), this.loadWorldSounds();
                    for (let o in this.sounds) {
                        var s, n;
                        for (let e = 0; e < this.sounds[o].length; e++) this.sounds[o][e].stop();
                        null === (s = (n = this.sounds[o]).stop) || void 0 === s || s.call(n);
                    }
                    let a = [];
                    e.bike
                        ? a.push({ x: 0, z: e.wheels.length }, { x: 0, z: 0 })
                        : a.push({ x: e.wheels.width / 2, z: e.wheels.length }, { x: -e.wheels.width / 2, z: e.wheels.length }, { x: e.wheels.width / 2, z: 0 }, { x: -e.wheels.width / 2, z: 0 });
                    for (let o = 0; o < a.length; o++) this.loadTyre(o, a[o]);
                    (this.lerpTarget = 0), (this.speedTarget = 0);
                }
                soundDidLoad() {
                    this.soundLoaded++,
                        this.soundLoaded >= this.soundCount &&
                            ((this.audioReady = !0),
                            Qs.value
                                ? ((this.worldSounds.scrape = this.worldSounds.scrapeInt), (this.sounds.rolls = this.sounds.rollsInt))
                                : ((this.worldSounds.scrape = this.worldSounds.scrapeExt), (this.sounds.rolls = this.sounds.rollsExt)),
                            (this.update = this.updateLive));
                }
                loadHit(e) {
                    this.soundCount++,
                        ue.getPositionalAudio(
                            zd.hits[e],
                            (t) => {
                                (this.worldSounds.hitsExt[e] = t),
                                    t.setRefDistance(5),
                                    t.setRolloffFactor(3 * Cd),
                                    t.setVolume(0),
                                    fe.add(t),
                                    (t.onEnded = () => {
                                        t.stop();
                                    }),
                                    this.soundDidLoad();
                            },
                            this.worldSounds.hitsExt[e]
                        ),
                        this.soundCount++,
                        ue.getPositionalAudio(
                            zd.hitsInt[e],
                            (t) => {
                                (this.worldSounds.hitsInt[e] = t),
                                    t.setRefDistance(5),
                                    t.setRolloffFactor(3 * Cd),
                                    t.setVolume(0),
                                    fe.add(t),
                                    (t.onEnded = () => {
                                        t.stop();
                                    }),
                                    this.soundDidLoad();
                            },
                            this.worldSounds.hitsInt[e]
                        );
                }
                loadWorldSounds() {
                    for (let e = 0; e < zd.hits.length; e++) this.loadHit(e);
                    (this.worldSounds.hits = Qs.value ? this.worldSounds.hitsInt : this.worldSounds.hitsExt),
                        this.soundCount++,
                        ue.getPositionalAudio(zd.scrape, (e) => {
                            this.worldSounds.scrapeExt && (this.worldSounds.scrapeExt.stop(), fe.remove(this.worldSounds.scrapeExt)),
                                (this.worldSounds.scrapeExt = e),
                                e.setLoop(!0),
                                e.setLoopStart(0.1),
                                e.setLoopEnd(e.buffer.duration - 0.1),
                                e.setVolume(0),
                                e.setRefDistance(8),
                                e.setRolloffFactor(Cd),
                                e.play(),
                                e.position.set(0, 0.5, fe.wheels.length / 2),
                                fe.add(this.worldSounds.scrapeExt),
                                this.soundDidLoad();
                        }),
                        this.soundCount++,
                        ue.getPositionalAudio(zd.scrapeInt, (e) => {
                            this.worldSounds.scrapeInt && (this.worldSounds.scrapeInt.stop(), fe.remove(this.worldSounds.scrapeInt)),
                                (this.worldSounds.scrapeInt = e),
                                e.setLoop(!0),
                                e.setLoopStart(0.1),
                                e.setLoopEnd(e.buffer.duration - 0.1),
                                e.setVolume(0),
                                e.setRefDistance(8),
                                e.setRolloffFactor(Cd),
                                e.play(),
                                e.position.set(0, 0.5, fe.wheels.length / 2),
                                fe.add(this.worldSounds.scrapeInt),
                                this.soundDidLoad();
                        });
                }
                loadTyre(e, t) {
                    this.soundCount++,
                        ue.getPositionalAudio(
                            Nd.tyre,
                            (i) => {
                                this.sounds.tyres[e] && this.sounds.tyres[e].stop(),
                                    (this.sounds.tyres[e] = i),
                                    i.setLoop(!0),
                                    i.setLoopStart(0.1),
                                    i.setLoopEnd(i.buffer.duration - 0.1),
                                    i.setRefDistance(2 * fe.wheels.length),
                                    i.setRolloffFactor(4),
                                    i.setVolume(0),
                                    (i.offset = Math.random() * i.buffer.duration),
                                    (i.detune = -400 * Math.random()),
                                    i.play(),
                                    (i.position.x = t.x),
                                    (i.position.z = t.z),
                                    fe.add(i),
                                    this.soundDidLoad();
                            },
                            this.sounds.tyres[e]
                        ),
                        this.soundCount++,
                        ue.getPositionalAudio(
                            Nd.tyreInt,
                            (i) => {
                                this.sounds.tyresInt[e] && this.sounds.tyresInt[e].stop(),
                                    (this.sounds.tyresInt[e] = i),
                                    i.setLoop(!0),
                                    i.setLoopStart(0.1),
                                    i.setLoopEnd(i.buffer.duration - 0.1),
                                    i.setRefDistance(2 * fe.wheels.length),
                                    i.setRolloffFactor(4),
                                    i.setVolume(0),
                                    (i.offset = Math.random() * i.buffer.duration),
                                    (i.detune = -400 * Math.random()),
                                    i.play(),
                                    (i.position.x = t.x),
                                    (i.position.z = t.z),
                                    fe.add(i),
                                    this.soundDidLoad();
                            },
                            this.sounds.tyresInt[e]
                        ),
                        this.soundCount++,
                        ue.getPositionalAudio(
                            Nd.roll,
                            (i) => {
                                this.sounds.rollsExt[e] && this.sounds.rollsExt[e].stop(),
                                    (this.sounds.rollsExt[e] = i),
                                    i.setLoop(!0),
                                    i.setLoopStart(0.1),
                                    i.setLoopEnd(i.buffer.duration - 0.1),
                                    i.setVolume(0),
                                    i.setRefDistance(2 * fe.wheels.length),
                                    i.setRolloffFactor(3 * Cd),
                                    (i.offset = (0.1 * Math.random() + 0.25 * e) * i.buffer.duration),
                                    i.play(),
                                    (i.position.x = t.x),
                                    (i.position.z = t.z),
                                    fe.add(i),
                                    this.soundDidLoad();
                            },
                            this.sounds.rollsExt[e]
                        ),
                        this.soundCount++,
                        ue.getPositionalAudio(
                            Nd.rollInt,
                            (i) => {
                                this.sounds.rollsInt[e] && this.sounds.rollsInt[e].stop(),
                                    (this.sounds.rollsInt[e] = i),
                                    i.setLoop(!0),
                                    i.setLoopStart(0.1),
                                    i.setLoopEnd(i.buffer.duration - 0.1),
                                    i.setVolume(0),
                                    i.setRefDistance(2 * fe.wheels.length),
                                    i.setRolloffFactor(3 * Cd),
                                    (i.offset = (0.1 * Math.random() + 0.25 * e) * i.buffer.duration),
                                    i.play(),
                                    (i.position.x = t.x),
                                    (i.position.z = t.z),
                                    fe.add(i),
                                    this.soundDidLoad();
                            },
                            this.sounds.rollsInt[e]
                        ),
                        this.soundCount++,
                        ue.getPositionalAudio(
                            Nd.offroad,
                            (i) => {
                                this.sounds.offroadsExt[e] && this.sounds.offroadsExt[e].stop(),
                                    (this.sounds.offroadsExt[e] = i),
                                    i.setLoop(!0),
                                    i.setLoopStart(0.1),
                                    i.setLoopEnd(i.buffer.duration - 0.1),
                                    i.setVolume(0),
                                    i.setRefDistance(2 * fe.wheels.length),
                                    i.setRolloffFactor(3 * Cd),
                                    (i.offset = Math.random() * i.buffer.duration),
                                    (i.detune = 800 * Math.random()),
                                    i.play(),
                                    (i.position.x = t.x),
                                    (i.position.z = t.z),
                                    e < 2 && (i.position.z = fe.wheels.length),
                                    fe.add(i),
                                    this.soundDidLoad();
                            },
                            this.sounds.offroadsExt[e]
                        ),
                        this.soundCount++,
                        ue.getPositionalAudio(
                            Nd.offroadInt,
                            (i) => {
                                this.sounds.offroadsInt[e] && this.sounds.offroadsInt[e].stop(),
                                    (this.sounds.offroadsInt[e] = i),
                                    i.setLoop(!0),
                                    i.setLoopStart(0.1),
                                    i.setLoopEnd(i.buffer.duration - 0.1),
                                    i.setVolume(0),
                                    i.setRefDistance(2 * fe.wheels.length),
                                    i.setRolloffFactor(3 * Cd),
                                    (i.offset = Math.random() * i.buffer.duration),
                                    (i.detune = 800 * Math.random()),
                                    i.play(),
                                    (i.position.x = t.x),
                                    (i.position.z = t.z),
                                    e < 2 && (i.position.z = fe.wheels.length),
                                    fe.add(i),
                                    this.soundDidLoad();
                            },
                            this.sounds.offroadsInt[e]
                        ),
                        (this.sounds.offroads = Qs.value ? this.sounds.offroadsInt : this.sounds.offroadsExt),
                        this.soundCount++,
                        ue.getPositionalAudio(
                            Nd.sus,
                            (i) => {
                                this.sounds.sus[e] && this.sounds.sus[e].stop(),
                                    (this.sounds.sus[e] = i),
                                    i.setLoop(!0),
                                    i.setLoopStart(0.1),
                                    i.setLoopEnd(i.buffer.duration - 0.1),
                                    i.setRefDistance(0.8),
                                    i.setRolloffFactor(Cd),
                                    i.setVolume(0),
                                    (i.offset = Math.random() * i.buffer.duration),
                                    (i.detune = -400 * Math.random()),
                                    i.play(),
                                    (i.position.x = t.x),
                                    (i.position.z = t.z),
                                    fe.add(i),
                                    this.soundDidLoad();
                            },
                            this.sounds.sus[e]
                        );
                }
                loadSound(e, t) {
                    this.soundCount++,
                        ue.getPositionalAudio(
                            t,
                            (t) => {
                                var i;
                                null === (i = this.sounds[e]) || void 0 === i || i.stop(),
                                    (this.sounds[e] = t),
                                    e == Id &&
                                        (t.setLoop(!0),
                                        t.setLoopStart(0.1),
                                        t.setLoopEnd(t.buffer.duration - 0.1),
                                        t.setVolume(0),
                                        t.setRefDistance(2 * fe.wheels.length),
                                        t.setRolloffFactor(Cd),
                                        t.play(),
                                        t.position.set(0, 0.5, fe.wheels.length / 2)),
                                    (e != Sd && e != Md) ||
                                        (t.setLoop(!0),
                                        t.setLoopStart(0.1),
                                        t.setLoopEnd(t.buffer.duration - 0.1),
                                        t.setRefDistance(2 * fe.wheels.length),
                                        t.setRolloffFactor(Cd),
                                        t.position.set(0, 0.5, fe.wheels.length),
                                        t.setVolume(0),
                                        t.play()),
                                    (e != Dd && e != kd) ||
                                        (t.setLoop(!0),
                                        t.setLoopStart(0.1),
                                        t.setLoopEnd(t.buffer.duration - 0.1),
                                        t.setRefDistance(2 * fe.wheels.length),
                                        t.setRolloffFactor(Cd),
                                        t.position.set(0, 0.5, fe.wheels.length / 2),
                                        t.setVolume(0),
                                        t.play()),
                                    fe.add(this.sounds[e]),
                                    this.soundDidLoad();
                            },
                            this.sounds[e]
                        );
                }
                updateLive(e, t, i) {
                    (this.interiorVol = Qs.value ? 0.5 : 1), this.updateEngine(e, this.inputs), this.updateBoost(), this.updateBrakes(), this.updateTyres(e, this.wheels), this.updateCollisions();
                }
                reset() {
                    (this.vol = 0), (this.lerpTarget = 2);
                }
                updateEngine(e, t) {
                    let i = this.sounds.engine,
                        s = this.sounds.engine2,
                        n = fe.speed / (1.25 * fe.metrics.topSpeed);
                    (n = n < 0.5 ? n * n * 2 : 2 * (1 - n)),
                        this.vc.inputs.accel < 0 && fe.direction > 0 && (n = 0),
                        (this.accelPower = 0.4 + (Math.abs(this.vc.inputs.accel) / fe.metrics.accel) * 0.6),
                        0 != t.accel
                            ? (this.decel && ((this.vol += 0.2), (this.decel = !1)),
                              (this.vol += 2 * e),
                              (this.vol = Math.min(1, this.vol, this.accelPower)),
                              (this.speedTarget = Math.min(fe.speed, fe.metrics.topSpeed + 10) / 15 + 2),
                              (this.lerpTarget = 0.95 * this.lerpTarget + 0.05 * this.speedTarget),
                              i.setPlaybackRate(4 * this.lerpTarget),
                              s.setPlaybackRate(0.06 + this.lerpTarget / 16),
                              (this.t1 = 0.6 * (1 - this.smoothstep(this.vol))),
                              i.setVolume(this.t1 * this.interiorVol),
                              s.setVolume(this.t1 * n * this.interiorVol))
                            : this.vol > 0
                            ? (0 == this.decel && (this.lerpTarget -= 0.05),
                              (this.decel = !0),
                              (this.vol -= e),
                              (this.vol = Math.max(0, this.vol)),
                              (this.t1 = 0.6 * this.vol),
                              i.setVolume(this.t1 * this.interiorVol),
                              s.setVolume(this.t1 * n * this.interiorVol))
                            : (i.setVolume(0), s.setVolume(0));
                }
                updateBoost() {
                    if (!this.sounds.boost) return;
                    let e = fe.speed / fe.metrics.topSpeed;
                    if (((this.boostV = 0), this.vc.hasAccel && this.vc.hasBoost)) {
                        let t = 1 - Math.min(1, e);
                        (this.boostV = 0.5 + e / 2), (this.boostT = 0.9 * this.boostT + 0.1 * t), (t = 1 + (1 - t) / 2), this.sounds.boost.setPlaybackRate(1 + 5 * t);
                    } else this.boostT *= 0.95;
                    this.sounds.boost.setVolume(0.75 * this.boostV * this.accelPower * this.interiorVol);
                }
                updateBrakes() {
                    fe.braking
                        ? ((this.brakeT = 0.9 * this.brakeT + 0.1 * Math.min(1, Math.max(0, (fe.speed - 10) / 20))), this.sounds.brake.setPlaybackRate(1), this.sounds.brake.setVolume(0.3 * this.brakeT * fe.brakeLerp * this.interiorVol))
                        : this.sounds.brake.setVolume(0);
                }
                updateTyres(e, t) {
                    let i = 1 * Math.max(0, Math.min(1, (fe.speed - 2) / fe.metrics.topSpeed));
                    for (let n of t) {
                        if (fe.bike && n.i > 1) break;
                        var s;
                        if (
                            ((this.maxAud = Math.max(0, Math.min(1, ((Math.abs(n.latDirDot) - 0.05) * n.speed - 2) / 4))),
                            fe.handbrake && n.i > 1 && (this.maxAud = Math.max(this.maxAud, Math.min(1, (Math.abs(n.lonDirDot * n.speed) - 2) / 4))),
                            fe.braking && n.speed > 40 && (this.maxAud = Math.max(this.maxAud, 0.5 * Math.abs(n.lonDirDot))),
                            (this.tl = this.tls[n.i]),
                            this.maxAud > 0 ? (this.tl = 0.95 * this.tl + 0.05 * this.maxAud) : (this.tl = 0.8 * this.tl),
                            n.shockPos < 0.25 && (this.tl *= 4 * n.shockPos),
                            n.onRoad && this.paved)
                        )
                            Qs.value ? (this.sounds.tyresInt[n.i].setVolume(this.tl), this.sounds.tyres[n.i].setVolume(0)) : (this.sounds.tyresInt[n.i].setVolume(0), this.sounds.tyres[n.i].setVolume(this.tl)),
                                null === (s = this.sounds.offroads[n.i]) || void 0 === s || s.setVolume(0),
                                this.sounds.rolls[n.i].setVolume(i),
                                this.sounds.rolls[n.i].setPlaybackRate(0.6 + (fe.speed / fe.metrics.topSpeed) * 0.4);
                        else
                            this.sounds.tyres[n.i].setVolume(0),
                                this.sounds.tyresInt[n.i].setVolume(0),
                                n.shockPos < 0.25 ? this.sounds.offroads[n.i].setVolume(Math.max(i * n.shockPos * 4, this.tl)) : this.sounds.offroads[n.i].setVolume(Math.max(i, this.tl)),
                                this.sounds.offroads[n.i].setPlaybackRate(0.5 + fe.speed / fe.metrics.topSpeed),
                                this.sounds.rolls[n.i].setVolume(0);
                        (this.tls[n.i] = this.tl), (this.tl = Math.max(Math.min(1, Math.abs(40 * n.dShockPos)), 0)), (this.tl *= n.shockPos < 0.5 ? 0 : 2 * n.shockPos - 1), this.sounds.sus[n.i].setVolume(0.6 * this.tl * this.interiorVol);
                    }
                }
                updateRoll() {
                    this.sounds.roll.setVolume(Math.max(0, Math.min(1, (fe.speed - 2) / fe.metrics.topSpeed)));
                }
                updateCollisions() {
                    this.vc.didCollide && !this.vc.collisionsDisabled
                        ? this.coll
                            ? (this.worldSounds.scrape.position.copy(this.vc.collisionPos),
                              fe.speed > 1 ? this.worldSounds.scrape.setVolume(Math.min(1, 2 * this.vc.collisionStrength)) : this.worldSounds.scrape.setVolume(Math.min(1, 2 * this.vc.collisionStrength * fe.speed)))
                            : ((this.coll = !0),
                              this.worldSounds.hits[this.hitIndex].position.copy(this.vc.collisionPos),
                              this.worldSounds.hits[this.hitIndex].setVolume(Math.min(1, 0.6 * this.vc.collisionStrength)),
                              (this.worldSounds.hits[this.hitIndex].detune = -1200 * Math.random() + 600),
                              this.worldSounds.hits[this.hitIndex].play(),
                              (this.hitIndex = (this.hitIndex + 1) % 2))
                        : ((this.coll = !1), this.worldSounds.scrape.setVolume(0));
                }
                smoothstep(e) {
                    return -1 * (3 - 2 * e) * e * e + 1;
                }
            };
            const Ld = 2 * Math.PI,
                Rd = 2.5 * Math.PI,
                Td = { straight: 0.6, casual: 0.6, easy: 0.6, normal: 0.75, hard: 0.6 },
                Pd = { straight: 0.55, casual: 0.55, easy: 0.55, normal: 0.55, hard: 0.4 },
                Gd = {};
            var Bd = class {
                constructor(e) {
                    (this.inputs = { accel: 0, steer: 0, brake: 0 }),
                        (this.targetNode = null),
                        (this.targetFineIndex = 0),
                        (this.targetPos = new r.W()),
                        (this.targetSpeed = 0),
                        (this.targetRoadHeading = 0),
                        (this.dH = 0),
                        (this.angleDif = 0),
                        (this.angleDifAbs = 0),
                        (this.lookahead = 20),
                        (this.bendiness = 0),
                        (this.bendyAngles = []),
                        (this.bendyLookahead = 4),
                        (this.bendyFactor = 1),
                        (this.bendinessVal = 0),
                        (this.lateralOffsetFactor = 2),
                        (this.debugShape = null),
                        (this.doNotResetIfOffroad = !1),
                        (this.updateIndex = 0),
                        (this.vehicleIndex = 0),
                        (this.vehicleAccel = 0),
                        (this.pVehicleSpeed = 0),
                        (this.vehicleFrontAxel = new r.W()),
                        (this.pRoadEdgeProximity = 0),
                        (this.dRoadEdgeProximity = 0),
                        (this.pSteer = 0),
                        (this.lerpIndex = 0),
                        (this.resetVehicle = e || (() => {})),
                        (this.debugShape = new r.B(new r.S(0.5, 32, 16), new r.C({ color: 16711935 }))),
                        (this.bendinessShape = new r.B(new r.S(0.5, 32, 16), new r.C({ color: 65535 }))),
                        (this.targetShape = new r.B(new r.S(0.3, 32, 16), new r.C({ color: 16776960 }))),
                        Ih.addListener("topography", () => this.onTopographyChanged()),
                        Ih.addListener("sceneName", () => this.onTopographyChanged()),
                        this.onTopographyChanged();
                }
                onTopographyChanged() {
                    "Planet" == Ih.value.sceneName ? (this.bendyFactor = Pd[Ih.value.topography]) : (this.bendyFactor = Td[Ih.value.topography]);
                }
                initialise() {
                    (this.doNotResetIfOffroad = !fe.onRoad),
                        (this.vehicleIndex = $t.vehicleIndex),
                        (this.targetNode = $t.vehicleNode),
                        (this.bendyAngles.length = 0),
                        (this.bendyRoot = $t.vehicleNode),
                        (this.bendyTail = $t.vehicleNode),
                        (this.bendiness = this.targetNode.da),
                        this.bendyAngles.push(this.targetNode.da);
                    for (let e = 1; e < this.bendyLookahead; e++) (this.bendyTail = this.bendyTail.next), (this.bendiness += this.bendyTail.da), this.bendyAngles.push(Math.abs(this.bendyTail.da));
                }
                reset() {
                    (this.pDeltaSteer = 0), (this.pSteer = 0), (this.steerSpeed = 0);
                }
                update(e) {
                    if (
                        ((this.vehicleAccel = (fe.speed - this.pVehicleSpeed) / e),
                        (this.pVehicleSpeed = fe.speed),
                        (Gd.m = _t(fe.frontAxlePosition.x, fe.frontAxlePosition.z, $t.vehicleNode, !0)),
                        (this.roadEdgeProximity = (Gd.m.d / (Ft - fe.wheels.width / 2)) * Gd.m.s),
                        this.roadEdgeProximity < 0 ? (this.roadEdgeProximity = Math.max(-1, Math.min(0, 2 * (this.roadEdgeProximity + 0.5)))) : (this.roadEdgeProximity = Math.min(1, Math.max(0, 2 * (this.roadEdgeProximity - 0.5)))),
                        (this.roadEdgeProximityAbs = Math.abs(this.roadEdgeProximity)),
                        (this.dRoadEdgeProximity = this.roadEdgeProximityAbs - this.pRoadEdgeProximity),
                        (this.pRoadEdgeProximity = this.roadEdgeProximityAbs),
                        fe.onRoad)
                    )
                        null != this.offRoadTime && (this.offRoadTime = null), (this.doNotResetIfOffroad = !1);
                    else if (!this.doNotResetIfOffroad)
                        if (null == this.offRoadTime) (this.offRoadTime = Date.now()), (this.offRoadMidlineDist = Gd.m.d);
                        else if (Date.now() - this.offRoadTime > 5e3) {
                            if (Gd.m.d > this.offRoadMidlineDist - 5) return void this.resetVehicle();
                            this.offRoadTime = Date.now();
                        }
                    if (fe.speed < 1) {
                        if (null == this.stuckTime) this.stuckTime = Date.now();
                        else if (Date.now() - this.stuckTime > 3e3) return console.log("Autodrive stuck; forcing a reset"), (this.stuckTime = null), void this.resetVehicle();
                    } else null !== this.stuckTime && (this.stuckTime = null);
                    this.updateTarget(),
                        (Gd.dist = this.targetPos.distanceTo(fe.position)),
                        (Gd.steerRadius = Gd.dist / 2 / Math.sin(this.angleDifAbs)),
                        (this.inputs.steer = Math.atan(fe.wheels.length / Gd.steerRadius)),
                        this.angleDif > 0 && (this.inputs.steer *= -1),
                        (Gd.angleOfArrival = -2 * this.angleDif + fe.heading),
                        (Gd.vnHeading = fe.heading - ((Rd - $t.vehicleNode.a) % Ld)),
                        Gd.vnHeading > 3 ? (Gd.vnHeading -= Ld) : Gd.vnHeading < -3 && (Gd.vnHeading += Ld),
                        (Gd.vnHeading = Math.abs(Gd.vnHeading)),
                        (Gd.targetArrivalDif = this.targetRoadHeading - Gd.angleOfArrival),
                        Gd.targetArrivalDif > 3 ? (Gd.targetArrivalDif -= Ld) : Gd.targetArrivalDif < -3 && (Gd.targetArrivalDif += Ld),
                        (Gd.targetArrivalDif = Math.abs(Gd.targetArrivalDif)),
                        (Gd.beelineAssessment = 1.5 * Gd.targetArrivalDif),
                        (Gd.beelineAssessment += 4 * Math.abs(fe.slip)),
                        (Gd.beelineAssessment += Gd.vnHeading),
                        (this.beelineFactor = 1 - Math.max(0, Math.min(1, Math.cos(Gd.beelineAssessment)))),
                        this.dRoadEdgeProximity > 0 &&
                            Math.sign(this.roadEdgeProximity) != Math.sign(this.inputs.steer) &&
                            ((this.beelineFactor += this.roadEdgeProximityAbs / 4), (this.beelineFactor = Math.max(0, Math.min(1, this.beelineFactor)))),
                        (this.beelineSteer = -this.angleDif),
                        (this.inputs.steer = this.inputs.steer * (1 - this.beelineFactor) + this.beelineSteer * this.beelineFactor),
                        this.roadEdgeProximityAbs > 0 &&
                            ((this.inputs.steer < 0 && this.roadEdgeProximity < 0 && $t.vehicleNode.rWallDist) || (this.inputs.steer > 0 && this.roadEdgeProximity > 0 && $t.vehicleNode.lWallDist)) &&
                            (this.inputs.steer /= 1 + this.roadEdgeProximityAbs * this.roadEdgeProximityAbs * this.roadEdgeProximityAbs),
                        (this.inputs.steer = Math.max(Math.min(fe.metrics.maxSteer, this.inputs.steer), -fe.metrics.maxSteer)),
                        (this.targetSpeed = this.lookahead),
                        fe.speed > this.targetSpeed
                            ? ((this.targetDecel = (this.targetSpeed * this.targetSpeed - fe.speed * fe.speed) / (2 * Gd.dist)),
                              (this.inputs.accel = 0),
                              this.inputs.brake > 0 ? (this.brakeThreshold = Math.max(1, 1.5 - (this.bendinessMax * fe.metrics.brake) / 4)) : (this.brakeThreshold = Math.max(1.05, 1.5 - (this.bendinessMax * fe.metrics.brake) / 4)),
                              (this.brakeFactor = 1 + 3 * this.bendinessMax),
                              (this.brakeFactor *= 1 - (5 * fe.slip + 3 * Math.abs(this.inputs.steer))),
                              fe.speed / this.targetSpeed > this.brakeThreshold
                                  ? ((this.inputs.brake = fe.speed / this.targetSpeed - 1), (this.inputs.brake *= this.brakeFactor), (this.inputs.brake = Math.min(1, this.inputs.brake)))
                                  : (this.inputs.brake = 0))
                            : 0 == this.inputs.accel && fe.speed > 0.95 * this.targetSpeed
                            ? ((this.inputs.accel = 0), (this.inputs.brake = 0))
                            : (fe.speed > 0.8 * this.targetSpeed ? (this.inputs.accel = fe.metrics.accel * (1 - Math.max(0.1, (fe.speed - 0.8 * this.targetSpeed) / (0.2 * this.targetSpeed)))) : (this.inputs.accel = fe.metrics.accel),
                              (this.inputs.brake = 0)),
                        this.updateIndex++,
                        this.updateIndex >= 7 && (this.updateIndex = 0),
                        fe.bike ? (this.steerLerp = 7 * e) : (this.steerLerp = 0.5),
                        (this.inputs.steer = this.pSteer * (1 - this.steerLerp) + this.inputs.steer * this.steerLerp),
                        (this.pSteer = this.inputs.steer);
                }
                updateTarget() {
                    (this.lookahead = 15 + this.bendinessVal * (0.8 * fe.metrics.topSpeed - 15)), (this.maxTargetDist = 10 + Math.max(0, Math.min(this.lookahead, fe.speed) - 10));
                    let e = Math.floor(this.maxTargetDist / 10);
                    (this.targetNode.i < $t.vehicleIndex + e || this.lerpIndex >= 10 || this.targetNode.i <= $t.vehicleIndex) &&
                        ((this.bendiness -= this.targetNode.da),
                        this.bendyAngles.shift(),
                        (this.targetNode = this.targetNode.next),
                        (this.bendyTail = this.bendyTail.next),
                        (this.bendiness += this.bendyTail.da),
                        this.bendyAngles.push(Math.abs(this.bendyTail.da)),
                        this.bendinessShape.position.copy(this.bendyTail.p),
                        (this.lerpIndex = 0),
                        (this.dH = this.targetNode.p.y - $t.vehicleNode.p.y),
                        (this.bendinessVal = Math.abs(this.bendiness / this.bendyLookahead)),
                        (this.bendinessMax = Math.max(...this.bendyAngles)),
                        (this.bendinessLerp = Math.min(1, (this.bendinessMax - this.bendinessVal) / 0.75)),
                        (this.bendinessVal = this.bendinessVal * (1 - this.bendinessLerp) + this.bendinessMax * this.bendinessLerp),
                        (this.bendinessVal -= 0.025),
                        (this.bendinessVal = Math.min(1, Math.max(0, this.bendyFactor - this.bendinessVal) / this.bendyFactor)),
                        (this.bendinessVal *= this.bendinessVal),
                        (this.bendinessVal *= this.bendinessVal));
                    let t = this.targetNode.p.distanceTo(fe.position);
                    if (((this.lerpIndex = Math.max(this.lerpIndex, Math.max(Math.floor(this.maxTargetDist - t)), 0)), this.lerpIndex < 10)) {
                        this.targetPos.copy(this.targetNode.ps[this.lerpIndex]);
                        let e = this.targetNode.a - this.targetNode.next.a;
                        e = e > 3 ? this.targetNode.next.a + Ld : e < -3 ? this.targetNode.next.a - Ld : this.targetNode.next.a;
                        let t = 1 - this.lerpIndex / 10;
                        this.targetRoadHeading = this.targetNode.a * t + e * (1 - t);
                    } else this.targetPos.copy(this.targetNode.next.p), (this.targetRoadHeading = this.targetNode.next.a);
                    this.targetRoadHeading = (Rd - this.targetRoadHeading) % Ld;
                    let i = Ll(this.targetPos.x - fe.position.x, this.targetPos.z - fe.position.z);
                    (this.angleDif = fe.heading - i),
                        this.angleDif > Math.PI ? (this.angleDif -= Ld) : this.angleDif < -Math.PI && (this.angleDif += Ld),
                        (this.angleDifAbs = Math.abs(this.angleDif)),
                        this.targetShape.position.copy(this.targetNode.p),
                        this.debugShape.position.copy(this.targetPos);
                }
            };
            const Wd = [2.23694, 3.59999],
                Ed = [1 / 1604, 0.001],
                Fd = new r.W(0, 1, 0),
                Zd = 2 * Math.PI,
                Hd = Math.PI / 180,
                Qd = {
                    default: new r.E({ color: 8947848 }),
                    grey: new r.D({ color: 6710886 }),
                    wheel: new r.D({ color: 4473924 }),
                    white: new r.D({ color: 15658734 }),
                    black: new r.D({ color: 3355443 }),
                    tire: new r.D({ color: 2236962 }),
                    body: new r.F({ color: 16316664, roughness: 0.5 }),
                    map: new r.F({ color: 16777215, roughness: 0.5, map: et(null) }),
                    metal: new r.D({ color: 16777215 }),
                    redlight: new r.F({ color: 6702148, emissive: 16711680, roughness: 0.5 }),
                    rearlight: new r.F({ color: 6702148, emissive: 16711680, roughness: 0.5, emissiveIntensity: 0 }),
                    reverselight: new r.F({ color: 6710852, emissive: 16777096 }),
                    headlight: new r.F({ color: 6710886, emissive: 16777181 }),
                    window: new r.E({ color: 6712183, specular: 2236962 }),
                    shadow: new r.C({ color: 0, colorWrite: !1, depthWrite: !1, side: r.k }),
                    null: new r.D({ color: 16711935 }),
                },
                Yd = { turnSpeed: 0, turnAccel: 0, pTurnSpeed: 0 };
            var Vd = class {
                constructor() {
                    (this.inputs = { accel: 0, steer: 0, controllerSteer: 0, brake: 0, handbrake: 0, stiffSteer: 0 }),
                        (this.sounds = {}),
                        (this.inputDisabled = !1),
                        (this.orientation = new r.m(0, 0, 0, "YXZ")),
                        (this.steerOrientation = new r.m(0, 0, 0, "YXZ")),
                        (this.vehicleDef = null),
                        (this.selectedVehicleIndex = 0),
                        (this.driveModeIndex = 0),
                        (this.driveForceFactor = 1),
                        (this.insideWall = !0),
                        (this.wasInsideWall = !0),
                        (this.tiltX = 0),
                        (this.tiltZ = 0),
                        (this.body = null),
                        (this.wheels = new r.G()),
                        (this.dashboard = null),
                        (this.wheelEulers = []),
                        (this.tV = new r.W()),
                        (this.tVec = new r.W()),
                        (this.wheelHeights = []),
                        (this.groundHeights = []),
                        (this.wheelFwd = new r.W(0, 0, 1)),
                        (this.wheelVelDir = new r.W()),
                        (this.wheelVelMag = 0),
                        (this.targetHeading = 0),
                        (this.pOrientation = 0),
                        (this.motionDir = new r.W()),
                        (this.pPos = new r.W()),
                        (this.analytics = { resetCount: 0, rawDS: 0 }),
                        (this.promptResetTimer = null),
                        (this.update = () => {}),
                        (this.dom = {}),
                        (this.hasInit = !1),
                        (this.canCancelAutodrive = !1),
                        (this.canEnableAutodrive = !0),
                        (this.hasCruiseTarget = !1),
                        (this.hasSpeedLimit = !1),
                        (this.onSpeedControlChangedBound = this.onSpeedControlChanged.bind(this)),
                        (this.changeVehicleBound = this.changeVehicle.bind(this)),
                        (this.changeModeBound = this.changeMode.bind(this)),
                        (this.changeSideBound = this.changeSide.bind(this)),
                        (this.changeGripBound = this.changeGrip.bind(this)),
                        (this.wasUsingCruise = !1),
                        (this.headlights = { left: {}, right: {} }),
                        (this.pdT = 0.1),
                        (this.holdHandbrake = !1),
                        (this.uiTimer = 0),
                        (this.speedFactor = 1),
                        (this.distFactor = 1),
                        (this.onUnitsChangedBound = this.onUnitsChanged.bind(this)),
                        (this.onControllerChangedBound = this.onControllerChanged.bind(this)),
                        (this.groundAngleLat = 0),
                        (this.groundAngleLon = 0),
                        (this.wheelDown = new r.W()),
                        (this.didCollide = !1),
                        (this.collisionSide = 0),
                        (this.collisionPos = new r.W()),
                        (this.printDebug = !1),
                        (this.v1 = new r.W()),
                        (this.v2 = new r.W()),
                        (this.v3 = new r.W()),
                        (this.v4 = new r.W()),
                        (this.v5 = new r.W()),
                        (this.didCrash = !1),
                        (this.curWallIndex = null),
                        (this.collisionStrength = 0),
                        (this.wrongWay = !1),
                        (this.nodeCheckFrame = 60),
                        (this.targetVehicleNodeIndex = 0),
                        (this.nextUpdateDistance = 25),
                        (this.nextUpdateIncrement = 25),
                        (this.maxUpdateIncrement = 250),
                        (this.nextAnalyticsUpdate = {}),
                        (this.steerSpeed = 0),
                        (this.steerMode = 1),
                        (this.lastAccel = 0),
                        (this.hasBoost = !1),
                        (this.hasAccel = !1),
                        (this.boostFromTap = !1),
                        (this.useMouse = !0),
                        (this.maxSteerSpeed = 4),
                        (this.prevSteer = 0),
                        (this.scrollSteer = !1),
                        (this.scrollAccel = !1),
                        (this.mouse = { x: 0, y: 0 }),
                        (this.prevMouse = { x: 0, y: 0 }),
                        (this.mouseDist = 0),
                        (this.mouseCruiseSpeed = Wl.default.speed),
                        (this.autodrive = ce.value),
                        (this.limitBrake = !1),
                        (this.softStiff = !1),
                        (this.softTurnInterval = 0.75),
                        (this.softInterval = 1),
                        (this.softTimer = 0),
                        (this.softLerp = 0),
                        (this.softTurning = !1),
                        (this.softTurningDir = 0),
                        (this.softStartPoint = 0),
                        (this.softSteerFactor = 1),
                        (this.softSteerTimeFactor = 1),
                        (this.softMaxSteer = 1),
                        (this.softSlip = 1),
                        (this.softSlipB = 1),
                        (this.stickyTurning = !1),
                        (this.stickyTimer = 0),
                        this.initialise();
                }
                initialise() {
                    (this.autoDriver = new Bd(() => {
                        this.resetToNode($t.vehicleNode);
                    })),
                        Wl.addListener("enabled", this.onSpeedControlChangedBound),
                        Wl.addListener("control", this.onSpeedControlChangedBound),
                        this.onSpeedControlChanged(),
                        this.initialisePosition(),
                        (this.audio = new Od(this)),
                        Pe.addListener("type", this.changeVehicleBound),
                        Pe.addListener("mode", this.changeModeBound),
                        Pe.addListener("side", this.changeSideBound),
                        Pe.addListener("gripFactor", this.changeGripBound),
                        ie.addListener("Units", this.onUnitsChangedBound),
                        this.onUnitsChanged(ie.Units),
                        D.addListener(this.onControllerChangedBound),
                        this.onControllerChanged(D.value, !0),
                        this.initVehicle(ke[Pe.value.type]),
                        this.changeGrip(),
                        (this.dom.speed = document.getElementById("ui-speed-val")),
                        (this.dom.dist = document.getElementById("ui-dist-val")),
                        (this.dom.mouseMarker = document.getElementById("ui-mouse-bar-marker")),
                        (this.dom.mousePrompt = document.getElementById("ui-mouse-prompt")),
                        fe.addListener(xe, this.onHeadlightsChanged.bind(this)),
                        this.onHeadlightsChanged(),
                        (zh.dist = 10 * ($t.vehicleNode.i - $t.initIndex + Ih.accumulatedProgress)),
                        Ih.addListener("weatherIndex", () => this.updateHeadlights()),
                        ce.addListener(() => {
                            this.onAutodrive();
                        }),
                        this.onAutodrive(),
                        (this.headlights = fe.headlights),
                        (this.hasInit = !0);
                }
                onSpeedControlChanged() {
                    (this.hasCruiseTarget = Wl.value.enabled && Wl.value.control == Gl), (this.hasSpeedLimit = Wl.value.enabled && Wl.value.control == Bl);
                }
                onAutodrive() {
                    (this.autodrive = ce.value), (fe.handbrake = !1), (this.holdHandbrake = !1), this.autodrive && ((this.canCancelAutodrive = !1), this.autoDriver.initialise());
                }
                initialisePosition() {
                    $t.initIndex = $t.vehicleNode.i - Ih.initialNode;
                    let e = $t.vehicleNode.a - $t.vehicleNode.next.da / 2;
                    this.setPose($t.vehicleNode.p.x, $t.vehicleNode.p.y, $t.vehicleNode.p.z, Math.PI / 2 - e, !0), this.autoDriver.initialise();
                }
                detatch() {
                    Pe.removeListener("type", this.changeVehicleBound),
                        Pe.removeListener("mode", this.changeVehicleBound),
                        Pe.removeListener("side", this.changeSideBound),
                        ie.removeListener("Units", this.onUnitsChangedBound),
                        fe.removeListener(xe, this.onHeadlightsChanged.bind(this));
                }
                setDriveMode(e) {
                    if (((this.driveModeFactor = 0.5), (this.wheels.children[0].hasDrive = !0), (this.wheels.children[1].hasDrive = !0), (this.driveMode = e), fe.bike))
                        switch (e) {
                            case Ne:
                                (this.driveModeFactor = 1), (this.wheels.children[0].hasDrive = !0), (this.wheels.children[1].hasDrive = !1);
                                break;
                            case ze:
                                (this.driveModeFactor = 1), (this.wheels.children[0].hasDrive = !1), (this.wheels.children[1].hasDrive = !0);
                        }
                    else
                        switch (((this.wheels.children[2].hasDrive = !0), (this.wheels.children[3].hasDrive = !0), e)) {
                            case Ne:
                                (this.driveModeFactor = 1), (this.wheels.children[2].hasDrive = !1), (this.wheels.children[3].hasDrive = !1);
                                break;
                            case ze:
                                (this.driveModeFactor = 1), (this.wheels.children[0].hasDrive = !1), (this.wheels.children[1].hasDrive = !1);
                        }
                }
                setDriveSide(e) {
                    fe.steeringWheel &&
                        (1 == e
                            ? ((fe.steeringWheel.position.x = fe.metrics.steeringPos.x), (fe.dashboard.position.x = fe.metrics.steeringPos.x))
                            : ((fe.steeringWheel.position.x = -fe.metrics.steeringPos.x), (fe.dashboard.position.x = -fe.metrics.steeringPos.x)));
                }
                onHeadlightsChanged() {
                    this.setLights(fe.headlights);
                }
                changeVehicle(e) {
                    this.initVehicle(ke[e]), this.changeGrip(), Uh.sendUpdate("vehicleChange", e);
                }
                changeMode(e) {
                    this.setDriveMode(e), Uh.sendUpdate("driveModeChange", e);
                }
                changeSide(e) {
                    this.setDriveSide(e);
                }
                changeGrip() {
                    (Yd.slipBase = fe.metrics.slipBase * Pe.gripFactor), (Yd.slipMod = fe.metrics.slipMod * Pe.gripFactor);
                }
                setLights(e) {
                    e ? ((Qd.rearlight.emissiveIntensity = 0.5), (Qd.headlight.emissiveIntensity = 0.5)) : ((Qd.rearlight.emissiveIntensity = 0), (Qd.headlight.emissiveIntensity = 0));
                }
                updateHeadlights() {
                    let e = 3.25 - 2.5 * (wt.intensity + ft.intensity),
                        t = Math.max(0.25, e);
                    fe.setHeadlightIntensity(t);
                }
                setBrake(e, t = 0) {
                    e ? (fe.braking || (fe.brakeLerp = 0), (fe.braking = !0), (Qd.redlight.emissiveIntensity = 0.5)) : ((fe.braking = !1), (Qd.redlight.emissiveIntensity = 0)), (this.inputs.brake = t);
                }
                positionHeadlights() {}
                initVehicle(e) {
                    var t;
                    if ((null === (t = this.vehicleDef) || void 0 === t ? void 0 : t.name) == e.name) return;
                    for (this.update = this.updatePass; fe.geo.children.length; ) fe.geo.remove(fe.geo.children[fe.geo.children.length - 1]);
                    (this.vehicleDef = e), (this.softSteerTimeFactor = 1), fe.setModel(e), e.map && (Qd.map.map = et(e.map));
                    let i = e.bodyObj,
                        s = e.wheelObj,
                        n = e.steerObj,
                        a = e.dashObj;
                    const o = new tn.a();
                    let r = Qd;
                    if (e.skins) {
                        let t = Object.keys(e.skins)[0];
                        for (let i in e.skins[t]) r[i].color.setHex(e.skins[t][i]);
                    }
                    if (
                        (o.load(i.default, (e) => {
                            e.traverse((e) => {
                                if (e.isMesh) {
                                    let t = Qd.default,
                                        i = e.name.split("_")[1];
                                    i in Qd && (t = Qd[i]), "dash" == i && (this.dashboard = e), (e.material = t), "shadow" == i && (e.castShadow = !0);
                                }
                            }),
                                this.positionHeadlights(),
                                this.updateHeadlights(),
                                (e.rotation.y = -Math.PI / 2),
                                fe.geo.add(e);
                        }),
                        o.load(s.default, (t) => {
                            t.traverse((e) => {
                                if (e.isMesh) {
                                    let t = Qd.wheel,
                                        i = e.name.split("_")[1];
                                    i in Qd && (t = Qd[i]), (e.material = t), "shadow" == i && (e.castShadow = !0), (e.position.z -= fe.wheels.tyreWidth);
                                }
                            }),
                                this.initWheels(t, fe.bike),
                                this.setDriveMode(Pe.value.mode),
                                this.audio.initForVehicle(e, this.inputs, this.wheels.children),
                                this.resetToNode($t.vehicleNode),
                                (this.update = this.updateStationed),
                                td.pause();
                        }),
                        n)
                    )
                        o.load(n.default, (e) => {
                            e.traverse((e) => {
                                if (e.isMesh) {
                                    let t = Qd.default,
                                        i = e.name.split("_")[1];
                                    i in Qd && (t = Qd[i]), (e.material = t);
                                }
                            }),
                                (e.rotation.order = "YZX"),
                                (e.rotation.y = -Math.PI / 2),
                                (e.rotation.z = -fe.metrics.steeringAngle),
                                e.position.copy(fe.metrics.steeringPos),
                                0 == Pe.value.side && (e.position.x *= -1),
                                (fe.steeringWheel = e),
                                fe.geo.add(e);
                        });
                    else if (fe.steeringWheel) {
                        var h;
                        null === (h = fe.steeringWheel.geometry) || void 0 === h || h.dispose(), (fe.steeringWheel = null);
                    }
                    if (a)
                        o.load(a.default, (e) => {
                            e.traverse((e) => {
                                if (e.isMesh) {
                                    let t = Qd.default,
                                        i = e.name.split("_")[1];
                                    i in Qd && (t = Qd[i]), (e.material = t);
                                }
                            }),
                                (e.rotation.y = -Math.PI / 2),
                                e.position.copy(fe.metrics.steeringPos),
                                0 == Pe.value.side && (e.position.x *= -1),
                                (fe.dashboard = e),
                                fe.geo.add(e);
                        });
                    else if (fe.dashboard) {
                        var l;
                        null === (l = fe.dashboard.geometry) || void 0 === l || l.dispose(), (fe.dashboard = null);
                    }
                }
                initLights() {
                    fe.setHeadlightColour(fe.headlightColour);
                }
                setPose(e, t, i, s, n = !1) {
                    for (var a; s < 0; ) s += 2 * Math.PI;
                    let o = 0;
                    if (n && (null === (a = fe.wheels) || void 0 === a ? void 0 : a.length)) {
                        let n = new r.W(e + Math.sin(s) * fe.wheels.length, t, i + Math.cos(s) * fe.wheels.length),
                            a = Sl.getHeight(n);
                        (o = -Math.tan((a - t) / fe.wheels.length)), (t += fe.wheels.travel / 2);
                    }
                    fe.position.set(e, t, i),
                        (this.orientation.x = o),
                        (this.orientation.z = 0),
                        (this.orientation.y = s),
                        (fe.heading = this.orientation.y),
                        (fe.motionHeading = fe.heading),
                        fe.setRotationFromEuler(this.orientation),
                        fe.updateMatrix(),
                        fe.updateMatrixWorld(),
                        this.updateVehicleNode(),
                        ($t.vehicleIndexDidChange = !0);
                }
                initWheels(e, t = !1) {
                    let i,
                        s = this.vehicleDef.wheels;
                    for (; this.wheels.children.length; ) this.wheels.remove(this.wheels.children[this.wheels.children.length - 1]);
                    (this.wheelEulers.length = 0),
                        (i = e.clone()),
                        this.prepWheelState(i, s),
                        (i.i = 0),
                        (i.name = "fl"),
                        (i.front = !0),
                        (i.relPos = new r.W(t ? 0 : s.width / 2, s.radius, s.length)),
                        (i.hasDrive = !0),
                        i.position.copy(i.relPos),
                        (i.rotation.y = Math.PI / 2),
                        this.wheelEulers.push(new r.m(0, Math.PI / 2, 0, "YXZ")),
                        this.wheels.add(i),
                        this.updateWheelWorldPos(i),
                        i.pPos.copy(i.worldPos),
                        (i = e.clone()),
                        this.prepWheelState(i, s),
                        (i.i = 1),
                        (i.front = !t),
                        (i.name = "fr"),
                        (i.relPos = new r.W(t ? 0 : -s.width / 2, s.radius, t ? 0 : s.length)),
                        (i.hasDrive = !0),
                        i.position.copy(i.relPos),
                        (i.rotation.y = -Math.PI / 2),
                        this.wheelEulers.push(new r.m(0, -Math.PI / 2, 0, "YXZ")),
                        this.wheels.add(i),
                        this.updateWheelWorldPos(i),
                        i.pPos.copy(i.worldPos),
                        t ||
                            ((i = e.clone()),
                            this.prepWheelState(i, s),
                            (i.i = 2),
                            (i.front = !1),
                            (i.name = "rl"),
                            (i.relPos = new r.W(s.width / 2, s.radius, 0)),
                            (i.hasDrive = !1),
                            i.position.copy(i.relPos),
                            (i.rotation.y = Math.PI / 2),
                            this.wheels.add(i),
                            this.updateWheelWorldPos(i),
                            i.pPos.copy(i.worldPos),
                            (i = e.clone()),
                            this.prepWheelState(i, s),
                            (i.i = 3),
                            (i.front = !1),
                            (i.name = "rr"),
                            (i.relPos = new r.W(-s.width / 2, s.radius, 0)),
                            (i.hasDrive = !1),
                            i.position.copy(i.relPos),
                            (i.rotation.y = -Math.PI / 2),
                            this.wheels.add(i),
                            this.updateWheelWorldPos(i),
                            i.pPos.copy(i.worldPos)),
                        fe.geo.add(this.wheels);
                }
                prepWheelState(e, t) {
                    (e.shockPos = 0.5),
                        (e.dShockPos = 0),
                        (e.shockFactor = 0.5),
                        (e.shockExcess = 0),
                        (e.groundHeight = 0),
                        (e.pHeight = 0),
                        (e.worldPos = new r.W()),
                        (e.tPos = new r.W()),
                        (e.tVel = new r.W()),
                        (e.pVel = new r.W()),
                        (e.pPos = new r.W()),
                        (e.height = 0),
                        (e.pSus = 0),
                        (e.vel = new r.W()),
                        (e.velDir = new r.W()),
                        (e.acc = new r.W()),
                        (e.groundCollide = 0),
                        (e.groundNorm = new r.W()),
                        (e.groundState = { n: [0, 1, 0] }),
                        (e.speed = 0),
                        (e.lonDirDot = 0),
                        (e.latDirDot = 0),
                        (e.friction = 1),
                        (e.wd = 0),
                        (e.collisionFactor = 0),
                        (e.radius = t.radius),
                        (e.travel = t.travel);
                }
                updateWheelWorldPos(e) {
                    e.worldPos.copy(e.relPos), e.worldPos.applyMatrix4(fe.matrixWorld);
                }
                destroy() {}
                suspend() {
                    this.audio.suspend(), (this.update = this.updateStationed), td.pause();
                }
                reload() {
                    this.initialisePosition(), this.resetToNode($t.vehicleNode);
                }
                updateStationed(e) {
                    if (
                        (($t.vehicleIndexDidChange = !1),
                        fe.pPosition.copy(fe.position),
                        (Y.signal.Handbrake = 1),
                        this.handleInput(e),
                        (fe.handbrake = !0),
                        (this.useMouse && Y.controllerSignal.Forward > 0) || Y.signal.Backward + Y.signal.Forward > 0 || (!this.useMouse && this.hasCruiseTarget) || this.autodrive)
                    )
                        return (fe.handbrake = !1), (this.holdHandbrake = !this.hasCruiseTarget), (this.update = this.updateLive), td.resume(), void (this.dom.mousePrompt.style.display = "none");
                    (this.inputs.accel = 0), this.updateWheelMotion(e), this.updateChassisMotion(e), this.updateWheelState(e), this.audio.update(e), (this.pdT = e);
                }
                updatePass(e, t) {}
                updateLive(e, t) {
                    fe.pPosition.copy(fe.position),
                        this.handleInput(e),
                        this.updateWheelMotion(e),
                        this.updateChassisMotion(e),
                        this.updateWheelState(e),
                        this.didCollide && !this.collisionsDisabled && (this.updateChassisMotion(e), this.updateWheelState(e), (this.didCollide = !0)),
                        this.updateVehicleState(e),
                        (this.uiTimer += e),
                        this.uiTimer > 0.033 && ((this.uiTimer -= 0.033), this.updateUI()),
                        (this.pdT = e),
                        ($t.vehicleIndexDidChange = !1),
                        this.updateVehicleNode();
                    try {
                        this.audio.update(e);
                    } catch (Au) {
                        if ((this.handleCrash(), this.didCrash)) throw ((Au.cause = "vehicle_matrix"), (Au.data = this.wheels.children[0]), Au);
                    }
                }
                updateVehicleState(e) {
                    var t, i, s, n;
                    for (Yd.w of ((this.dS = ((t = fe.pPosition.x), (i = fe.pPosition.z), (s = fe.position.x), (n = fe.position.z), Math.sqrt((s - t) * (s - t) + (n - i) * (n - i)))),
                    (this.analytics.rawDS += this.dS),
                    fe.vel.subVectors(fe.pPosition, fe.position).multiplyScalar(1 / e),
                    (fe.speed = this.dS / e),
                    (fe.speedLerp = Math.min(1, fe.speed / fe.metrics.topSpeed)),
                    (zh.speed = fe.speed),
                    fe.accel.set(0, 0, 0),
                    this.wheels.children))
                        fe.accel.add(Yd.w.acc.multiplyScalar(1 / e));
                    if ((fe.accel.multiplyScalar(0.25), fe.accel.applyAxisAngle(Fd, -this.orientation.y), fe.pVel.copy(fe.vel), !isFinite(fe.speed))) {
                        let e = { wheelHeights: this.wheelHeights, tiltX: this.tiltX, tiltZ: this.tiltZ, dS: this.dS, speed: fe.speed, pos: fe.position, pPos: fe.pPosition, nodeIndex: $t.vehicleIndex, onRoad: fe.onRoad };
                        throw new Error(JSON.stringify(e));
                    }
                }
                onUnitsChanged(e) {
                    (this.speedFactor = Wd[e]), (this.distFactor = Ed[e]);
                }
                onControllerChanged(e, t = !1) {
                    (this.controller = M[e]),
                        (this.useMouse = 1 == e),
                        this.useMouse ? (this.hasCruiseTarget ? t || (this.wasUsingCruise = !0) : (Wl.reset(), this.resetToNode($t.vehicleNode))) : this.wasUsingCruise || t ? (this.wasUsingCruise = !1) : Wl.set("enabled", !1),
                        t || ce.set(!1),
                        Uh.sendUpdate("inputModeChange", e);
                }
                updateUI() {
                    (this.dom.speed.innerHTML = (zh.speed * this.speedFactor).toFixed(1)), (this.dom.dist.innerHTML = (Math.floor(zh.dist * this.distFactor * 10) / 10).toFixed(1));
                }
                updateBasic(e) {
                    (fe.speed += this.inputs.accel * e),
                        (fe.steer += this.inputs.steer * e),
                        (fe.steer = Math.max(Math.min(fe.metrics.maxSteer, fe.steer), -fe.metrics.maxSteer)),
                        (fe.position.x += Math.cos(fe.rotation.y) * fe.speed * e),
                        (fe.position.z -= Math.sin(fe.rotation.y) * fe.speed * e),
                        (fe.rotation.y += fe.steer * e);
                }
                updateWheelMotion(e) {
                    let t;
                    for (t of ((this.printDebug = !this.printDebug),
                    this.wheelDown.set(0, -fe.wheels.radius, 0).applyEuler(this.orientation),
                    (fe.rockLonTarget = fe.accel.z + this.sinTiltX * Rl.value),
                    fe.rockLonTarget > 0 ? (fe.rockLonTarget /= Math.max(fe.rockLonTarget, 14)) : (fe.rockLonTarget /= -1 * Math.min(fe.rockLonTarget, -14)),
                    (fe.rockLonTarget *= fe.metrics.rockFactor),
                    (Yd.l = Math.min(1, 15 * e)),
                    (fe.rockLon = fe.rockLon * (1 - Yd.l) + fe.rockLonTarget * Yd.l),
                    this.vehicleDef.bike ||
                        ((fe.rockLatTarget = fe.accel.x - this.sinTiltZ * Rl.value),
                        fe.rockLatTarget > 0 ? (fe.rockLatTarget /= Math.max(fe.rockLatTarget, 20)) : (fe.rockLatTarget /= -1 * Math.min(fe.rockLatTarget, -20)),
                        (fe.rockLatTarget *= fe.metrics.rockFactor),
                        (fe.rockLat = fe.rockLat * (1 - Yd.l) + fe.rockLatTarget * Yd.l)),
                    this.wheels.children))
                        t.front && (this.steerOrientation.copy(this.orientation), fe.bike ? (this.steerOrientation.y += fe.steer) : 0 == t.i ? (this.steerOrientation.y += fe.steerL) : (this.steerOrientation.y += fe.steerR)),
                            t.vel.subVectors(t.worldPos, t.pPos),
                            t.tVel.subVectors(t.tPos, t.pPos),
                            (Yd.steepness = 0),
                            t.shockPos > 0 && t.dH > 0 && (Yd.steepness = t.dH / t.vel.length()),
                            (t.dXZ = Math.sqrt(t.vel.x * t.vel.x + t.vel.z * t.vel.z)),
                            (t.dH = t.groundHeight - t.pHeight),
                            (t.collisionFactor = 0),
                            (t.pdH = (t.vel.y - t.tVel.y) / t.dXZ),
                            !t.onRoad && t.dH > 0 && t.pdH > 0 && t.pdH < 1 && ((Yd.m = 1 - 2 * t.pdH), Yd.m < 1 && ((t.vel.x *= Yd.m), (t.vel.z *= Yd.m))),
                            t.velDir.copy(t.vel).normalize(),
                            0 == t.shockPos ? (t.dS = 0.98 * t.dS) : (t.dS = t.vel.length()),
                            t.vel.divideScalar(this.pdT),
                            (t.speed = t.vel.length()),
                            t.pPos.copy(t.worldPos),
                            t.front
                                ? (this.tV.set(0, 0, 1).applyEuler(this.steerOrientation),
                                  (t.lonDirDot = t.velDir.dot(this.tV)),
                                  (t.direction = t.lonDirDot < 0 ? -1 : 1),
                                  this.tV.set(1, 0, 0).applyEuler(this.steerOrientation),
                                  (t.latDirDot = t.velDir.dot(this.tV)))
                                : (this.tV.set(0, 0, 1).applyEuler(this.orientation),
                                  (t.lonDirDot = t.velDir.dot(this.tV)),
                                  (t.direction = t.lonDirDot < 0 ? -1 : 1),
                                  this.tV.set(1, 0, 0).applyEuler(this.orientation),
                                  (t.latDirDot = t.velDir.dot(this.tV))),
                            t.dXZ > 0.001 ? (t.groundAngle = -Math.atan(t.dH / t.dXZ) || 0) : (t.groundAngle = this.tiltX * t.lonDirDot + this.tiltZ * t.latDirDot),
                            t.acc.set(0, 0, 0),
                            fe.braking
                                ? ((fe.brakeLerp += e / 0.25),
                                  fe.brakeLerp > 1 && (fe.brakeLerp = 1),
                                  (fe.brakeForce = fe.brakeLerp * fe.metrics.brake * this.inputs.brake),
                                  this.autodrive && (fe.brakeForce = this.autoDriver.inputs.brake * fe.metrics.brake),
                                  (Yd.maxDecel = ((t.speed * t.lonDirDot) / e) * -1),
                                  Yd.maxDecel < 0 ? (t.acc.z = Math.max(Yd.maxDecel, -fe.brakeForce)) : (t.acc.z = Math.min(Yd.maxDecel, fe.brakeForce)),
                                  t.speed < 0.1 && (fe.braking = !1))
                                : t.hasDrive &&
                                  ((t.acc.z = fe.drive * this.driveModeFactor),
                                  fe.bike
                                      ? t.front
                                          ? (t.acc.z *= fe.frSteerDifferential)
                                          : (t.acc.z /= fe.frSteerDifferential)
                                      : 0 == t.i
                                      ? (t.acc.z *= fe.steerDifferential)
                                      : 1 == t.i
                                      ? (t.acc.z /= fe.steerDifferential)
                                      : 2 == t.i
                                      ? (t.acc.z *= fe.rearSteerDifferential)
                                      : (t.acc.z /= fe.rearSteerDifferential)),
                            t.friction < 1 && (t.acc.z *= t.friction),
                            fe.bike && (t.friction *= 2),
                            !t.front && fe.handbrake && (t.acc.z = 0),
                            (Yd.wheelWeight = 2 * t.shockFactor),
                            (Yd.frictionMultiplier = this.hasBoost && !this.autodrive ? Math.max(0.75, Math.abs(t.lonDirDot)) : 1),
                            (Yd.latNorm = Yd.wheelWeight * Math.cos(t.groundAngle * Math.abs(t.latDirDot)) * -Rl.value * t.friction * Yd.frictionMultiplier),
                            this.useMouse || this.autodrive
                                ? fe.bike || this.autodrive
                                    ? (Yd.maxLat = ((t.speed * t.latDirDot) / e) * -1 - Rl.value * this.sinTiltZ)
                                    : (Yd.maxLat = ((t.speed * t.latDirDot) / e) * -0.5 - Rl.value * this.sinTiltZ)
                                : ((Yd.maxLat = (t.speed / e) * -t.latDirDot),
                                  t.hasDrive && this.hasBoost
                                      ? (Pe.mode == je && (Yd.maxLat *= Yd.slipBase - 1.25 * Yd.slipMod * (fe.speedLerp * fe.speedLerp)),
                                        (Pe.mode == Ne || Pe.mode == ze) && (Yd.maxLat *= Yd.slipBase - Yd.slipMod * (fe.speedLerp * fe.speedLerp)))
                                      : t.speed > 1 && (Yd.maxLat *= Yd.slipBase - Yd.slipMod * (fe.speedLerp * fe.speedLerp)),
                                  (Yd.maxLat -= Rl.value * this.sinTiltZ)),
                            (t.slip = 0),
                            Yd.maxLat < 0
                                ? Yd.maxLat < -Yd.latNorm
                                    ? ((t.spin = t.acc.z > 0 && t.latDirDot > 0.3), (t.slip = t.latDirDot), (t.acc.x += -Yd.latNorm))
                                    : ((t.spin = !1), (t.acc.x += Yd.maxLat))
                                : Yd.maxLat > Yd.latNorm
                                ? ((t.spin = t.acc.z > 0 && t.latDirDot < -0.3), (t.slip = -t.latDirDot), (t.acc.x += Yd.latNorm))
                                : ((t.spin = !1), (t.acc.x += Yd.maxLat)),
                            !t.front &&
                                fe.handbrake &&
                                ((Yd.lonNorm = Yd.wheelWeight * Math.cos(t.groundAngle * t.lonDirDot) * -Rl.value * t.friction * Yd.frictionMultiplier),
                                (Yd.maxLon = ((t.speed * t.lonDirDot) / e) * -1 + Rl.value * this.sinTiltX * 2),
                                (t.acc.z += Math.max(Math.min(Yd.maxLon, Yd.lonNorm), -Yd.lonNorm))),
                            (t.onRoad || 1 == t.groundNorm.y) && ((t.acc.x += Yd.wheelWeight * Rl.value * this.sinTiltZ), (t.acc.z -= Yd.wheelWeight * Rl.value * this.sinTiltX)),
                            (Yd.rawSpeed = t.speed * t.lonDirDot),
                            !(t.i > 1 && fe.handbrake) &&
                                Math.abs(Yd.rawSpeed) > 0 &&
                                ((Yd.rollResistance = Yd.rawSpeed * fe.metrics.rollResistance),
                                Yd.rawSpeed < 0 ? (Yd.rollResistance += Math.max(-0.1, Yd.rawSpeed / e)) : (Yd.rollResistance += Math.min(0.1, Yd.rawSpeed / e)),
                                (t.acc.z -= Yd.rollResistance)),
                            (t.acc.y += fe.downforce * Rl.value),
                            (t.acc.z *= Math.min(1, 3 * t.shockFactor)),
                            t.front ? t.acc.applyEuler(this.steerOrientation) : t.acc.applyEuler(this.orientation),
                            (t.acc.y += Rl.value),
                            t.onRoad || 1 == t.groundNorm.y || ((t.acc.x -= Yd.wheelWeight * Rl.value * t.groundNorm.x * 1.5), (t.acc.z -= Yd.wheelWeight * Rl.value * t.groundNorm.z * 1.5)),
                            t.shockPos > 0 && (t.front ? (t.acc.y += fe.rockLon) : (t.acc.y -= fe.rockLon), fe.bike || (t.i % 2 == 0 ? (t.acc.y += fe.rockLat) : (t.acc.y -= fe.rockLat))),
                            (t.acc.y -= Yd.wheelWeight * Rl.value),
                            (t.dSus = (t.pSus - t.acc.y) / e),
                            (t.pSus = t.acc.y),
                            t.dSus < 0 ? (t.dSus *= fe.metrics.dampening) : fe.bike ? (t.dSus *= 0.5 * fe.metrics.dampening) : (t.dSus *= 1.5 * fe.metrics.dampening),
                            (t.acc.y -= t.dSus),
                            t.vel.add(t.acc.multiplyScalar(e)),
                            t.tPos.addVectors(t.worldPos, t.vel.multiplyScalar(e)),
                            t.pVel.copy(t.vel),
                            (this.wheelHeights[t.i] = t.tPos.y),
                            (this.groundHeights[t.i] = t.groundHeight),
                            t.shockPos > 0 && (t.hasDrive && t.spin ? (t.dS *= 1 + fe.slip) : (t.dS *= Math.abs(t.lonDirDot)));
                }
                updateChassisMotion(e) {
                    (Yd.wheelWidth = this.vehicleDef.wheels.width),
                        (Yd.wheelLength = this.vehicleDef.wheels.length),
                        (Yd.axleFPos = this.v1),
                        (Yd.axleFDir = this.v2),
                        (Yd.axleRPos = this.v3),
                        (Yd.axleRDir = this.v4),
                        (Yd.chassisDir = this.v5),
                        fe.bike
                            ? (Yd.axleFPos.copy(this.wheels.children[0].tPos),
                              Yd.axleRPos.copy(this.wheels.children[1].tPos),
                              (Yd.shockF = this.wheels.children[0].collisionFactor + this.wheels.children[0].shockPos),
                              (Yd.shockR = this.wheels.children[1].collisionFactor + this.wheels.children[1].shockPos),
                              (Yd.shockSum = Yd.shockF + Yd.shockR),
                              (Yd.shockRatio = 0 == Yd.shockSum ? 0.5 : Yd.shockR / Yd.shockSum))
                            : ((Yd.wL = this.wheels.children[0]),
                              (Yd.wR = this.wheels.children[1]),
                              (Yd.d = Yd.wL.tPos.distanceTo(Yd.wR.tPos)),
                              (Yd.wL.collisionFactor += Yd.wL.shockPos + 0.25),
                              (Yd.wR.collisionFactor += Yd.wR.shockPos + 0.25),
                              (Yd.shockSum = Yd.wL.collisionFactor + Yd.wR.collisionFactor),
                              (Yd.shockRatio = 0 == Yd.shockSum ? 0.5 : Yd.wL.collisionFactor / Yd.shockSum),
                              (Yd.discrepency = Yd.d - Yd.wheelWidth),
                              (Yd.leftOffset = Yd.discrepency * (1 - Yd.shockRatio)),
                              Yd.axleFDir.subVectors(Yd.wR.tPos, Yd.wL.tPos).normalize(),
                              Yd.axleFPos.copy(Yd.axleFDir),
                              Yd.axleFPos.multiplyScalar(Yd.wheelWidth / 2 + Yd.leftOffset),
                              Yd.axleFPos.add(Yd.wL.tPos),
                              (Yd.wL = this.wheels.children[2]),
                              (Yd.wR = this.wheels.children[3]),
                              (Yd.d = Yd.wL.tPos.distanceTo(Yd.wR.tPos)),
                              (Yd.wL.collisionFactor += Yd.wL.shockPos + 0.25),
                              (Yd.wR.collisionFactor += Yd.wR.shockPos + 0.25),
                              (Yd.shockSum = Yd.wL.collisionFactor + Yd.wR.collisionFactor),
                              (Yd.shockRatio = 0 == Yd.shockSum ? 0.5 : Yd.wL.collisionFactor / Yd.shockSum),
                              (Yd.discrepency = Yd.d - Yd.wheelWidth),
                              (Yd.leftOffset = Yd.discrepency * (1 - Yd.shockRatio)),
                              Yd.axleRDir.subVectors(Yd.wR.tPos, Yd.wL.tPos).normalize(),
                              Yd.axleRPos.copy(Yd.axleRDir),
                              Yd.axleRPos.multiplyScalar(Yd.wheelWidth / 2 + Yd.leftOffset),
                              Yd.axleRPos.add(Yd.wL.tPos),
                              (Yd.shockF = this.wheels.children[0].collisionFactor + this.wheels.children[1].collisionFactor),
                              (Yd.shockR = this.wheels.children[2].collisionFactor + this.wheels.children[3].collisionFactor),
                              (Yd.shockSum = Yd.shockF + Yd.shockR),
                              (Yd.shockRatio = 0 == Yd.shockSum ? 0.5 : Yd.shockR / Yd.shockSum)),
                        (Yd.d = Yd.axleFPos.distanceTo(Yd.axleRPos)),
                        (Yd.discrepency = Yd.d - Yd.wheelLength),
                        (Yd.leftOffset = Yd.discrepency * (1 - Yd.shockRatio)),
                        Yd.chassisDir.subVectors(Yd.axleFPos, Yd.axleRPos).normalize(),
                        fe.position.copy(Yd.chassisDir),
                        fe.position.multiplyScalar(Yd.leftOffset),
                        fe.position.add(Yd.axleRPos),
                        fe.frontAxlePosition.copy(Yd.axleFPos),
                        (this.pOrientation = fe.heading),
                        (this.orientation.y = Ll(Yd.chassisDir.x, Yd.chassisDir.z)),
                        (Yd.deltaHeading = this.orientation.y - fe.heading),
                        Yd.deltaHeading > 3 ? (fe.heading += Zd) : Yd.deltaHeading < -3 && (fe.heading -= Zd),
                        (Yd.deltaHeading = this.orientation.y - fe.heading),
                        (fe.speedLerp = fe.speed / fe.metrics.topSpeed),
                        (Yd.turnSpeed = (this.orientation.y - fe.heading) / e),
                        (Yd.turnAccel = (Yd.turnSpeed - Yd.pTurnSpeed) / e),
                        (Yd.maxTurnAccel = 5 - 2 * fe.speedLerp),
                        this.didCollide || (Yd.turnAccel < -Yd.maxTurnAccel ? (Yd.turnSpeed = Yd.pTurnSpeed - Yd.maxTurnAccel * e) : Yd.turnAccel > Yd.maxTurnAccel && (Yd.turnSpeed = Yd.pTurnSpeed + Yd.maxTurnAccel * e)),
                        (this.orientation.y = fe.heading + Yd.turnSpeed * e),
                        (Yd.pTurnSpeed = Yd.turnSpeed),
                        this.orientation.y > Zd ? (this.orientation.y -= Zd) : this.orientation.y < -Zd && (this.orientation.y += Zd),
                        (fe.heading = this.orientation.y),
                        fe.fwd.set(Math.sin(fe.heading), -fe.pitch, Math.cos(fe.heading)).normalize(),
                        fe.position.y > 0
                            ? this.tVec
                                  .subVectors(fe.pPosition, fe.position)
                                  .normalize()
                                  .multiplyScalar(fe.metrics.drag * fe.speed * fe.speed * e * e)
                            : this.tVec
                                  .subVectors(fe.pPosition, fe.position)
                                  .normalize()
                                  .multiplyScalar(0.25 * fe.speed * fe.speed * e * e),
                        fe.position.add(this.tVec),
                        fe.bike
                            ? ((Yd.d1 = this.wheels.children[0].tPos.distanceTo(this.wheels.children[1].tPos)),
                              (Yd.r1 = Math.asin((this.wheelHeights[0] - this.wheelHeights[1]) / Yd.d1)),
                              (this.tiltX = -Yd.r1 || 0),
                              (this.tiltX = Math.max(Math.min(1.2, this.tiltX), -1.2)),
                              (this.sinTiltX = Math.sin(this.tiltX)),
                              (fe.pitch = this.tiltX),
                              (this.orientation.x = this.tiltX),
                              (Yd.r1 = Math.asin((this.groundHeights[0] - this.groundHeights[1]) / Yd.d1)),
                              (this.gradientX = -Yd.r1 || 0),
                              (Yd.vs = (fe.steer / (fe.metrics.maxSteer * this.softSteerFactor)) * Math.min(1, fe.speed / fe.metrics.topSpeed)),
                              (this.tiltZ = 1.25 * -Yd.vs),
                              (fe.slip = this.wheels.children[1].slip))
                            : ((Yd.d1 = this.wheels.children[0].tPos.distanceTo(this.wheels.children[2].tPos)),
                              (Yd.d2 = this.wheels.children[1].tPos.distanceTo(this.wheels.children[3].tPos)),
                              (Yd.r1 = Math.asin((this.wheelHeights[0] - this.wheelHeights[2]) / Yd.d1)),
                              (Yd.r2 = Math.asin((this.wheelHeights[1] - this.wheelHeights[3]) / Yd.d2)),
                              (Yd.tiltX = -(Yd.r1 + Yd.r2) / 2 || this.tiltX),
                              (Yd.tiltLerp = 3 * (1 + fe.speedLerp)),
                              Math.abs(Yd.tiltX - this.tiltX) / e < Yd.tiltLerp ? (this.tiltX = Yd.tiltX) : Yd.tiltX < this.tiltX ? (this.tiltX -= Yd.tiltLerp * e) : (this.tiltX += Yd.tiltLerp * e),
                              (this.tiltX = Math.max(Math.min(1.3, this.tiltX), -1.3)),
                              (this.sinTiltX = Math.sin(this.tiltX)),
                              (fe.pitch = this.tiltX),
                              (this.orientation.x = this.tiltX),
                              (Yd.r1 = Math.asin((this.groundHeights[0] - this.groundHeights[2]) / Yd.d1)),
                              (Yd.r2 = Math.asin((this.groundHeights[1] - this.groundHeights[3]) / Yd.d2)),
                              (this.gradientX = -(Yd.r1 + Yd.r2) / 2 || 0),
                              (Yd.d2 = Yd.wheelWidth * Math.cos(this.tiltX)),
                              (Yd.d1 = this.wheelHeights[1] - this.wheelHeights[0]),
                              (Yd.r1 = Math.asin(Yd.d1 / Yd.d2)),
                              (Yd.d1 = this.wheelHeights[3] - this.wheelHeights[2]),
                              (Yd.r2 = Math.asin(Yd.d1 / Yd.d2)),
                              (Yd.shockF = this.wheels.children[0].shockPos + this.wheels.children[1].shockPos),
                              (Yd.shockR = this.wheels.children[2].shockPos + this.wheels.children[3].shockPos),
                              (Yd.shockSum = Yd.shockF + Yd.shockR),
                              (Yd.shockRatio = 0 == Yd.shockSum ? 0.5 : Yd.shockF / Yd.shockSum),
                              (Yd.tiltZ = -(Yd.r1 * Yd.shockRatio + Yd.r2 * (1 - Yd.shockRatio)) || this.tiltZ),
                              Math.abs(Yd.tiltZ - this.tiltZ) / e < Yd.tiltLerp ? (this.tiltZ = Yd.tiltZ) : Yd.tiltZ < this.tiltZ ? (this.tiltZ -= Yd.tiltLerp * e) : (this.tiltZ += Yd.tiltLerp * e),
                              (fe.slip = (this.wheels.children[0].slip + this.wheels.children[1].slip + this.wheels.children[2].slip + this.wheels.children[3].slip) / 4)),
                        (fe.gradient = this.gradientX),
                        (this.tiltZ = Math.max(Math.min(1.3, this.tiltZ), -1.3)),
                        (this.orientation.z = this.tiltZ),
                        (fe.roll = this.tiltZ),
                        (this.sinTiltZ = Math.sin(this.tiltZ)),
                        this.tVec.set(0, -fe.wheels.radius, 0).applyEuler(this.orientation),
                        fe.position.add(this.tVec),
                        this.motionDir.copy(fe.position).sub(this.pPos).normalize(),
                        !this.didCollide && fe.direction > 0
                            ? ((Yd.trueHeading = Ll(this.motionDir.x, this.motionDir.z)),
                              Yd.trueHeading - fe.motionHeading > 3 ? (fe.motionHeading += Zd) : Yd.trueHeading - fe.motionHeading < -3 && (fe.motionHeading -= Zd),
                              (fe.motionHeading = 0 * fe.motionHeading + 1 * Ll(this.motionDir.x, this.motionDir.z)),
                              fe.speed < 5 && (fe.motionHeading = fe.motionHeading * (fe.speed / 5) + fe.heading * (1 - fe.speed / 5)))
                            : (fe.motionHeading = fe.heading),
                        this.pPos.copy(fe.position),
                        fe.setRotationFromEuler(this.orientation);
                    try {
                        fe.updateMatrix(), fe.updateMatrixWorld(), (this.didCrash = !1);
                    } catch (Au) {
                        if ((this.handleCrash(), this.didCrash)) throw ((Au.cause = "vehicle_matrix"), Au);
                        this.didCrash = !0;
                    }
                }
                handleCrash() {
                    this.resetToNode($t.vehicleNode);
                }
                updateWheelState(e) {
                    let t;
                    for (t of ((Yd.wheelCirc = this.vehicleDef.wheels.circumference),
                    (fe.downforce = Math.min(1, fe.speed / fe.metrics.topSpeed)),
                    (fe.downforce *= fe.downforce * fe.metrics.aeroFactor),
                    fe.bike
                        ? ((Yd.r = 0),
                          (Yd.r = (this.wheels.children[0].dS / Yd.wheelCirc) * 6.28 * this.wheels.children[0].direction),
                          (this.wheelEulers[0].z += Yd.r),
                          (this.wheelEulers[0].y = fe.steer * (1 - Math.sin(Math.abs(this.tiltZ))) + 1.57),
                          this.wheels.children[0].setRotationFromEuler(this.wheelEulers[0]),
                          fe.handbrake || ((Yd.r = (this.wheels.children[1].dS / Yd.wheelCirc) * 6.28 * this.wheels.children[1].direction), (this.wheels.children[1].rotation.x = this.wheels.children[1].rotation.x + Yd.r)))
                        : ((Yd.r = 0),
                          (Yd.r = (this.wheels.children[0].dS / Yd.wheelCirc) * 6.28 * this.wheels.children[0].direction),
                          (this.wheelEulers[0].z += Yd.r),
                          (this.wheelEulers[0].y = fe.steerL + 1.57),
                          this.wheels.children[0].setRotationFromEuler(this.wheelEulers[0]),
                          (Yd.r = (this.wheels.children[1].dS / Yd.wheelCirc) * 6.28 * this.wheels.children[1].direction),
                          (this.wheelEulers[1].z -= Yd.r),
                          (this.wheelEulers[1].y = fe.steerR - 1.57),
                          this.wheels.children[1].setRotationFromEuler(this.wheelEulers[1]),
                          fe.handbrake ||
                              ((Yd.r = (this.wheels.children[2].dS / Yd.wheelCirc) * 6.28 * this.wheels.children[2].direction),
                              (this.wheels.children[2].rotation.x = this.wheels.children[2].rotation.x + Yd.r),
                              (Yd.r = (this.wheels.children[3].dS / Yd.wheelCirc) * 6.28 * this.wheels.children[3].direction),
                              (this.wheels.children[3].rotation.x = this.wheels.children[3].rotation.x + Yd.r))),
                    (Yd.d = fe.wheels.radius),
                    (Yd.airborne = !1),
                    (Yd.grounded = !1),
                    this.didCollide || ((this.collisionStrength = 0), (this.collisionsDisabled = !1)),
                    (this.didCollide = !1),
                    (fe.onRoad = !1),
                    (this.wheelsInside = {}),
                    this.wheels.children))
                        this.updateWheelWorldPos(t),
                            (t.pHeight = t.groundHeight),
                            this.tVec.copy(t.worldPos).add(this.wheelDown),
                            (t.groundState.insideWall = t.insideWall),
                            (t.groundState.debug = 1 == t.i),
                            (Yd.ground = Sl.testGround(this.tVec, t.groundState)),
                            t.groundNorm.set(Yd.ground.n[0], Yd.ground.n[1], Yd.ground.n[2]),
                            (t.groundHeight = Yd.ground.h),
                            (t.friction = Yd.ground.f),
                            (t.onRoad = Yd.ground.r),
                            (fe.onRoad = fe.onRoad || t.onRoad),
                            (Yd.airborne = Yd.airborne || t.groundHeight < t.worldPos.y - 1),
                            (Yd.grounded = Yd.grounded || (t.onRoad && t.worldPos.y < t.groundHeight + 0.1)),
                            Yd.ground.w
                                ? ((t.wd = Yd.ground.wd),
                                  (t.wn = Yd.ground.wn),
                                  (t.ws = Yd.ground.ws),
                                  null == t.wi || t.wi != Yd.ground.wi
                                      ? ((t.wi = Yd.ground.wi),
                                        (t.insideWall = t.wd < 0),
                                        (t.mayCollide = !0),
                                        null == this.wheelsInside[Yd.ground.wi] && (this.wheelsInside[Yd.ground.wi] = t.insideWall),
                                        this.wheelsInside[t.wi] !== t.insideWall && (this.collideWallEnd(t), (this.didCollide = !0), (this.collisionSide = t.front ? 0 : 2), this.collisionPos.set(0, t.relPos.y, t.relPos.z)))
                                      : (null == this.wheelsInside[Yd.ground.wi] && (this.wheelsInside[Yd.ground.wi] = this.collisionsDisabled ? t.wd < 0 : t.insideWall),
                                        this.wheelsInside[t.wi] !== t.insideWall && (this.collideWallEnd(t), (this.didCollide = !0), (this.collisionSide = t.front ? 0 : 2), this.collisionPos.set(0, t.relPos.y, t.relPos.z)),
                                        this.collisionsDisabled
                                            ? this.wheelsInside[t.wi] !== t.wd < 0
                                                ? ((this.didCollide = !0), (this.collisionSide = Yd.ground.ws > 0 ? 3 : 1), this.collisionPos.copy(t.relPos))
                                                : (t.insideWall = t.wd < 0)
                                            : t.insideWall !== t.wd < 0
                                            ? (this.collideWallEdge(t), (this.didCollide = !0), (this.collisionSide = Yd.ground.ws > 0 ? 3 : 1), this.collisionPos.copy(t.relPos))
                                            : (t.insideWall = t.wd < 0)))
                                : ((t.wi = null), (t.insideWall = null)),
                            (Yd.shockDist = -(t.worldPos.y - t.groundHeight - Yd.d) + t.travel),
                            (t.shockFactor = Math.max(Yd.shockDist / (2 * t.travel), 0)),
                            (t.prevShockPos = t.shockPos),
                            (t.shockPos = t.shockFactor),
                            (t.shockExcess = 0),
                            t.shockPos > 1 && ((t.shockExcess = t.shockPos - 1), (t.shockExcess = Math.min(1, t.shockExcess)), (t.worldPos.y += t.shockExcess * t.travel * 2), (t.shockPos = 1)),
                            (t.dShockPos = t.shockPos - t.prevShockPos),
                            (t.position.y = t.radius + t.shockPos * t.travel * 2 - t.travel);
                    !nd.Reset || fe.onRoad || this.promptResetTimer
                        ? this.promptResetTimer && fe.onRoad && (rd.value == id.Reset && rd.set(id.None), clearTimeout(this.promptResetTimer), (this.promptResetTimer = null))
                        : (this.promptResetTimer = setTimeout(() => {
                              rd.set(id.Reset),
                                  setTimeout(() => {
                                      rd.value == id.Reset && rd.set(id.None);
                                  }, 15e3);
                          }, 5e3)),
                        !this.autodrive &&
                            nd.Boost &&
                            rd.value == id.None &&
                            fe.onRoad &&
                            fe.speed > 5 &&
                            this.tiltX < -0.11 &&
                            (rd.set(id.Boost),
                            setTimeout(() => {
                                ad("Boost");
                            }, [3e3])),
                        Yd.airborne && !Yd.grounded && (this.collisionsDisabled = !0),
                        fe.bike ? (fe.direction = this.wheels.children[1].direction) : (fe.direction = Math.min(this.wheels.children[2].direction, this.wheels.children[3].direction)),
                        t.speed < 0.5 && (fe.direction = 0),
                        fe.steeringWheel &&
                            (this.autodrive
                                ? (fe.steeringWheel.rotation.x = 0.95 * fe.steeringWheel.rotation.x + Pe.value.steerRotation * Hd * (-fe.steer / fe.metrics.maxSteer) * 0.05)
                                : (fe.steeringWheel.rotation.x = Pe.value.steerRotation * Hd * (-fe.steer / fe.metrics.maxSteer)));
                }
                collideTerrain(e, t) {
                    fe.bike, (e.collisionFactor = 10), (this.wheelHeights[e.i] = e.tPos.y), (this.collisionStrength = 0);
                }
                collideWallEnd(e) {
                    this.collisionsDisabled ||
                        (this.tVec.copy(e.tPos),
                        e.tPos.copy(e.pPos),
                        e.pPos.copy(this.tVec),
                        fe.bike || (this.tVec.copy(e.vel), (this.tVec.y = 0), e.tPos.add(this.tVec.multiplyScalar(-0.8))),
                        (e.collisionFactor = 10),
                        (this.wheelHeights[e.i] = e.tPos.y),
                        (this.collisionStrength = fe.speed / 10));
                }
                collideWallEdge(e, t = 1) {
                    this.collisionsDisabled ||
                        (this.tVec.set(e.wn.x, 0.01, e.wn.z),
                        e.tPos.add(this.tVec.multiplyScalar(e.wd * e.ws)),
                        (this.collTemp = (e.velDir.x * -e.wn.z + e.velDir.z * e.wn.x) * Math.abs(e.wd) * 0.75),
                        this.tVec.set(-e.wn.z, 0, e.wn.x).multiplyScalar(this.collTemp),
                        e.tPos.sub(this.tVec),
                        (e.collisionFactor = 10),
                        (this.collisionStrength = Math.max(this.collisionStrength, Math.abs(this.collTemp / this.pdT))),
                        (this.wheelHeights[e.i] = e.tPos.y));
                }
                updateVehicleNode() {
                    if ($t.vehicleNode.next) {
                        if ($t.vehicleNode.i < this.targetVehicleNodeIndex)
                            return (fe.wrongWay = !1), rd.value == id.UTurn && rd.set(id.None), ($t.vehicleNode = $t.vehicleNode.next), ($t.vehicleIndex = $t.vehicleNode.i), ($t.vehicleIndexDidChange = !0), void td.nodeDidChange();
                        (Yd.d1 = fe.position.distanceToSquared($t.vehicleNode.p)),
                            (Yd.d2 = fe.position.distanceToSquared($t.vehicleNode.next.next.p)),
                            Yd.d2 > 14400
                                ? (this.nodeCheckFrame--,
                                  this.nodeCheckFrame <= 0 &&
                                      ((this.nodeCheckFrame = 60),
                                      (Yd.closest = Kt(fe.position.x, fe.position.z, $t.vehicleNode, !0)),
                                      Yd.closest.n.i > $t.vehicleNode.i && (this.targetVehicleNodeIndex = Yd.closest.n.i),
                                      Hl.value.edge || Sl.testFarGrid(fe.position.x, fe.position.z) || (Hl.set("edge", !0), Uh.sendUpdate("achievment", "edge"))))
                                : Yd.d2 < Yd.d1
                                ? ((fe.wrongWay = !1),
                                  (rd.value != id.UTurn && rd.value != id.Reverse) || rd.set(id.None),
                                  ($t.vehicleNode = $t.vehicleNode.next),
                                  ($t.vehicleIndex = $t.vehicleNode.i),
                                  ($t.vehicleIndexDidChange = !0),
                                  td.nodeDidChange())
                                : Yd.d1 > 400 && fe.onRoad
                                ? (fe.wrongWay ||
                                      ((Yd.transformedNodeAngle = (2.5 * Math.PI - $t.vehicleNode.a) % (2 * Math.PI)),
                                      (Yd.angleDif = Math.abs(fe.heading - Yd.transformedNodeAngle)),
                                      Yd.angleDif > 2 && Yd.angleDif < 4.3 && (Uh.sendUpdate("wrongWay"), (fe.wrongWay = !0), rd.set(id.UTurn))),
                                  !fe.wrongWay && fe.direction < 0 && ((fe.reversingTooFar = !0), rd.set(id.Reverse)))
                                : fe.wrongWay
                                ? ((Yd.transformedNodeAngle = (2.5 * Math.PI - $t.vehicleNode.a) % (2 * Math.PI)),
                                  (Yd.angleDif = Math.abs(fe.heading - Yd.transformedNodeAngle)),
                                  (Yd.angleDif < 1.4 || Yd.angleDif > 4.9) && ((fe.wrongWay = !1), rd.value == id.UTurn && rd.set(id.None)))
                                : fe.reversingTooFar && ((fe.reversingTooFar = !1), rd.value == id.Reverse && rd.set(id.None)),
                            (zh.dist = 10 * ($t.vehicleNode.i - $t.initIndex + Ih.accumulatedProgress)),
                            this.analytics.rawDS > this.nextUpdateDistance &&
                                ((this.nextUpdateDistance = this.analytics.rawDS + this.nextUpdateIncrement),
                                this.nextUpdateIncrement < this.maxUpdateIncrement && (this.nextUpdateIncrement = Math.min(this.maxUpdateIncrement, 2 * this.nextUpdateIncrement)),
                                (this.nextAnalyticsUpdate.distance = zh.dist),
                                (this.nextAnalyticsUpdate.rawDistance = this.analytics.rawDS),
                                (this.nextAnalyticsUpdate.speed = zh.speed),
                                Uh.sendUpdate("vehicleController", this.nextAnalyticsUpdate),
                                (this.nextAnalyticsUpdate = {}));
                    }
                }
                handleInput(e) {
                    (this.hasBoost = this.hasBoost && (this.hasAccel || this.hasCruiseTarget)),
                        (this.inputs.accel = 0),
                        (this.inputs.drive = 0),
                        Y.signal.Autodrive && ce.set(!this.autodrive),
                        Y.signal.Headlights && fe.setHeadlights(!fe.headlights, !0),
                        Y.signal.Reset && (this.resetToNode($t.vehicleNode), nd.Reset && ad("Reset"), this.analytics.resetCount++, Uh.sendUpdate("resetCount", this.analytics.resetCount), (this.holdHandbrake = !this.hasCruiseTarget)),
                        this.autodrive
                            ? (this.autoDriver.update(e),
                              (this.inputs.accel = this.autoDriver.inputs.accel),
                              (this.inputs.steer = this.autoDriver.inputs.steer),
                              (this.hasCruiseTarget || this.hasSpeedLimit) &&
                                  (fe.speed > Wl.value.speed && ((this.inputs.accel = 0), fe.speed > Wl.value.speed + 1 && (this.autoDriver.inputs.brake = Math.max(this.autoDriver.inputs.brake, fe.speed / Wl.value.speed - 1))),
                                  (this.inputs.accel = Math.min(fe.metrics.accel, (Wl.value.speed - fe.speed) / e)),
                                  0 == Wl.value.speed ? ((this.inputs.accel = 0), (this.autoDriver.inputs.brake = 1)) : fe.handbrake && (fe.handbrake = !1)),
                              this.autoDriver.inputs.brake > 0 ? (fe.braking || (fe.brakeLerp = 0), (fe.braking = !0), (Qd.redlight.emissiveIntensity = 0.5)) : ((fe.braking = !1), (Qd.redlight.emissiveIntensity = 0)),
                              Y.controllerSignal.Forward || Y.controllerSignal.Backward || Y.signal.Forward || Y.signal.Backward || Y.signal.Left || Y.signal.Right ? this.canCancelAutodrive && ce.set(!1) : (this.canCancelAutodrive = !0),
                              (fe.steer = this.inputs.steer))
                            : ((this.hasBoost = !1),
                              (this.isDriven = !1),
                              Y.signal.Forward &&
                                  ((this.hasBoost = !!Y.signal.Boost),
                                  (this.isDriven = !0),
                                  this.useMouse && !this.hasCruiseTarget && (this.hasBoost = !1),
                                  nd.Boost && this.hasBoost && ad("Boost"),
                                  (this.hasAccel = !0),
                                  (this.lastAccel = oe.appTime),
                                  !this.hasBoost && fe.direction < 0 ? this.setBrake(!0, Y.signal.Forward) : (this.setBrake(!1), (this.inputs.accel = Y.signal.Forward * fe.metrics.accel)),
                                  (this.holdHandbrake = !1)),
                              Y.signal.Backward &&
                                  ((this.hasAccel = !1),
                                  (this.isDriven = !0),
                                  fe.direction > 0 ? this.setBrake(!0, Y.signal.Backward) : (this.setBrake(!1), (this.inputs.accel = Y.signal.Backward * -fe.metrics.accel)),
                                  (this.holdHandbrake = !1)),
                              this.isDriven || ((this.hasAccel = !1), this.setBrake(!1)),
                              (this.inputs.stickySteer = Y.signal.StickySteer > 0 ? 1 : 0),
                              this.inputs.stickySteer && Y.signal.Handbrake && !this.inputs.handbrake && (this.holdHandbrake = !0),
                              (this.inputs.handbrake = Y.signal.Handbrake > 0),
                              (fe.handbrake = this.inputs.handbrake || this.holdHandbrake),
                              !this.hasCruiseTarget ||
                                  this.autodrive ||
                                  fe.braking ||
                                  fe.handbrake ||
                                  (0 != this.inputs.accel && !this.useMouse) ||
                                  ((this.inputs.accel = Math.min(fe.metrics.accel, Math.max(-fe.metrics.reverse, (Wl.value.speed - fe.direction * fe.speed) / e))), this.useMouse && this.hasBoost && (this.inputs.accel = fe.metrics.accel)),
                              this.hasSpeedLimit && ((this.hasAccel = this.inputs.accel > 0), (this.inputs.accel = Math.max(-fe.metrics.accel, Math.min(this.inputs.accel, (Wl.value.speed - fe.speed) / e)))),
                              this.hasBoost
                                  ? (this.inputs.accel += fe.metrics.accel * Math.max(0, 1 - fe.speed / fe.metrics.topSpeed))
                                  : this.inputs.accel > 0 && fe.speed < 27 && (this.inputs.accel += fe.metrics.accel * Math.max(0, 0.5 * (1 - fe.speed / 27))),
                              0 == D.value
                                  ? (A.softSteer ? this.smoothKeySteerSoft(e) : this.smoothKeySteerQuick(e), (fe.steer = this.inputs.steer))
                                  : (this.smoothKeySteerQuick(e), this.smoothControllerSteer(e), (fe.steer = Math.max(Math.min(Yd.maxSteer, this.inputs.steer + this.inputs.controllerSteer), -Yd.maxSteer)))),
                        fe.updateSteer(),
                        this.getDriveState(e),
                        (fe.hasBoost = this.hasBoost),
                        0 != f.scrollDelta && Wl.value.enabled && null == f.scrollLock && (f.scrollDelta < 0 ? Wl.inc5() : Wl.dec5()),
                        this.inputDisabled || (f.scrollDelta = 0);
                }
                checkAutodriveProgress() {}
                resetToNode(e) {
                    let t = e.a - e.next.da / 2;
                    this.setPose(e.p.x, e.p.y, e.p.z, Math.PI / 2 - t, !0), (this.inputs.accel = 0), (this.inputs.steer = 0), (this.inputs.brake = 0), (this.inputs.handbrake = 0), (this.inputs.stickySteer = 0), (this.hasBoost = !1);
                    let i = 0;
                    for (let s of this.wheels.children)
                        (s.shockPos = 0.5),
                            (s.groundHeight = 0),
                            s.vel.set(0, 0, 0),
                            s.velDir.set(0, 0, 0),
                            s.acc.set(0, 0, 0),
                            (s.dSus = 0),
                            (s.pSus = 0),
                            (s.dS = 0),
                            s.tPos.set(0, 0, 0),
                            (s.prevShockPos = 0.5),
                            (s.insideWall = !0),
                            s.i % 2 == 0 ? s.rotation.set(0, Math.PI / 2, 0) : s.rotation.set(0, -Math.PI / 2, 0),
                            (s.collisionFactor = 0),
                            (s.wd = 0),
                            (this.wheelHeights[i] = 0),
                            i++,
                            this.updateWheelWorldPos(s),
                            s.pPos.copy(s.worldPos);
                    i = 0;
                    for (let s of this.wheelEulers) i % 2 == 0 ? s.set(0, Math.PI / 2, 0) : s.set(0, -Math.PI / 2, 0);
                    this.pPos.copy(fe.position),
                        (fe.pitch = this.orientation.x),
                        fe.reset(),
                        rd.value == id.UTurn && rd.set(id.None),
                        (zh.speed = fe.speed),
                        (Yd.turnSpeed = 0),
                        (Yd.pTurnSpeed = 0),
                        (this.targetHeading = 0),
                        (this.update = this.updateStationed),
                        td.pause(),
                        (this.tiltX = this.orientation.x),
                        (this.sinTiltX = Math.sin(this.tiltX)),
                        (this.tiltZ = this.orientation.z),
                        (this.sinTiltZ = Math.sin(this.tiltZ)),
                        (this.dS = 0),
                        (this.didCollide = !1),
                        (this.collisionSide = 0),
                        (this.collisionsDisabled = !1),
                        this.updateUI(),
                        ($t.vehicleNode = e),
                        ($t.vehicleIndex = e.i),
                        ($t.vehicleIndexDidChange = !0),
                        (this.targetVehicleNodeIndex = $t.vehicleIndex),
                        this.motionDir.set(0, 0, 1),
                        this.steerOrientation.copy(this.orientation),
                        this.autoDriver.reset(),
                        this.useMouse && (this.dom.mousePrompt.style.display = "block"),
                        this.audio.reset();
                }
                getDriveState(e) {
                    this.inputs.accel > 0
                        ? fe.drive < this.inputs.accel
                            ? ((fe.drive += fe.metrics.jerk * e), fe.drive > this.inputs.accel && (fe.drive = this.inputs.accel))
                            : (fe.drive = this.inputs.accel)
                        : fe.drive > this.inputs.accel
                        ? ((fe.drive -= fe.metrics.jerk * e), fe.drive < this.inputs.accel && (fe.drive = this.inputs.accel))
                        : (fe.drive = this.inputs.accel);
                }
                smootherLerp(e) {
                    return (e * (6 * e - 15) + 10) * e * e * e;
                }
                smoothLerp(e) {
                    return (3 - 2 * e) * e * e;
                }
                halfLerp(e) {
                    return 2 * ((3 - 2 * (e = e / 2 + 0.5)) * e * e - 0.5);
                }
                smoothKeySteerSoft(e) {
                    if (
                        ((Yd.maxSteer = fe.metrics.maxSteer),
                        (this.softSteerFactor = 1 - fe.speedLerp * Vl.steerSpeedFactor),
                        fe.bike
                            ? ((this.softTurnInterval = fe.metrics.steerInterval), (this.softSteerTimeFactor = 1 + fe.speedLerp * fe.speedLerp))
                            : ((this.softTurnInterval = fe.metrics.steerInterval),
                              (this.softSteerTimeFactor = 1 + 0.5 * fe.speedLerp),
                              fe.slip > 0 &&
                                  !Y.signal.StickySteer &&
                                  ((this.softSlip = 1 - fe.slip),
                                  (this.softSlip *= this.softSlip),
                                  (this.softSlipB = Math.max(0.5, this.softSlip)),
                                  (this.softSteerTimeFactor *= this.softSlipB),
                                  (this.softSteerFactor = 1 - fe.speedLerp * Vl.steerSpeedFactor * this.softSlipB))),
                        (Yd.maxSteer *= this.softSteerFactor),
                        (Yd.steerInput = Y.signal.Left - Y.signal.Right),
                        (Yd.steerDir = Yd.steerInput < 0 ? -1 : 1),
                        (Yd.steerTarget = Yd.steerInput * Yd.maxSteer),
                        Y.signal.StickySteer)
                    )
                        return (
                            this.softStiff || (this.softStiff = !0),
                            0 == Yd.steerInput
                                ? ((Y.signal.Left = 0), (Y.signal.Right = 0), void (this.softTurning = !1))
                                : ((Yd.stickySpeed = 0),
                                  this.softTurning ? this.softTimer < 0.15 && ((this.softTimer += e), this.softTimer > 0.15 && (this.softTimer = 0.15)) : ((this.softTimer = e), (this.softTurning = !0)),
                                  (Yd.stickySpeed = this.softTimer * (A.lockedSteerSpeed / 0.15)),
                                  fe.bike ? (this.inputs.steer += Yd.steerInput * e * this.softSteerFactor * Yd.stickySpeed * 0.5) : (this.inputs.steer += Yd.steerInput * e * this.softSteerFactor * Yd.stickySpeed),
                                  void (this.inputs.steer > 0 ? (this.inputs.steer = Math.min(Yd.maxSteer, this.inputs.steer)) : (this.inputs.steer = Math.max(-Yd.maxSteer, this.inputs.steer))))
                        );
                    this.softStiff && ((this.softStiff = !1), (this.softTimer = 0), (this.softStartPoint = fe.steer)),
                        0 != Yd.steerInput
                            ? (this.softTurning && this.softTurningDir == Yd.steerInput) ||
                              ((this.softTimer = 0),
                              (this.softStartPoint = fe.steer),
                              (this.softInterval = this.softTurnInterval / (Math.abs(Yd.steerTarget - fe.steer) / Yd.maxSteer) / A.steerSpeed),
                              fe.bike && Math.abs(Yd.steerTarget - fe.steer) > Yd.maxSteer && (this.softInterval *= 1 - fe.speedLerp / 2),
                              (this.softTurning = !0),
                              (this.softTurningDir = Yd.steerInput < 0 ? -1 : 1))
                            : this.softTurning &&
                              ((this.softTurning = !1),
                              fe.bike
                                  ? (this.softInterval = this.softTurnInterval * Math.abs(fe.steer / (Yd.maxSteer * A.recenterSpeed)))
                                  : (this.softInterval = this.softSlipB * this.softTurnInterval * Math.abs(fe.steer / (Yd.maxSteer * A.recenterSpeed))),
                              (this.softTimer = 0),
                              (this.softStartPoint = fe.steer),
                              (this.softTurningDir = 0)),
                        (this.softTimer += e / this.softSteerTimeFactor),
                        (this.softLerp = Math.min(1, this.softTimer / this.softInterval)),
                        (this.softLerp = this.halfLerp(this.softLerp)),
                        (this.softSteerOutput = this.softStartPoint * (1 - this.softLerp) + Yd.steerTarget * this.softLerp),
                        (this.inputs.steer = this.softSteerOutput);
                }
                smoothControllerSteer(e) {
                    if (((Yd.contSteer = Y.controllerSignal.Left - Y.controllerSignal.Right), (Yd.steerLimiter = 1 - fe.speedLerp * Vl.steerSpeedFactor * Yd.slipFactor), 1 == D.value)) {
                        (Yd.maxSteer = fe.metrics.maxSteer * Yd.steerLimiter * m.steerRange), (Yd.contSmoothing = 1 - m.steerSmoothing), (Yd.a = 0.02 + Yd.contSmoothing * Yd.contSmoothing * Yd.contSmoothing * 0.98);
                        let e = Yd.contSteer * m.linearity + Yd.contSteer * Yd.contSteer * (1 - m.linearity);
                        Yd.contSteer < 0 && (e = Yd.contSteer * m.linearity - Yd.contSteer * Yd.contSteer * (1 - m.linearity)), (Yd.contSteer = e * Yd.maxSteer);
                    } else {
                        (Yd.maxSteer = fe.metrics.maxSteer * Yd.steerLimiter * P.steerRange), (Yd.contSmoothing = 1 - P.steerSmoothing), (Yd.a = 0.02 + Yd.contSmoothing * Yd.contSmoothing * Yd.contSmoothing * 0.98);
                        let e = Yd.contSteer * P.linearity + Yd.contSteer * Yd.contSteer * (1 - P.linearity);
                        Yd.contSteer < 0 && (e = Yd.contSteer * P.linearity - Yd.contSteer * Yd.contSteer * (1 - P.linearity)), (Yd.contSteer = e * Yd.maxSteer);
                    }
                    (Yd.a = Math.min(1, Yd.a)), (Yd.nextSteer = this.inputs.controllerSteer * (1 - Yd.a) + Yd.contSteer * Yd.a), (this.inputs.controllerSteer = Yd.nextSteer);
                }
                smoothKeySteerQuick(e) {
                    if (
                        ((Yd.slipFactor = 1),
                        fe.slip > 0 && !Y.signal.StickySteer && (Yd.slipFactor = Math.max(0.5, (1 - fe.slip) * (1 - fe.slip))),
                        (Yd.steerLimiter = 1 - fe.speedLerp * Vl.steerSpeedFactor * Yd.slipFactor),
                        (Yd.maxSteer = fe.metrics.maxSteer * Yd.steerLimiter),
                        Y.signal.StickySteer)
                    )
                        return (
                            (Yd.steerInput = Y.signal.Left - Y.signal.Right),
                            0 == Yd.steerInput
                                ? ((Y.signal.Left = 0), (Y.signal.Right = 0), void (this.stickyTurning = !1))
                                : ((Yd.stickySpeed = 0),
                                  this.stickyTurning ? this.stickyTimer < 0.15 && ((this.stickyTimer += e), this.stickyTimer > 0.15 && (this.stickyTimer = 0.15)) : ((this.stickyTimer = e), (this.stickyTurning = !0)),
                                  (Yd.stickySpeed = this.stickyTimer * (A.lockedSteerSpeed / 0.15)),
                                  fe.bike ? (this.inputs.steer += Yd.steerInput * e * this.softSteerFactor * Yd.stickySpeed * 0.5) : (this.inputs.steer += Yd.steerInput * e * this.softSteerFactor * Yd.stickySpeed),
                                  void (this.inputs.steer > 0 ? (this.inputs.steer = Math.min(Yd.maxSteer, this.inputs.steer)) : (this.inputs.steer = Math.max(-Yd.maxSteer, this.inputs.steer))))
                        );
                    (Yd.steerInput = Y.signal.Left - Y.signal.Right),
                        (Yd.steerDir = Yd.steerInput < 0 ? -1 : 1),
                        (Yd.steerTarget = Yd.steerInput * Yd.maxSteer),
                        (Yd.steerTemper = Math.max(fe.slip, Yd.maxSteer - Math.abs(this.inputs.steer) / Yd.maxSteer)),
                        ((Yd.steerDir < 0 && this.inputs.steer > 0) || (Yd.steerDir > 0 && this.inputs.steer < 0)) && (Yd.steerTemper = 1),
                        (Yd.a = ((10 * e) / fe.metrics.steerInterval / Yd.slipFactor) * A.steerSpeed * Yd.steerTemper),
                        0 == Yd.steerInput && (Yd.a = ((10 * e) / fe.metrics.steerInterval / Yd.slipFactor) * A.recenterSpeed),
                        (Yd.a = Math.min(1, Yd.a)),
                        (this.inputs.steer = this.inputs.steer * (1 - Yd.a) + Yd.steerTarget * Yd.a);
                }
            };
            const Ud = {},
                Xd = (e, t) => {
                    if (isNaN(t)) console.warn("Attempting to set nan config value for ", e);
                    else {
                        window.localStorage.setItem(qd[e], t), (Kd[e] = t);
                        for (let i of Ud[e] || []) i(t);
                    }
                },
                Jd = { UseAckermann: !0, AudioLevel: 1, Units: 0 },
                qd = {},
                Kd = { UseAckermann: Jd.UseAckermann, AudioLevel: Jd.AudioLevel, Units: Jd.Units };
            for (let yu in Kd) {
                let e;
                qd[yu] = "config-" + yu;
                try {
                    e = JSON.parse(window.localStorage.getItem(qd[yu]));
                } catch (Au) {
                    console.warn("JSON Parsing exception"), console.warn(Au), Xd(yu, Jd[yu]), (e = Jd[yu]);
                }
                Kd[yu] = null === e ? Jd[yu] : e;
            }
            var _d = Kd;
            new (class {
                constructor() {
                    (this.setBound = this.set.bind(this)), (this.ls = window.localStorage), this.loadConfig();
                }
                loadConfig() {
                    let e;
                    for (let t in _d) (e = this.get(t)), (_d[t] = null == e ? Jd[t] : e);
                }
                get(e) {
                    return JSON.parse(this.ls.getItem("config-" + e));
                }
                set(e, t) {
                    console.log("Set config '" + e + "' to " + t), (_d[e] = t), window.localStorage.setItem("config-" + e, t);
                }
            })();
            const $d = "no_prompt_fps";
            var ec = new (class extends l {
                constructor(...e) {
                    super(...e),
                        (this.default = !1),
                        (this.value = !1),
                        (this.disabled = null != window.localStorage.getItem($d) || null != window.localStorage.getItem("analytics_didChangeQuality") || Ih.value.viewLodIndex * Ih.value.detailLodIndex == 0);
                }
                disable() {
                    (this.disabled = !0), window.localStorage.setItem($d, !0);
                }
            })();
            var tc = new (class {
                constructor() {
                    (this.domStats = {}),
                        (this.active = !1),
                        (this.initialised = !1),
                        (this.showCamPos = !1),
                        (this.updateBound = this.update.bind(this)),
                        f.addListener(V.Debug, this.toggleActive.bind(this)),
                        f.addListener(V.Debug2, () => {
                            this.showCamPos = !this.showCamPos;
                        });
                }
                setStats(e) {
                    (this.stats = e), document.body.appendChild(this.stats.dom), (this.stats.dom.style.display = "none");
                }
                init() {
                    (this.dom = document.getElementById("ui-debug")),
                        (this.domPos = document.getElementById("ui-debug-position")),
                        (this.domFarCoords = document.getElementById("ui-debug-far-coords")),
                        (this.domNode = document.getElementById("ui-debug-node")),
                        (this.domTail = document.getElementById("ui-debug-midline-tail"));
                    for (let e in en) {
                        let t = document.createElement("div");
                        t.className = "ui-debug-row";
                        let i = document.createElement("div");
                        (i.className = "ui-debug-label"), (i.innerHTML = e + ":"), t.appendChild(i);
                        let s = document.createElement("div");
                        (s.className = "ui-debug-value"), (s.innerHTML = en[e]), t.appendChild(s), this.dom.appendChild(t), (this.domStats[e] = s);
                    }
                    this.initialised = !0;
                }
                toggleActive() {
                    this.initialised || this.init(),
                        this.stats &&
                            ((this.active = !this.active),
                            this.active
                                ? (oe.addListener(this.updateBound), (this.dom.style.display = "flex"), (this.stats.dom.style.display = "block"))
                                : (oe.removeListener(this.updateBound), (this.dom.style.display = "none"), (this.stats.dom.style.display = "none")));
                }
                update() {
                    let e, t, i;
                    this.showCamPos
                        ? Hs.parent
                            ? ((e = Hs.parent.position.x), (t = Hs.parent.position.y), (i = Hs.parent.position.z))
                            : ((e = Hs.position.x), (t = Hs.position.y), (i = Hs.position.z))
                        : ((e = fe.position.x), (t = fe.position.y), (i = fe.position.z)),
                        (this.domPos.innerHTML = Math.floor(e) + "x " + Math.floor(t) + "y " + Math.floor(i) + "z");
                    let s,
                        n,
                        a = e / At,
                        o = i / At;
                    (s = Math.floor((a - Math.floor(a)) * yt)),
                        (n = Math.floor((o - Math.floor(o)) * yt)),
                        (a = Math.floor(a)),
                        (o = Math.floor(o)),
                        (this.domFarCoords.innerHTML = s + ", " + n + " @ " + a + ", " + o),
                        (this.domNode.innerHTML = $t.vehicleNode.i),
                        (this.domTail.innerHTML = $t.tail.i);
                    for (let r in this.domStats) this.domStats[r].innerHTML = en[r];
                }
            })();
            var ic = class {
                    constructor(e, t, i, s) {
                        (this.screenSize = new r.V()),
                            (this.renderScale = 1),
                            (this.onError = () => {}),
                            (this.onLoadProgress = () => {}),
                            (this.loadStages = []),
                            (this.isCineCam = !1),
                            (this.loadLoopBound = this.loadLoop.bind(this)),
                            (this.maxLoadLoops = 1e3),
                            (this.loadLoopCount = 0),
                            (this.loadInactivityTimer = 0),
                            (this.prevLoadProg = 0),
                            (this.fineLoadProgress = 0),
                            (this.initialised = !1),
                            (this.midlineDidReset = !0),
                            (this.onLoadedBound = this.onLoaded.bind(this)),
                            (this.firstFrame = !0),
                            (this.basicPromptInterval = null),
                            (this.onAudioInitBound = this.onAudioInit.bind(this)),
                            (this.onTickerStateBound = this.onTickerState.bind(this)),
                            (this.lights = {}),
                            (this.fpsTracker = 0),
                            (this.statsTimer = 0),
                            (this.updateBound = this.update.bind(this)),
                            (this.physDT = 0),
                            (this.maxPhysDT = 0.02),
                            (this.minPhysDT = 0.001),
                            (this.checkNoGPU = 0),
                            (this.lowFPSWaiter = 0),
                            (this.canvas = e),
                            (this.onError = i),
                            (this.onLoadProgress = s),
                            (this.stats = new h.a()),
                            (this.stats.dom.style.left = ""),
                            (this.stats.dom.style.right = "0"),
                            (this.pauseDom = document.getElementById("game-paused")),
                            this.initScene(e),
                            oe.addStateListener(this.onTickerStateBound),
                            f.init(t),
                            f.addListener(V.NodeDebug, () => console.log($t.vehicleNode)),
                            Y.addListener("Mute", () => {
                                ue.toggleMute();
                            }),
                            Y.addListener("ToggleCinecam", () => this.toggleCamera()),
                            Y.addListener("NextScene", () => {
                                Sl.nextSkin();
                            }),
                            Y.addListener("PrevScene", () => {
                                Sl.prevSkin();
                            }),
                            Ih.addListener("seed", () => {
                                Uh.recordSeed(Ih.value.seed), this.regenerateAll();
                            }),
                            Ih.addListener("sceneName", () => {
                                this.regenerateAll();
                            }),
                            Ih.addListener("topography", () => {
                                this.regenerateTopography();
                            }),
                            Ih.addListener("viewLodIndex", () => {
                                this.regenerateViewDist();
                            }),
                            Ih.addListener("detailLodIndex", this.regenerateDetail.bind(this)),
                            Ih.addListener("renderScale", (e) => {
                                (this.renderScale = fh[e]), Uh.sendUpdate("renderScale", e), this.setSize(this.screenSize.x, this.screenSize.y);
                            }),
                            (this.renderScale = fh[Ih.value.renderScale]),
                            f.lockKeys(),
                            fe.addListener(me, this.onVehicleChanged.bind(this)),
                            this.generate();
                    }
                    pregenerate() {
                        d.set(!0),
                            Uh.sendUpdate("sceneConfigChange", { ...Ih.value, initNode: Ih.initialNode, accumProg: Ih.accumulatedProgress }),
                            Ih.loadProgress(),
                            f.lockKeys(),
                            this.vehicleController.suspend(),
                            oe.removeListener(this.updateBound),
                            (this.midlineDidReset = !0),
                            (this.loadProgress = 0),
                            (this.loadStages.length = 0),
                            this.onLoadProgress(0);
                    }
                    regenerateAll() {
                        this.pregenerate(), (this.scene.fog = dt()), this.generate();
                    }
                    regenerateSeed() {}
                    regenerateTopography() {
                        this.pregenerate(),
                            this.loadStages.push({ name: "topography", setup: Sl.topographyLoaderInit, loader: Sl.topographyLoader, portion: 0.25, frameIterations: 50 }),
                            this.loadStages.push({ name: "scene", setup: Sl.sceneLoaderInit, loader: Sl.sceneLoader, portion: 0.1, frameIterations: 1 }),
                            this.loadStages.push({ name: "farGrid", setup: Sl.farGridReset, loader: Sl.farGridLoader, portion: 0.35, frameIterations: 10 }),
                            this.loadStages.push({ name: "nearGrid", setup: Sl.nearGridReset, loader: Sl.nearGridLoader, portion: 0.28, frameIterations: 10 }),
                            this.loadStages.push({ name: "finalise", setup: () => {}, loader: Sl.postGridLoader, portion: 0.02, frameIterations: 10 }),
                            (this.loadStage = this.loadStages[0]),
                            this.loadStage.setup(),
                            oe.addListener(this.loadLoopBound);
                    }
                    regenerateViewDist() {
                        Sl.updateConfig(), this.camController.updateViewDist(), this.regenerateAll();
                    }
                    regenerateDetail() {
                        Sl.updateConfig(), this.regenerateAll();
                        let e = 512 * (Ih.value.detailLodIndex + 1);
                        (wt.shadow.mapSize.width = e), (wt.shadow.mapSize.height = e), wt.shadow.map.dispose(), (wt.shadow.map = null);
                    }
                    generate() {
                        (this.loadProgress = 0),
                            (this.midlineDidReset = !0),
                            this.loadStages.push({ name: "topography", setup: Sl.topographyLoaderInit, loader: Sl.topographyLoader, portion: 0.25, frameIterations: 50 }),
                            this.loadStages.push({ name: "scene", setup: Sl.sceneLoaderInit, loader: Sl.sceneLoader, portion: 0.1, frameIterations: 1 }),
                            this.loadStages.push({ name: "farGrid", setup: Sl.farGridLoaderInit, loader: Sl.farGridLoader, portion: 0.35, frameIterations: 10 }),
                            this.loadStages.push({ name: "nearGrid", setup: Sl.nearGridLoaderInit, loader: Sl.nearGridLoader, portion: 0.28, frameIterations: 10 }),
                            this.loadStages.push({ name: "finalise", setup: () => {}, loader: Sl.postGridLoader, portion: 0.02, frameIterations: 10 }),
                            (this.loadStage = this.loadStages[0]),
                            this.loadStage.setup(),
                            oe.addListener(this.loadLoopBound);
                    }
                    loadLoop(e) {
                        try {
                            let t,
                                i = 1e3 * e,
                                s = Date.now() + i;
                            for (this.fineLoadProgress = 0, t = 0; t < this.maxLoadLoops && ((this.fineLoadProgress = this.loadStage.loader()), !(this.fineLoadProgress >= 1 || Date.now() >= s)); t++);
                            if (this.fineLoadProgress >= 1) {
                                let e = this.loadStages.shift();
                                if (((this.loadProgress += e.portion), console.log("Loaded " + e.name + "..."), 0 == this.loadStages.length))
                                    return console.log("Loading complete"), oe.removeListener(this.loadLoopBound), void this.onLoaded();
                                (this.loadStage = this.loadStages[0]), this.loadStage.setup(), (this.fineLoadProgress = this.loadProgress), this.onLoadProgress(this.loadProgress);
                            } else (this.fineLoadProgress = this.loadProgress + this.loadStages[0].portion * this.fineLoadProgress), this.onLoadProgress(this.fineLoadProgress);
                            if (this.prevLoadProg >= this.fineLoadProgress) {
                                if (((this.loadInactivityTimer += e), this.loadInactivityTimer > 3)) {
                                    if ((Uh.sendFeedback("LOAD ERROR: Stuck at progress ", this.loadProgress), !Nh.NewPlayer)) return this.onError("LOAD ERROR: Stuck at progress ", this.loadProgress), void oe.retire();
                                    Ze(null, !0);
                                }
                            } else this.loadInactivityTimer = 0;
                            (this.prevLoadProg = this.fineLoadProgress), (this.loadLoopCount = 0), this.render(), this.stats.update();
                        } catch (Au) {
                            return console.error(Au), this.onError(Au.stack.toString()), Uh.sendFeedback("LOAD ERROR: " + Au.stack.toString()), void oe.retire();
                        }
                    }
                    onLoaded() {
                        this.initialised
                            ? (this.vehicleController.reload(this.midlineDidReset), f.unlockKeys())
                            : (this.initVehicle(),
                              window.addEventListener("keydown", this.onAudioInitBound),
                              window.addEventListener("mousedown", this.onAudioInitBound),
                              tc.setStats(this.stats),
                              td.init(),
                              Y.initialise(),
                              (this.initialised = !0)),
                            this.camController.updateViewDist(),
                            d.set(!1),
                            this.onLoadProgress(1),
                            this.beginRender();
                    }
                    awaitVehicleMotion() {
                        fe.speed > 1 && (rd.set(id.None), clearInterval(this.basicPromptInterval));
                    }
                    beginGame() {
                        var e, t;
                        (e = kh),
                            (t = !0),
                            localStorage.setItem(e, t),
                            rd.value !== id.None && (this.basicPromptInterval = setInterval(this.awaitVehicleMotion.bind(this), 3e3)),
                            f.unlockKeys(),
                            this.canvas.focus(),
                            Uh.initialiseAnalytics();
                    }
                    resetVehicle() {
                        this.vehicleController.resetToNode($t.vehicleNode);
                    }
                    onAudioInit() {
                        ue.init(), window.removeEventListener("keydown", this.onAudioInitBound), window.removeEventListener("mousedown", this.onAudioInitBound);
                    }
                    onTickerState(e) {
                        this.pauseDom.style.display = e ? "block" : "none";
                    }
                    initRenderer(e = !0, t = !0) {
                        (this.renderer = new r.X({ canvas: this.canvas, antialias: e, powerPreference: "high-performance", stencil: !1, logarithmicDepthBuffer: t })),
                            console.log("Device pixel ratio: ", window.devicePixelRatio),
                            this.renderer.setPixelRatio(Math.min(1, window.devicePixelRatio)),
                            this.renderer.setClearColor(16777215, 1),
                            console.log("Antialias, logdepth ", e, t),
                            (this.renderer.shadowMap.enabled = !0);
                    }
                    initScene(e) {
                        (this.scene = Xh),
                            (this.scene.background = bt),
                            (this.scene.fog = dt()),
                            (this.renderer = new r.X({ canvas: this.canvas, antialias: Ih.value.antialias, powerPreference: "high-performance", stencil: !1, logarithmicDepthBuffer: !1 })),
                            console.log("Device pixel ratio: ", window.devicePixelRatio),
                            this.renderer.setPixelRatio(Math.min(1, window.devicePixelRatio)),
                            this.renderer.setClearColor(16777215, 1),
                            (this.renderer.shadowMap.enabled = !0),
                            (this.lights.ambient = vt),
                            this.scene.add(this.lights.ambient);
                        let t = ft;
                        t.position.set(0, 1, 0), (this.lights.hemi = t), this.scene.add(this.lights.hemi);
                        let i = wt;
                        i.position.set(0, 10, 0),
                            (i.castShadow = !0),
                            (i.shadow.radius = 2),
                            (i.shadow.camera.left = -4),
                            (i.shadow.camera.right = 4),
                            (i.shadow.camera.top = 4),
                            (i.shadow.camera.bottom = -4),
                            i.shadow.camera.updateProjectionMatrix();
                        let s = 512 * (Ih.value.detailLodIndex + 1);
                        (i.shadow.mapSize.width = s),
                            (i.shadow.mapSize.height = s),
                            (i.shadow.camera.near = 0.5),
                            (i.shadow.camera.far = 300),
                            (i.target = fe),
                            (this.lights.dir = i),
                            this.scene.add(this.lights.dir),
                            this.toggleCamera(),
                            this.scene.add(Sl.container),
                            this.scene.add(fe),
                            this.setSize(e.offsetWidth, e.offsetHeight),
                            this.render();
                    }
                    toggleCamera() {
                        this.camController &&
                            (this.camController.destroy(), this.camController.camContainer && this.scene.remove(this.camController.camContainer), (this.isCineCam = !this.isCineCam), (this.vehicleController.inputDisabled = this.isCineCam)),
                            this.isCineCam ? ((this.camController = new Ol(this.onViewChange.bind(this), this.canvas)), this.scene.add(this.camController.camContainer)) : (this.camController = new Cl(this.onViewChange.bind(this)));
                    }
                    initVehicle() {
                        (this.vehicleController = new Vd()), this.onVehicleChanged();
                    }
                    onVehicleChanged() {
                        let e = this.lights.dir.shadow.camera,
                            t = fe.metrics.shadowMapSize;
                        (e.left = -t), (e.right = t), (e.top = t), (e.bottom = -t), e.updateProjectionMatrix();
                    }
                    destroy() {
                        for (this.camController.destroy(), this.vehicleController.destroy(), this.bikeController.destroy(), oe.removeListener(this.updateBound); this.scene.children.length; )
                            console.log("Removing scene children"), this.scene.remove(this.scene.children[0]);
                        for (; this.canvas.lastChild; ) this.canvas.removeChild(this.canvas.lastChild);
                        this.renderer.clear();
                    }
                    render() {
                        this.renderer.render(this.scene, this.camController.camera);
                    }
                    beginRender() {
                        fe.headlights || (fe.setHeadlights(!0), (fe.lightsContainer.position.y -= 100), this.update(oe.dT, oe.appTime), fe.setHeadlights(!1), (fe.lightsContainer.position.y += 100)), oe.addListener(this.updateBound);
                    }
                    update(e, t) {
                        ne.disabled || (t < 20 && e > 0.07 ? ((this.checkNoGPU += 1), this.checkNoGPU > 10 && (ne.set(!0), ne.disable())) : this.checkNoGPU > 0 && (this.checkNoGPU -= 1));
                        try {
                            if (((this.physDT += e), Y.update(e), this.physDT > this.maxPhysDT))
                                for (this.vehicleController.update(this.maxPhysDT, t), this.physDT -= this.maxPhysDT; this.physDT > this.maxPhysDT; ) this.vehicleController.update(this.maxPhysDT, t), (this.physDT -= this.maxPhysDT);
                            this.physDT > this.minPhysDT && (this.vehicleController.update(this.physDT), (this.physDT = 0)), this.camController.update(e), Sl.update(e, t);
                        } catch (Au) {
                            return console.error(Au), this.onError(Au.stack.toString()), Uh.sendFeedback("UPDATE ERROR IN " + Au.cause + ": " + Au.stack.toString()), void oe.retire();
                        }
                        this.render(), this.stats.update(), (en["draw-calls"] = this.renderer.info.render.calls), this.fpsTracker++, (this.statsTimer += e), this.statsTimer >= 5 && this.updateStats();
                    }
                    updateStats() {
                        (this.curFPS = this.fpsTracker / this.statsTimer),
                            (this.fpsTracker = 0),
                            (this.statsTimer = 0),
                            this.lowFPSWaiter > 3 && this.curFPS < 45 && this.curFPS > 15 && !ec.disabled && (this.curFPS < 20 && ne.set(!0), ec.set(!0), ec.disable()),
                            this.lowFPSWaiter++,
                            Uh.sendUpdate("stats", { fps: this.curFPS, drawCalls: this.renderer.info.render.calls, playTime: 1e3 * oe.playTime });
                    }
                    onViewChange() {}
                    setSize(e, t) {
                        this.screenSize.set(e, t), this.renderer.setSize(e * this.renderScale, t * this.renderScale), this.camController.setSize(e, t), f.setSize(e, t), this.render();
                    }
                },
                sc = (i(17), i.p + "static/media/warning.2f7f711f.svg"),
                nc = i.p + "static/media/u_turn.38a08a9e.svg",
                ac = i.p + "static/media/arrow_up.fdd3dd06.svg",
                oc = (i(48), i.p + "static/media/no_mobile_1.959d982f.svg"),
                rc = i.p + "static/media/anslo_ico.77ddc9f9.svg",
                hc = i.p + "static/media/splash-logo-placeholder-7b.2d60164d.png",
                lc = i(0);
            const dc = [
                    { q: "Why does it run so poorly/like a slideshow?", a: "Check that your browser application is running with hardware acceleration enabled - both in the browser settings and your GPU settings" },
                    {
                        q: "What's different about this driving game?",
                        a:
                            "The custom environment generation engine has been carefully designed for expansive, true-to-life scenery stretching endlessly into the horizon without repetition. With an entirely procedurally generated world, players can easily swap between different locations, seasons, and weathers to suit their mood. And, being browser-based, accessing the game couldn't be easier; one click and you're off.",
                    },
                    {
                        q: "How does the environment generation engine work?",
                        a:
                            "The full write-up is still in the works (see above), but in short: a heightmap is generated with a custom algorithm similar to perlin noise, and the road's midline is traced through that heightmap using simple rules on gradient and curvature. The environment is rendered in chunks of different resolutions based on how close to the road's midline they will appear. Add in a lot of dynamic geometry management, textures, and basic vehicle physics, and you have Slow Roads.",
                    },
                    {
                        q: "Why a JavaScript browser game, and not a conventional engine?",
                        a:
                            "Browser games have a massive benefit of broad compatibility and ease of access; as long as you have a modern browser, simply load up the web page and start playing in one click - no installs or logins needed. Further, writing browser games in pure JavaScript, rather than building them from an engine such as Unity, allows for more powerful control over optimisation, which is critical for a demanding game such as this. Beyond that... breaking convention and proving novel capabilities can be a rewarding challenge in itself.",
                    },
                    {
                        q: "Why electric vehicles?",
                        a:
                            "EVs work well in this context for a few reasons: they're quieter and more peaceful; they're simpler and more intuitive to gamify (no gears or RPM concerns); the physics and audio is easier to code; and they're the future - combustion engines are quickly becoming old fashioned. That said, I'm open to adding more vehicle types, including manual transmission, in future.",
                    },
                    {
                        q: "Will you make it open source?",
                        a:
                            "Probably not anytime soon, but I'm not against it in principle. The codebase has always been \"experimental\", and as such unreadable to anyone but me, so probably of limited value right now. If there's interest, I may isolate and open source interesting subsystems like the routing algorithm, or expose an interface for graphics mods.",
                    },
                    {
                        q: "Can I copy/modify your game for my own business or personal use?",
                        a: Object(lc.jsxs)(lc.Fragment, {
                            children: [
                                "No, thank you - this is my personal project and I don't want to invite derivative works, nor do I want others to abuse my work for their own profit. I have applied a ",
                                Object(lc.jsx)("a", { className: "about-link", href: "http://creativecommons.org/licenses/by-nc-nd/4.0/", children: "CC BY-ND-NC 4.0 license" }),
                                " for that reason. If you wish to host an unmodified version, you're in your rights to do that provided you credit me and don't alter the game nor monetise it in any way (e.g. with surrounding adverts). My preference would be that you don't embed it at all, however; my work is currently presented exactly how I want it to be presented, and I would like to retain control over that.",
                            ],
                        }),
                    },
                    {
                        q: "Why can I drive through trees and signs?",
                        a:
                            "Off-road object collisions might be a useful \"threat\" for discouraging shortcuts in a competitive context, but if you're just here to chill they would only add insult to injury. Ignoring off-road object collisions is also a huge saving on physics processing, so altogether it's a reasonable tradeoff.",
                    },
                    {
                        q: "Why is driving off-road so broken? No shadows, sinking into the ground, missing geometry, etc.",
                        a:
                            "Off-road driving isn't an intended gameplay element, so it isn't really supported; rather, I decided there's no reason to prohibit it. The engine is optimised for going one direction and following the road only, so don't be surprised if it \"looks broken\" should you choose to ignore that.",
                    },
                    {
                        q: "Will you support mobile/controllers/wheels?",
                        a: "Controllers yes, but achieving good performance on mobiles might be difficult, and is something I still need to explore. Support for controllers and wheels is planned in the next few weeks.",
                    },
                    {
                        q: "How much will it cost?",
                        a: Object(lc.jsxs)(lc.Fragment, {
                            children: [
                                "Nothing! And no ads, either... enjoy this as a respite from run-away capitalism. However, keeping the game online relies upon kind ",
                                Object(lc.jsx)("a", { className: "about-link", href: "https://ko-fi.com/slowroads", children: "donations" }),
                                ", so anything you might be able to contribute would go a long way to supporting it.",
                            ],
                        }),
                    },
                    { q: "Slow roads? More like Fast Roads!", a: 'The idea of a "slow road" is about taking the longer scenic route instead of the highway, not about how fast you drive.' },
                    {
                        q: "Will you offer a downloadable/Steam version?",
                        a: "I'm considering a Steam release with extra features in the future, though it's not certain. However, if I don't go that route, it should be possible to offer a free download of the web version.",
                    },
                    {
                        q: "Can you add X feature/Y vehicle model/make it more like [insert AAA game here]?",
                        a:
                            "Probably not - the browser is a somewhat limited platform, so advanced features and lots of content isn't a realistic goal. I would also like to maintain the casual, minimal design of the game, and not make it too similar to existing racing games; they already offer all the hardcore features I can't.",
                    },
                    {
                        q: "I'm a developer/artist/musician, can I contribute my work to the game?",
                        a: "I'm not accepting content from others, sorry; this is still a personal project for me, and a portfolio piece, so involving work from others defeats the purpose. But thanks for the interest!",
                    },
                ],
                cc = [
                    { title: "1. Project overview (tl;dr for all sections)", link: "https://anslo.medium.com/slow-roads-tl-dr-a664ac6bce40" },
                    { title: "2. Generating realistic environment heightmaps (...Soon!)" },
                    { title: "3. Pathing a route through the environment" },
                    { title: "4. Rendering seamless, dynamically-generated environment geometry" },
                    { title: "5. Graphics and shading" },
                    { title: "6. Cheap vehicle physics" },
                    { title: "7. Optimisation strategies" },
                    { title: "8. UX approach" },
                    { title: "9. Testing and analytics" },
                    { title: "10. Project Retrospective" },
                ],
                pc = ({ title: e, link: t }) =>
                    t
                        ? Object(lc.jsxs)(lc.Fragment, { children: [Object(lc.jsx)("a", { className: "about-link splash-blog-link", href: t, target: "_blank", rel: "noopener noreferrer", children: e }), Object(lc.jsx)("hr", {})] })
                        : Object(lc.jsxs)(lc.Fragment, { children: [Object(lc.jsx)("div", { className: "splash-blog-missing", children: e }), Object(lc.jsx)("hr", {})] }),
                uc = ({ q: e, a: t }) => {
                    const [i, n] = Object(s.useState)(!1);
                    return Object(lc.jsxs)("div", {
                        className: "faq-qa",
                        children: [
                            Object(lc.jsxs)("div", {
                                className: "faq-q",
                                onMouseDown: (e) => {
                                    n(!i), e.preventDefault();
                                },
                                children: [Object(lc.jsx)("div", { children: e }), Object(lc.jsx)("div", { style: { paddingLeft: "12px" }, children: i ? "-" : "+" })],
                            }),
                            i && Object(lc.jsx)("div", { className: "faq-a", children: t }),
                        ],
                    });
                },
                gc = () =>
                    Object(lc.jsxs)("div", {
                        id: "splash-changelog",
                        children: [
                            "New Version: ",
                            Object(lc.jsx)("strong", { children: $s }),
                            Object(lc.jsx)("br", {}),
                            Object(lc.jsx)("ul", { children: qs.map((e) => Object(lc.jsx)("li", { className: "splash-version-change", children: e })) }),
                            Object(lc.jsxs)("div", {
                                id: "splash-feedback-prompt",
                                children: ["Please use the feedback form to let me know what you think, or ", Object(lc.jsx)("a", { href: "https://discord.gg/TNf9bBrZmR", children: "join the discord" }), " and tell me personally!"],
                            }),
                            Object(lc.jsx)("hr", { style: { borderColor: "#fff", opacity: 0.1 } }),
                            Object(lc.jsxs)("div", {
                                className: "splash-version-footer",
                                children: [
                                    "Next update target: ",
                                    Ks.targetDate,
                                    Object(lc.jsx)("br", {}),
                                    Object(lc.jsx)("ul", { children: Ks.changes.map((e, t) => Object(lc.jsx)("li", { className: "splash-version-change", children: e }, "ch" + t)) }),
                                ],
                            }),
                        ],
                    }),
                mc = ({ loadProgress: e, gameHasBegun: t, onBegin: i }) =>
                    Object(lc.jsx)("div", {
                        id: "splash-loader",
                        className: "splash-ready",
                        onClick: (e) => {
                            e.preventDefault(), i();
                        },
                        children: t ? "return" : "begin",
                    }),
                xc = () =>
                    Object(lc.jsxs)("div", {
                        className: "splash-notsupported",
                        children: [
                            Object(lc.jsx)("img", { className: "splash-notsupported-icon", src: oc, alt: "" }),
                            Object(lc.jsx)("br", {}),
                            "Apologies, this project is not yet properly supported on mobile devices.",
                            Object(lc.jsx)("br", {}),
                            Object(lc.jsx)("br", {}),
                            "If you're not on a mobile device, please disregard this message and click below to force a reload.",
                            Object(lc.jsx)("br", {}),
                            Object(lc.jsx)("br", {}),
                            Object(lc.jsx)("div", {
                                className: "splash-reload",
                                onMouseDown: () => {
                                    window.localStorage.setItem("force-allow-mobile", !0), window.location.reload();
                                },
                                children: "I have a keyboard",
                            }),
                        ],
                    });
            var vc = ({ onClose: e, supported: t, gameHasBegun: i, loadProgress: n }) => {
                    const [a, o] = Object(s.useState)(Lh.value);
                    return (
                        Object(s.useEffect)(
                            () => (
                                Lh.addListener(o),
                                () => {
                                    Lh.removeListener(o);
                                }
                            ),
                            [o]
                        ),
                        Object(lc.jsxs)("div", {
                            id: "splash-container",
                            children: [
                                Js && Object(lc.jsx)(gc, {}),
                                Object(lc.jsx)("div", { id: "home-bg" }),
                                Object(lc.jsxs)("div", {
                                    id: "home",
                                    children: [
                                        t &&
                                            Object(lc.jsxs)(lc.Fragment, {
                                                children: [
                                                    Object(lc.jsxs)("div", { id: "splash-version", children: [Object(lc.jsx)("span", { id: "splash-player-count" }), "v", $s] }),
                                                    Object(lc.jsxs)("a", {
                                                        id: "splash-anslo",
                                                        href: "https://twitter.com/anslogen",
                                                        target: "_blank",
                                                        rel: "noopener noreferrer",
                                                        children: [Object(lc.jsx)("img", { src: rc, id: "splash-anslo-img", alt: "" }), Object(lc.jsx)("div", { children: "from anslo.dev \xa9 2022" })],
                                                    }),
                                                    Object(lc.jsxs)("div", {
                                                        id: "splash-license",
                                                        children: [
                                                            "This work is licensed under a ",
                                                            Object(lc.jsx)("a", { rel: "license", className: "splash-link", href: "http://creativecommons.org/licenses/by-nc-nd/4.0/", children: "CC BY-NC-ND 4.0 International License" }),
                                                        ],
                                                    }),
                                                ],
                                            }),
                                        Object(lc.jsx)("div", { id: "splash-logo-placeholder" }),
                                        Object(lc.jsx)("img", { id: "splash-logo", src: hc, alt: "" }),
                                        Object(lc.jsx)("div", { id: "splash-header", children: "slow roads" }),
                                        Object(lc.jsx)("div", { id: "splash-subheader", children: "endless driving zen" }),
                                        t ? Object(lc.jsx)(mc, { loadProgress: n, gameHasBegun: i, onBegin: e }) : Object(lc.jsx)(xc, {}),
                                        Object(lc.jsxs)("a", { id: "splash-about", href: "#about", children: ["about", Object(lc.jsx)("br", {}), "\u25be"] }),
                                        t &&
                                            Object(lc.jsxs)("div", {
                                                id: "splash-footer",
                                                children: [
                                                    Object(lc.jsx)("div", {
                                                        className: "splash-footer-link",
                                                        children: Object(lc.jsxs)("a", {
                                                            href: "https://ko-fi.com/slowroads",
                                                            target: "_blank",
                                                            rel: "noopener noreferrer",
                                                            children: ["donate", Object(lc.jsx)("span", { className: "outlink" })],
                                                        }),
                                                    }),
                                                    Object(lc.jsx)("div", {
                                                        className: "splash-footer-link",
                                                        children: Object(lc.jsxs)("a", { className: "splash-link", href: "https://discord.gg/TNf9bBrZmR", children: ["discord", Object(lc.jsx)("span", { className: "outlink" })] }),
                                                    }),
                                                ],
                                            }),
                                    ],
                                }),
                                Object(lc.jsxs)("div", {
                                    id: "about",
                                    children: [
                                        Object(lc.jsxs)("a", { id: "splash-top", href: "#home", children: ["\u25b4", Object(lc.jsx)("br", {}), "back up"] }),
                                        Object(lc.jsxs)("div", {
                                            id: "about-wrapper",
                                            children: [
                                                Object(lc.jsx)("div", {
                                                    className: "about-content",
                                                    style: { marginBottom: "80px" },
                                                    children: Object(lc.jsxs)("div", {
                                                        className: "splash-about",
                                                        children: [
                                                            Object(lc.jsx)("strong", { children: "Slow Roads" }),
                                                            " is a casual, procedurally-generated driving game which lets you disconnect from life for a while and run endlessly toward the distant horizon. Set the scenery to suit your mood, throw on some music, and",
                                                            Object(lc.jsx)("br", {}),
                                                            Object(lc.jsx)("strong", { children: "just drive" }),
                                                            ".",
                                                        ],
                                                    }),
                                                }),
                                                Object(lc.jsx)("div", { className: "splash-topo-divider", children: Object(lc.jsx)("div", { className: "splash-topo-header", children: "Background" }) }),
                                                Object(lc.jsxs)("div", {
                                                    className: "about-content",
                                                    children: [
                                                        Object(lc.jsxs)("div", {
                                                            className: "splash-nav",
                                                            children: [
                                                                Object(lc.jsx)("a", { className: "splash-nav-item", href: "#background", children: "background" }),
                                                                Object(lc.jsx)("a", { className: "splash-nav-item", href: "#development", children: "development plan" }),
                                                                Object(lc.jsx)("a", { className: "splash-nav-item", href: "#blog", children: "technical blog" }),
                                                                Object(lc.jsx)("a", { className: "splash-nav-item", href: "#faq", children: "faq" }),
                                                                Object(lc.jsx)("a", { className: "splash-nav-item", href: "#archive", children: "attributions" }),
                                                            ],
                                                        }),
                                                        Object(lc.jsxs)("div", {
                                                            className: "splash-about-text",
                                                            children: [
                                                                "My name is ",
                                                                Object(lc.jsx)("a", { className: "about-link", href: "https://anslo.dev", children: "anslo" }),
                                                                " and I'm a creative developer exploring in the space between design and computer science. With a background in software engineering and a life-long love of functional art, my projects focus on finding novel applications of digital technology in answering interesting design questions.",
                                                                Object(lc.jsx)("br", {}),
                                                                Object(lc.jsx)("br", {}),
                                                                "Slow Roads exists primarily as an exploration of procedural scenery generation, but also as an experiment testing the boundaries of 3D application development within JavaScript. As a game, this project is a nostalgic love letter to the rolling hills of the Peak District, and to the arcade rally games I would play for hours on end as a child. As a technical demo, I aim to set a high bar and redress the negative idea of what can be accomplished in the browser.",
                                                                Object(lc.jsx)("br", {}),
                                                                Object(lc.jsx)("br", {}),
                                                                "Aside from this, my hope is that those in need of a simple, soothing escape will find it here.",
                                                            ],
                                                        }),
                                                    ],
                                                }),
                                                Object(lc.jsx)("div", { className: "splash-topo-divider", children: Object(lc.jsx)("div", { className: "splash-topo-header", children: "Development Plan" }) }),
                                                Object(lc.jsx)("div", {
                                                    className: "about-content",
                                                    children: Object(lc.jsxs)("div", {
                                                        className: "splash-about-text",
                                                        children: [
                                                            "I currently plan to continue full-time development until the end of January in order to add the most popular feature requests and fix the most critical bugs. Beyond this I hope to continue expanding the experience part-time while I work on other projects.",
                                                            Object(lc.jsx)("br", {}),
                                                            Object(lc.jsx)("br", {}),
                                                            Object(lc.jsx)("div", { className: "splash-about-title", children: "Upcoming Release - v1.2.0 (~31st January):" }),
                                                            Object(lc.jsx)("br", {}),
                                                            Object(lc.jsxs)("div", {
                                                                style: { marginLeft: "16px" },
                                                                children: [
                                                                    "- New location (TBD) ",
                                                                    Object(lc.jsx)("br", {}),
                                                                    "- Improved environmental detail and effects ",
                                                                    Object(lc.jsx)("br", {}),
                                                                    "- Revamped control panel with extra settings for physics/audio ",
                                                                    Object(lc.jsx)("br", {}),
                                                                    "- Improved vehicle models (including first-person) ",
                                                                    Object(lc.jsx)("br", {}),
                                                                    "- Improved autodrive, including a lane-follow option ",
                                                                    Object(lc.jsx)("br", {}),
                                                                    "- Mouse-look when in autodrive/key-control ",
                                                                    Object(lc.jsx)("br", {}),
                                                                    "- Further bug fixes to minimise generation errors and resolve audio issues ",
                                                                    Object(lc.jsx)("br", {}),
                                                                ],
                                                            }),
                                                            Object(lc.jsx)("br", {}),
                                                            Object(lc.jsx)("br", {}),
                                                            "Beyond this, Slow Roads will likely return to being a side-project for me, though development will continue incrementally.",
                                                            Object(lc.jsx)("br", {}),
                                                            Object(lc.jsx)("br", {}),
                                                            Object(lc.jsx)("div", { className: "splash-about-title", children: "Planned Future Features:" }),
                                                            Object(lc.jsx)("br", {}),
                                                            Object(lc.jsxs)("div", {
                                                                style: { marginLeft: "16px" },
                                                                children: [
                                                                    "- More locations with more environmental detail",
                                                                    Object(lc.jsx)("br", {}),
                                                                    '- "Profile" UI for viewing progress and past seeds',
                                                                    Object(lc.jsx)("br", {}),
                                                                    "- Continued stability upgrades ",
                                                                    Object(lc.jsx)("br", {}),
                                                                    "- An offline build, either self-hosted or via Steam",
                                                                    Object(lc.jsx)("br", {}),
                                                                    "- Possibly open-sourcing the code",
                                                                    Object(lc.jsx)("br", {}),
                                                                ],
                                                            }),
                                                            Object(lc.jsx)("br", {}),
                                                            "Find the full plan of work on my ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://public.zenkit.com/c/VRrOoJJR08/slow-roads?v=AB7dI0FTBJ", children: "ZenKit board" }),
                                                            ".",
                                                            Object(lc.jsx)("br", {}),
                                                            "Join the ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://discord.gg/TNf9bBrZmR", children: "discord server" }),
                                                            " to discuss new ideas.",
                                                            Object(lc.jsx)("br", {}),
                                                            "Supporters on ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://ko-fi.com/slowroads", children: "ko-fi" }),
                                                            " get early access and priority requests!",
                                                            Object(lc.jsx)("br", {}),
                                                        ],
                                                    }),
                                                }),
                                                Object(lc.jsx)("div", { className: "splash-topo-divider", children: Object(lc.jsx)("div", { className: "splash-topo-header", children: "Technical Blog" }) }),
                                                Object(lc.jsx)("div", {
                                                    className: "about-content",
                                                    children: Object(lc.jsxs)("div", {
                                                        className: "splash-about-text",
                                                        children: [
                                                            "While I have no immediate plans to make the source code public, over the next few weeks I will be writing blog posts diving into each of the main components. If you're curious, please follow me on ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://twitter.com/anslogen", children: "Twitter" }),
                                                            " or ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://anslo.medium.com/", children: "Medium" }),
                                                            " to be notified of new posts.",
                                                            Object(lc.jsx)("br", {}),
                                                            Object(lc.jsx)("br", {}),
                                                            Object(lc.jsx)("div", { className: "splash-about-blog-list", children: cc.map((e, t) => Object(lc.jsx)(pc, { title: e.title, link: e.link }, t)) }),
                                                        ],
                                                    }),
                                                }),
                                                Object(lc.jsx)("div", { className: "splash-topo-divider", children: Object(lc.jsx)("div", { className: "splash-topo-header", children: "FAQ" }) }),
                                                Object(lc.jsx)("div", {
                                                    className: "about-content",
                                                    children: Object(lc.jsx)("div", { className: "splash-about-text", children: dc.map((e, t) => Object(lc.jsx)(uc, { q: e.q, a: e.a }, t)) }),
                                                }),
                                                Object(lc.jsx)("div", { className: "splash-topo-divider", children: Object(lc.jsx)("div", { className: "splash-topo-header", children: "Attributions" }) }),
                                                Object(lc.jsx)("div", {
                                                    className: "about-content",
                                                    children: Object(lc.jsxs)("div", {
                                                        className: "splash-about-text",
                                                        children: [
                                                            "Rendering library - ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://threejs.org/", children: "three.js" }),
                                                            Object(lc.jsx)("br", {}),
                                                            "Off-world textures - ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://mars.nasa.gov/mars2020/multimedia/raw-images/", children: "Nasa Perseverance" }),
                                                            Object(lc.jsx)("br", {}),
                                                            "Brake audio - ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://freesound.org/people/Hencocor/sounds/407406/", children: "Hencocor on freesound.org" }),
                                                            Object(lc.jsx)("br", {}),
                                                            "Ambient audio - ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://freesound.org/people/InspectorJ/sounds/401543/", children: "InspectorJ on freesound.org" }),
                                                            Object(lc.jsx)("br", {}),
                                                            "Tyre audio - ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://freesound.org/people/fractanimal/sounds/614627/", children: "fractanimal on freesound.org" }),
                                                            Object(lc.jsx)("br", {}),
                                                            "Gravel audio - ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://freesound.org/people/seth-m/sounds/341069/", children: "seth-m on freesound.org" }),
                                                            Object(lc.jsx)("br", {}),
                                                            "Boost audio - ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://freesound.org/people/YleArkisto/sounds/342892/", children: "YleArkisto on freesound.org" }),
                                                            Object(lc.jsx)("br", {}),
                                                            "Suspension audio - ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://freesound.org/people/ingudios/sounds/119468/", children: "ingudios on freesound.org" }),
                                                            Object(lc.jsx)("br", {}),
                                                            "Collision sounds - ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://freesound.org/people/jakobthiesen/sounds/174836/", children: "jakobthiesen on freesound.org" }),
                                                            Object(lc.jsx)("br", {}),
                                                            "Collision sounds - ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://freesound.org/people/jakobthiesen/sounds/174837/", children: "jakobthiesen on freesound.org" }),
                                                            Object(lc.jsx)("br", {}),
                                                            "Collision sounds - ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://freesound.org/people/SubwaySandwitch420/sounds/538947/", children: "SubwaySandwitch420 on freesound.org" }),
                                                            Object(lc.jsx)("br", {}),
                                                            "Barrier scrape sound - ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://freesound.org/people/eyenorth/sounds/464846/", children: "eyenorth on freesound.org" }),
                                                            Object(lc.jsx)("br", {}),
                                                            "Misc sound effects - ",
                                                            Object(lc.jsx)("a", { className: "about-link", href: "https://freesound.org/people/HECKFRICKER/sounds/625312/", children: "HECKFRICKER on freesound.org" }),
                                                            Object(lc.jsx)("br", {}),
                                                        ],
                                                    }),
                                                }),
                                            ],
                                        }),
                                        null == a
                                            ? Object(lc.jsx)("div", { id: "splash-distance", className: "splash-footer", children: "thank you for playing" })
                                            : Object(lc.jsxs)("div", { id: "splash-distance", className: "splash-footer", children: ["thank you for over ", Math.floor(a / 1e3), " kilometres travelled"] }),
                                    ],
                                }),
                            ],
                        })
                    );
                },
                fc = (i(50), i.p + "static/media/lock_open.2037b97e.svg"),
                wc = i.p + "static/media/lock_closed.2c30efba.svg",
                bc = i.p + "static/media/refresh.56c65653.svg",
                Ac = i.p + "static/media/handbrake.9ce9ad46.svg";
            const yc = ["mph", "kmph"],
                Ic = ["miles", "km"],
                Sc = [0.44704, 0.277778],
                Mc = [60 * Sc[0], 100 * Sc[1]],
                Dc = ({ conversion: e, cruiseDefault: t }) => {
                    const [i, n] = Object(s.useState)(Wl.value.enabled),
                        [a, o] = Object(s.useState)(Wl.value.speed),
                        [r, h] = Object(s.useState)(Wl.value.control),
                        [l, d] = Object(s.useState)(!1),
                        [c, p] = Object(s.useState)(!1);
                    return (
                        Object(s.useEffect)(
                            () => (
                                Wl.addListener("control", h),
                                Wl.addListener("enabled", n),
                                Wl.addListener("speed", o),
                                () => {
                                    Wl.removeListener("control", h), Wl.removeListener("enabled", n), Wl.removeListener("speed", h);
                                }
                            ),
                            [h, n, o]
                        ),
                        Object(lc.jsxs)("div", {
                            id: "ui-cruise-controls",
                            onMouseEnter: () => d(!0),
                            onMouseLeave: () => d(!1),
                            children: [
                                Object(lc.jsx)("img", {
                                    id: "ui-cruise-toggle",
                                    title: "Toggle speed control",
                                    alt: "",
                                    src: i ? wc : fc,
                                    onMouseDown: () => {
                                        Wl.set("enabled", !i);
                                    },
                                    onMouseEnter: () => p(!0),
                                    onMouseLeave: () => p(!1),
                                }),
                                i &&
                                    Object(lc.jsxs)("div", {
                                        id: "ui-cruise-select",
                                        children: [
                                            Object(lc.jsx)("div", {
                                                className: "ui-cruise-arrow",
                                                onMouseDown: () => {
                                                    Wl.inc5();
                                                },
                                                children: "\u25b4",
                                            }),
                                            Object(lc.jsx)("div", { id: "ui-cruise-value", children: Math.round(a / e) }),
                                            Object(lc.jsx)("div", {
                                                className: "ui-cruise-arrow",
                                                onMouseDown: () => {
                                                    Wl.dec5();
                                                },
                                                children: "\u25be",
                                            }),
                                        ],
                                    }),
                                i &&
                                    l &&
                                    Object(lc.jsxs)("div", {
                                        style: { marginLeft: "2vh" },
                                        id: "ui-cruise-select",
                                        children: [
                                            Object(lc.jsx)("div", {
                                                className: "ui-cruise-arrow",
                                                onMouseDown: () => {
                                                    Wl.toggleMode();
                                                },
                                                children: "\u25b4",
                                            }),
                                            Object(lc.jsx)("div", { id: "ui-cruise-style", title: r == Gl ? "automatically maintains a cruise speed" : "limits your max speed", children: r == Gl ? "cruise" : "limit" }),
                                            Object(lc.jsx)("div", {
                                                className: "ui-cruise-arrow",
                                                onMouseDown: () => {
                                                    Wl.toggleMode();
                                                },
                                                children: "\u25be",
                                            }),
                                        ],
                                    }),
                                null == a && c && Object(lc.jsx)("div", { id: "ui-cruise-label", children: "speed control" }),
                            ],
                        })
                    );
                };
            var kc = () => {
                    const [e, t] = Object(s.useState)(ie.Units),
                        [i, n] = Object(s.useState)(!1),
                        [a, o] = Object(s.useState)(!1),
                        [r, h] = Object(s.useState)(!1);
                    return (
                        Object(s.useEffect)(
                            () => (
                                ie.addListener(q.Units, t),
                                () => {
                                    ie.removeListener(q.Units, t);
                                }
                            ),
                            [t]
                        ),
                        Object(s.useEffect)(
                            () => (
                                Y.addListener("ToggleHandbrake", h),
                                () => {
                                    Y.removeListener("ToggleHandbrake", h);
                                }
                            ),
                            [h]
                        ),
                        Object(lc.jsxs)("div", {
                            id: "main-stats",
                            children: [
                                r && Object(lc.jsx)("img", { id: "ui-handbrake", src: Ac, alt: "", title: "Handbrake Engaged" }),
                                Object(lc.jsxs)("div", {
                                    id: "ui-dist",
                                    className: "ui-stat",
                                    children: [
                                        Object(lc.jsx)("span", { id: "ui-dist-val", className: "ui-stat-val", children: "0" }),
                                        Object(lc.jsx)("div", { className: "ui-stat-unit", onMouseDown: () => ie.set(q.Units, (e + 1) % 2), children: Ic[e] }),
                                        Object(lc.jsxs)("div", {
                                            id: "ui-dist-reset",
                                            children: [
                                                Object(lc.jsx)("img", {
                                                    id: "ui-dist-reset-icon",
                                                    alt: "",
                                                    src: bc,
                                                    onMouseEnter: () => n(!0),
                                                    onMouseLeave: () => {
                                                        n(!1), o(!1);
                                                    },
                                                    onClick: () => {
                                                        a ? (Ih.revertProgress(), window.localStorage.setItem("reloading", !0), window.location.reload()) : o(!0);
                                                    },
                                                }),
                                                a && Object(lc.jsx)("div", { id: "ui-dist-reset-warning", children: "Click again to confirm..." }),
                                                i && !a && Object(lc.jsx)("div", { id: "ui-dist-reset-warning", children: "Reset distance (page will reload)" }),
                                            ],
                                        }),
                                    ],
                                }),
                                Object(lc.jsx)("div", { className: "ui-stat-spacer" }),
                                Object(lc.jsxs)("div", {
                                    id: "ui-speed",
                                    className: "ui-stat",
                                    children: [
                                        Object(lc.jsx)("span", { id: "ui-speed-val", className: "ui-stat-val", children: "0" }),
                                        Object(lc.jsx)("div", { className: "ui-stat-unit", onMouseDown: () => ie.set(q.Units, (e + 1) % 2), children: yc[e] }),
                                        Object(lc.jsx)(Dc, { conversion: Sc[e], cruiseDefault: Mc[e] }),
                                    ],
                                }),
                            ],
                        })
                    );
                },
                Cc = (i(22), i(18), i.p + "static/media/controls.0048d852.svg"),
                jc = i.p + "static/media/controls_mouse_icon.0ab0135a.svg",
                Nc = i.p + "static/media/controls_controller.54e3c07e.svg",
                zc = i.p + "static/media/controls_camera.82fac4d7.svg";
            const Oc = ({ value: e, meta: t, onSet: i }) => {
                    var s, n;
                    return Object(lc.jsxs)("div", {
                        className: "settings-input-bool",
                        children: [
                            Object(lc.jsx)("div", {
                                className: e ? "settings-input-bool_option bool_selected" : "settings-input-bool_option",
                                onMouseDown: () => i(!0),
                                children: (null === (s = t.labels) || void 0 === s ? void 0 : s[1]) || "on",
                            }),
                            Object(lc.jsx)("div", {
                                className: e ? "settings-input-bool_option" : "settings-input-bool_option bool_selected",
                                onMouseDown: () => i(!1),
                                children: (null === (n = t.labels) || void 0 === n ? void 0 : n[0]) || "off",
                            }),
                        ],
                    });
                },
                Lc = ({ container: e, prop: t, meta: i, onSetProportion: n, dragging: a, setDragging: o }) => {
                    const r = Object(s.useCallback)(
                            (t) => {
                                if (e.current) {
                                    let i = e.current.getBoundingClientRect();
                                    n(Math.min(Math.max(0, (t.clientX - i.left) / i.width), 1));
                                }
                                t.stopPropagation();
                            },
                            [e, n]
                        ),
                        h = Object(s.useCallback)(() => {
                            o(!1);
                        }, [o]);
                    return (
                        Object(s.useEffect)(
                            () => (
                                a ? (window.addEventListener("mousemove", r), window.addEventListener("mouseup", h)) : (window.removeEventListener("mousemove", r), window.removeEventListener("mouseup", h)),
                                () => {
                                    window.removeEventListener("mousemove", r), window.removeEventListener("mouseup", h);
                                }
                            ),
                            [r, h, a]
                        ),
                        Object(lc.jsx)("div", {
                            className: "settings-input-range_handle",
                            style: { left: 100 * t + "%" },
                            onMouseDown: (e) => {
                                r(e), o(!0), e.stopPropagation();
                            },
                        })
                    );
                },
                Rc = [
                    Oc,
                    ({ value: e, meta: t, onSet: i }) => {
                        const [n, a] = Object(s.useState)(!1);
                        return Object(lc.jsxs)("div", {
                            className: "settings-input-enum",
                            onMouseEnter: () => a(!0),
                            onMouseLeave: () => a(!1),
                            children: [
                                t.labels[e],
                                Object(lc.jsx)("div", { className: "settings-input-enum_arrow", children: "\u25be" }),
                                n &&
                                    Object(lc.jsx)("div", {
                                        className: "settings-input-enum_options",
                                        children: t.labels.map((e, t) => Object(lc.jsx)("div", { className: "settings-input-enum_option", onMouseDown: () => i(t), children: e }, e + t)),
                                    }),
                            ],
                        });
                    },
                    Oc,
                    Oc,
                    Oc,
                    ({ value: e, meta: t, onSet: i }) => {
                        const [n, a] = Object(s.useState)(!1),
                            o = Object(s.useRef)(null),
                            r = Object(s.useCallback)(
                                (e) => {
                                    i(t.min + e * (t.max - t.min));
                                },
                                [t, i]
                            );
                        let h = (e - t.min) / (t.max - t.min);
                        return Object(lc.jsxs)("div", {
                            className: "settings-input-range",
                            children: [
                                Object(lc.jsx)("div", { className: "settings-input-range_value", children: 0 == t.precision ? Math.round(e) : e.toFixed(t.precision || 1) }),
                                Object(lc.jsx)("div", {
                                    ref: o,
                                    className: "settings-input-range_bar",
                                    onMouseDown: (e) => {
                                        let t = e.target.getBoundingClientRect();
                                        r((e.clientX - t.left) / t.width), a(!0), e.stopPropagation();
                                    },
                                    children: Object(lc.jsx)(Lc, { container: o, prop: h, meta: t, onSetProportion: r, dragging: n, setDragging: a }),
                                }),
                            ],
                        });
                    },
                ],
                Tc = ["Left Click", "Middle Click", "Right Click"],
                Pc = {
                    StickySteer: "Steer lock (hold)",
                    NextScene: "Next scene",
                    PrevScene: "Previous scene",
                    CameraMode: "Change camera view",
                    ToggleHandbrake: "Toggle handbrake",
                    ToggleUI: "Toggle UI",
                    ToggleCinecam: "Toggle free cam",
                    ToggleDebug: "Toggle debug overlay",
                    DoubleSpeed: "Double Speed (hold)",
                    ResetCamera: "Reset Camera to Vehicle",
                    MatchSpeed: "Lock to vehicle speed (toggle)",
                },
                Gc = ({ ico: e, selected: t, onMouseDown: i }) =>
                    Object(lc.jsx)("div", {
                        className: t ? "settings-sidebar_option option-selected" : "settings-sidebar_option",
                        onMouseDown: i,
                        children: Object(lc.jsx)("img", { className: "settings-sidebar_option-icon", src: e, alt: "" }),
                    }),
                Bc = ({ settings: e, meta: t, isCinecam: i }) => {
                    let s = Object.keys(e.value),
                        n = Object.keys(Vl.value);
                    return Object(lc.jsxs)("div", {
                        className: "settings-input-list",
                        children: [
                            s.map((i) => Object(lc.jsx)(Wc, { settings: e, label: i, meta: t[i], onSet: (t) => e.set(i, t) }, "setting_" + i)),
                            !i &&
                                Object(lc.jsxs)(lc.Fragment, {
                                    children: [
                                        Object(lc.jsx)("div", { className: "settings-input-row settings-input-list_section", children: "global settings" }),
                                        n.map((e) => Object(lc.jsx)(Wc, { settings: Vl, label: e, meta: Yl[e], onSet: (t) => Vl.set(e, t) }, "setting_" + e)),
                                    ],
                                }),
                        ],
                    });
                },
                Wc = ({ settings: e, label: t, meta: i, onSet: n }) => {
                    const [a, o] = Object(s.useState)(e.value[t]);
                    Object(s.useEffect)(
                        () => (
                            e.addListener(t, o),
                            () => {
                                e.removeListener(t, o);
                            }
                        ),
                        [e, t, o]
                    );
                    const r = Rc[i.type];
                    return Object(lc.jsxs)("div", {
                        className: "settings-input-row",
                        children: [Object(lc.jsx)("div", { className: i.desc ? "settings-input-label help" : "settings-input-label", title: i.desc || "", children: i.readable || t }), Object(lc.jsx)(r, { value: a, meta: i, onSet: n })],
                    });
                },
                Ec = ({ map: e }) => {
                    const t = e.value,
                        [i, n] = Object(s.useState)([]);
                    return (
                        Object(s.useEffect)(() => {
                            let e,
                                i = [];
                            for (let n in t) {
                                var s;
                                if (((e = t[n]), 0 == D.value)) 0 == (null === (s = e) || void 0 === s ? void 0 : s.indexOf("Key")) && (e = e.slice(3));
                                else 1 == D.value && (e = e > 2 ? "Mouse btn " + e : Tc[e]);
                                i.push([n, e]);
                            }
                            n(i);
                        }, [t, n]),
                        Object(lc.jsxs)("div", {
                            className: "settings-input-list",
                            children: [
                                i.map((e) => Object(lc.jsx)(Fc, { label: [e[0]], signal: e[1], onRequestReset: () => {} }, e[0] + "_" + e[1])),
                                Object(lc.jsx)("br", {}),
                                Object(lc.jsx)("div", { className: "settings-input-list_section", children: "Other key bindings are as set in your Keyboard controls. Exit free cam to modify them." }),
                            ],
                        })
                    );
                },
                Fc = ({ label: e, signal: t, awaitingReset: i, onRequestReset: s, onClearInput: n, tickTime: a = null }) => {
                    let o = null == a ? 0 : Y.controllerSignal[e] || 0;
                    return Object(lc.jsxs)("div", {
                        className: "settings-input-row",
                        children: [
                            Object(lc.jsx)("div", { className: "settings-input-label", children: Pc[e] || e }),
                            n &&
                                Object(lc.jsx)("div", {
                                    className: "settings-input-signal-clear",
                                    onMouseDown: (t) => {
                                        t.stopPropagation(), t.preventDefault(), i ? s(!1) : n(e);
                                    },
                                    children: "x",
                                }),
                            i
                                ? Object(lc.jsx)("div", {
                                      className: "settings-input-signal settings-input-signal-reset",
                                      onClick: (e) => {
                                          s(null);
                                      },
                                      children: 0 == D.value ? "press a key..." : 1 == D.value ? "click a button..." : "press a control...",
                                  })
                                : Object(lc.jsxs)("div", {
                                      className: "settings-input-signal",
                                      onClick: () => {
                                          s(e);
                                      },
                                      title: "Click to remap",
                                      children: [t, null !== a && Object(lc.jsx)("div", { className: "settings-input-signal-val", style: { width: 100 * o + "%" } })],
                                  }),
                        ],
                    });
                },
                Zc = [
                    {
                        map: b,
                        settings: A,
                        settingsMeta: y,
                        mapPanel: ({ map: e }) => {
                            const [t, i] = Object(s.useState)(e.value),
                                [n, a] = Object(s.useState)([]),
                                [o, r] = Object(s.useState)(null),
                                h = Object(s.useCallback)(
                                    (t) => {
                                        e.set({ ...e.value, [t]: null });
                                    },
                                    [e]
                                ),
                                l = Object(s.useCallback)(
                                    (t) => {
                                        if (null != o) {
                                            for (let i in e.value) e.value[i] == t.code && (e.value[i] = null);
                                            e.set({ ...e.value, [o]: t.code }), r(null);
                                        }
                                    },
                                    [o, r, e]
                                );
                            return (
                                Object(s.useEffect)(
                                    () => (
                                        i(e.value),
                                        e.addListener(i),
                                        () => {
                                            e.removeListener(i);
                                        }
                                    ),
                                    [e, i]
                                ),
                                Object(s.useEffect)(
                                    () => (
                                        null != o ? (f.lockKeys(), window.addEventListener("keydown", l)) : (f.unlockKeys(), window.removeEventListener("keydown", l)),
                                        () => {
                                            f.unlockKeys(), window.removeEventListener("keydown", l);
                                        }
                                    ),
                                    [o, l]
                                ),
                                Object(s.useEffect)(() => {
                                    let e,
                                        i = [];
                                    for (let n in t) {
                                        var s;
                                        if (((e = t[n]), 0 == D.value)) 0 == (null === (s = e) || void 0 === s ? void 0 : s.indexOf("Key")) && (e = e.slice(3));
                                        else 1 == D.value && (e = e > 2 ? "Mouse btn " + e : Tc[e]);
                                        i.push([n, e]);
                                    }
                                    a(i);
                                }, [t, a]),
                                Object(lc.jsx)("div", {
                                    className: "settings-input-list",
                                    children: n.map((e) =>
                                        Object(lc.jsx)(
                                            Fc,
                                            {
                                                label: [e[0]],
                                                signal: e[1],
                                                awaitingReset: e[0] == o,
                                                onRequestReset: (e) => {
                                                    r(e);
                                                },
                                                onClearInput: h,
                                            },
                                            e[0] + "_" + e[1]
                                        )
                                    ),
                                })
                            );
                        },
                    },
                    {
                        map: g,
                        settings: m,
                        settingsMeta: x,
                        mapPanel: ({ map: e }) => {
                            const [t, i] = Object(s.useState)(e.value),
                                [n, a] = Object(s.useState)([]),
                                [o, r] = Object(s.useState)(null),
                                h = Object(s.useCallback)(
                                    (t) => {
                                        e.set({ ...e.value, [t]: null });
                                    },
                                    [e]
                                ),
                                l = Object(s.useCallback)(
                                    (t) => {
                                        null != o && (e.set({ ...e.value, [o]: t.button }), r(null), t.preventDefault(), t.stopPropagation());
                                    },
                                    [o, r, e]
                                );
                            return (
                                Object(s.useEffect)(
                                    () => (
                                        i(e.value),
                                        e.addListener(i),
                                        () => {
                                            e.removeListener(i);
                                        }
                                    ),
                                    [e, i]
                                ),
                                Object(s.useEffect)(
                                    () => (
                                        null != o ? (f.lockKeys(), window.addEventListener("mousedown", l)) : (f.unlockKeys(), window.removeEventListener("mousedown", l)),
                                        () => {
                                            f.unlockKeys(), window.removeEventListener("mousedown", l);
                                        }
                                    ),
                                    [o, l]
                                ),
                                Object(s.useEffect)(() => {
                                    let e,
                                        i = [];
                                    for (let s in t) (e = t[s]), (e = e > 2 ? "Mouse btn " + e : Tc[e]), i.push([s, e]);
                                    a(i);
                                }, [t, a]),
                                Object(lc.jsx)("div", {
                                    className: "settings-input-list",
                                    children: n.map((e) =>
                                        Object(lc.jsx)(
                                            Fc,
                                            {
                                                label: [e[0]],
                                                signal: e[1],
                                                awaitingReset: e[0] == o,
                                                onRequestReset: (e) => {
                                                    null !== e && (0 == e && (e = null), r(e));
                                                },
                                                onClearInput: h,
                                            },
                                            e[0] + "_" + e[1]
                                        )
                                    ),
                                })
                            );
                        },
                    },
                    {
                        map: T,
                        settings: P,
                        settingsMeta: G,
                        mapPanel: ({ map: e }) => {
                            const [t, i] = Object(s.useState)(e.value),
                                [n, a] = Object(s.useState)([]),
                                [o, r] = Object(s.useState)(null),
                                [h, l] = Object(s.useState)(!1),
                                [d, c] = Object(s.useState)(null != navigator.getGamepads()[0]),
                                [p, u] = Object(s.useState)(0),
                                g = Object(s.useCallback)(
                                    (t) => {
                                        e.set({ ...e.value, [t]: null });
                                    },
                                    [e]
                                ),
                                m = Object(s.useCallback)(() => {
                                    c(!0);
                                }, [c]),
                                x = Object(s.useCallback)(() => {
                                    c(!1);
                                }, [c]);
                            return (
                                Object(s.useEffect)(
                                    () => (
                                        window.addEventListener("gamepadconnected", m),
                                        window.addEventListener("gamepaddisconnected", x),
                                        () => {
                                            window.removeEventListener("gamepadconnected", m), window.removeEventListener("gamepaddisconnected", x);
                                        }
                                    ),
                                    [m, x, c]
                                ),
                                Object(s.useEffect)(
                                    () => (
                                        oe.addSlowListener(u),
                                        () => {
                                            oe.removeSlowListener(u);
                                        }
                                    ),
                                    [u]
                                ),
                                Object(s.useEffect)(
                                    () => (
                                        i(e.value),
                                        e.addListener(i),
                                        () => {
                                            e.removeListener(i);
                                        }
                                    ),
                                    [e, i]
                                ),
                                Object(s.useEffect)(() => {
                                    null != o ? Y.initGamepadRemap(() => r(null), o) : Y.cancelGamepadRemap();
                                }, [o, r]),
                                Object(s.useEffect)(() => {
                                    let e,
                                        i = [];
                                    for (let s in t) (e = ""), t[s] && (t[s].type == z ? (e = "Btn " + t[s].index) : ((e = "Axis " + t[s].index), t[s].sign > 0 ? (e += " (+)") : (e += " (-)"))), i.push([s, e]);
                                    a(i);
                                }, [t, a]),
                                d
                                    ? Object(lc.jsx)("div", {
                                          className: "settings-input-list",
                                          children: n.map((e) =>
                                              Object(lc.jsx)(
                                                  Fc,
                                                  {
                                                      label: [e[0]],
                                                      signal: e[1],
                                                      awaitingReset: e[0] == o,
                                                      onRequestReset: (e) => {
                                                          r(e);
                                                      },
                                                      onClearInput: g,
                                                      tickTime: p,
                                                  },
                                                  e[0] + "_" + e[1]
                                              )
                                          ),
                                      })
                                    : Object(lc.jsxs)("div", {
                                          className: "settings-input-missing",
                                          children: [
                                              "No gamepad detected - check the connection then click below to re-attempt",
                                              Object(lc.jsx)("br", {}),
                                              Object(lc.jsx)("div", {
                                                  className: "settings-input-missing-check",
                                                  onClick: () => {
                                                      l(!1), null !== navigator.getGamepads()[0] ? c(!0) : setTimeout(() => l(!0), 150);
                                                  },
                                                  children: "Try Again",
                                              }),
                                              h && Object(lc.jsx)("div", { className: "settings-input-missing-check-fail", children: "No gamepad found" }),
                                          ],
                                      })
                            );
                        },
                    },
                ];
            var Hc = ({ onMouseEnter: e, onMouseLeave: t, onMouseDown: i }) => {
                const [n, a] = Object(s.useState)(D.value),
                    [o, r] = Object(s.useState)(N.value),
                    [h, l] = Object(s.useState)(0),
                    [d, c] = Object(s.useState)(!1);
                Object(s.useEffect)(
                    () => (
                        N.addListener(r),
                        () => {
                            N.removeListener(r);
                        }
                    ),
                    [r]
                ),
                    Object(s.useEffect)(
                        () => (
                            D.addListener(a),
                            () => {
                                D.removeListener(a);
                            }
                        ),
                        [a]
                    );
                let p = o ? Ec : Zc[n].mapPanel;
                return Object(lc.jsxs)("div", {
                    className: "settings-sidebar",
                    onMouseEnter: e,
                    onMouseLeave: t,
                    onMouseDown: i,
                    children: [
                        o
                            ? Object(lc.jsx)("div", { className: "settings-sidebar_options", children: Object(lc.jsx)(Gc, { ico: zc, selected: 0 == n, onMouseDown: () => {} }) })
                            : Object(lc.jsxs)("div", {
                                  className: "settings-sidebar_options",
                                  children: [
                                      Object(lc.jsx)(Gc, { ico: Cc, selected: 0 == n, onMouseDown: () => D.set(0) }),
                                      Object(lc.jsx)(Gc, { ico: jc, selected: 1 == n, onMouseDown: () => D.set(1) }),
                                      Object(lc.jsx)(Gc, { ico: Nc, selected: 2 == n, onMouseDown: () => D.set(2) }),
                                  ],
                              }),
                        Object(lc.jsxs)("div", {
                            className: "settings-sidebar_tabs",
                            children: [
                                Object(lc.jsx)("div", { className: "settings-sidebar_tab " + (0 == h ? "option-selected" : ""), onMouseDown: () => l(0), children: "controls" }),
                                Object(lc.jsx)("div", { className: "settings-sidebar_tab " + (1 == h ? "option-selected" : ""), onMouseDown: () => l(1), children: "settings" }),
                            ],
                        }),
                        Object(lc.jsx)("div", {
                            className: "settings-sidebar_content",
                            children: 0 == h ? Object(lc.jsx)(p, { map: o ? k : Zc[n].map, isCinecam: o }) : Object(lc.jsx)(Bc, { settings: o ? C : Zc[n].settings, meta: o ? j : Zc[n].settingsMeta, isCinecam: o }),
                        }),
                        0 == o &&
                            Object(lc.jsx)("div", {
                                className: "settings-sidebar_tab option-selected",
                                style: { borderTop: "3px solid #111", borderBottom: "3px solid #111", color: "#888", fontWeight: d ? "1000" : "" },
                                onClick: () => {
                                    d ? (0 == h ? Zc[n].map.reset() : Zc[n].settings.reset(), c(!1)) : c(!0);
                                },
                                children: d ? "click again to confirm reset" : "reset all to default",
                            }),
                    ],
                });
            };
            const Qc = { General: { state: ie, meta: ee }, Graphics: { state: Ih, meta: Ah }, Vehicle: { state: Pe, meta: Re } },
                Yc = ({ label: e, section: t, startCollapsed: i = !1 }) => {
                    const [n, a] = Object(s.useState)(i);
                    let o = Object.keys(t.meta);
                    return Object(lc.jsxs)(lc.Fragment, {
                        children: [
                            Object(lc.jsxs)("div", {
                                className: "settings-input-row settings-input-list_section collapsible",
                                onMouseDown: () => a(!n),
                                children: [Object(lc.jsx)("div", { className: "collapsible-title", children: e }), Object(lc.jsx)("div", { className: "collapsible-cross", children: n ? "+" : "-" })],
                            }),
                            !n && o.map((i, s) => Object(lc.jsx)(Vc, { settings: t.state, label: i, meta: t.meta[i] }, e + "_" + s)),
                        ],
                    });
                },
                Vc = ({ settings: e, label: t, meta: i }) => {
                    const [n, a] = Object(s.useState)(e.value[t]);
                    Object(s.useEffect)(
                        () => (
                            e.addListener(t, a),
                            () => {
                                e.removeListener(t, a);
                            }
                        ),
                        [e, t, a]
                    );
                    const o = Rc[i.type];
                    return Object(lc.jsxs)("div", {
                        className: "settings-input-row",
                        children: [
                            Object(lc.jsx)("div", { className: i.desc ? "settings-input-label help" : "settings-input-label", title: i.desc || "", children: i.readable || t }),
                            Object(lc.jsx)(o, { value: n, meta: i, onSet: i.onSet }),
                        ],
                    });
                };
            var Uc = ({ onMouseEnter: e, onMouseLeave: t, onMouseDown: i }) =>
                    Object(lc.jsx)("div", {
                        className: "settings-sidebar",
                        onMouseEnter: e,
                        onMouseLeave: t,
                        onMouseDown: i,
                        children: Object(lc.jsx)("div", {
                            className: "settings-sidebar_content",
                            children: Object(lc.jsxs)("div", {
                                className: "settings-input-list",
                                children: [
                                    Object(lc.jsx)(Yc, { label: "general", section: Qc.General, startCollapsed: !1 }),
                                    Object(lc.jsx)(Yc, { label: "graphics", section: Qc.Graphics, startCollapsed: !1 }),
                                    Object(lc.jsx)(Yc, { label: "vehicle", section: Qc.Vehicle, startCollapsed: !1 }),
                                ],
                            }),
                        }),
                    }),
                Xc = i.p + "static/media/globe.0021026f.svg",
                Jc = i.p + "static/media/config.fa1e0797.svg",
                qc = i.p + "static/media/v_config_1.45a9fb9a.svg",
                Kc = i.p + "static/media/w_clear.e325f7bb.svg",
                _c = i.p + "static/media/w_sunset.6daecb38.svg",
                $c = i.p + "static/media/w_sunrise.d42cfd8c.svg",
                ep = i.p + "static/media/w_cloud.126a5129.svg",
                tp = i.p + "static/media/w_night.c1e24675.svg",
                ip = i.p + "static/media/cycle_timer.e67c5684.svg",
                sp = i.p + "static/media/s_winter.a14698ea.svg",
                np = i.p + "static/media/s_spring.9771ab1e.svg",
                ap = i.p + "static/media/s_summer.eea0686a.svg",
                op = i.p + "static/media/s_autumn.76993205.svg",
                rp = i.p + "static/media/mars.4b77b21a.svg",
                hp = i.p + "static/media/s_moon.ef286549.svg",
                lp = i.p + "static/media/venus.7fd51f92.svg",
                dp = i.p + "static/media/panorama.568dc952.svg",
                cp = i.p + "static/media/feedback2.24052523.svg",
                pp = i.p + "static/media/favicon_circle_white.eb1953e3.svg",
                up = (i.p, i.p, i.p + "static/media/ico_kofi.0dd3be2c.svg"),
                gp = (i.p, i.p + "static/media/loc_hills_lines.39f0c4cc.png"),
                mp = i.p + "static/media/loc_offworld.5e298b5e.png",
                xp = (i(51), i.p + "static/media/vol_high.30de055e.svg"),
                vp = i.p + "static/media/vol_off.11497865.svg";
            const fp = ({ container: e, level: t, setLevel: i, dragging: n, setDragging: a }) => {
                const o = Object(s.useCallback)(
                        (t) => {
                            if (e.current) {
                                let s = e.current.getBoundingClientRect();
                                i(Math.min(Math.max(0, (s.bottom - t.clientY) / s.height), 1));
                            }
                            t.stopPropagation();
                        },
                        [e, i]
                    ),
                    r = Object(s.useCallback)(() => {
                        a(!1);
                    }, [a]);
                return (
                    Object(s.useEffect)(
                        () => (
                            n ? (window.addEventListener("mousemove", o), window.addEventListener("mouseup", r)) : (window.removeEventListener("mousemove", o), window.removeEventListener("mouseup", r)),
                            () => {
                                window.removeEventListener("mousemove", o), window.removeEventListener("mouseup", r);
                            }
                        ),
                        [o, r, n]
                    ),
                    Object(lc.jsx)("div", {
                        id: "slider-handle",
                        style: { top: 100 * (1 - t) + "%" },
                        onMouseDown: (e) => {
                            o(e), a(!0), e.stopPropagation();
                        },
                    })
                );
            };
            var wp = ({ requestFocus: e }) => {
                const [t, i] = Object(s.useState)(ie.AudioLevel),
                    [n, a] = Object(s.useState)(t > 0),
                    [o, r] = Object(s.useState)(0.5),
                    [h, l] = Object(s.useState)(!1),
                    d = Object(s.useRef)(null);
                return (
                    Object(s.useEffect)(() => {
                        a(t <= 0);
                    }, [a, t]),
                    Object(s.useEffect)(() => {
                        ie.set(q.AudioLevel, t);
                    }, [t]),
                    Object(s.useEffect)(
                        () => (
                            ie.addListener(q.AudioLevel, i),
                            () => {
                                ie.removeListener(q.AudioLevel, i);
                            }
                        ),
                        [i]
                    ),
                    Object(lc.jsx)(Ep, {
                        icon: n ? vp : xp,
                        expanded: !!h,
                        onMouseDown: (e) => {
                            n ? i(0 == o ? 0.5 : o) : (r(t), i(0)), e.stopPropagation();
                        },
                        onExpanded: (t) => {
                            t && e();
                        },
                        children: Object(lc.jsx)("div", {
                            id: "slider-container",
                            ref: d,
                            children: Object(lc.jsx)("div", {
                                id: "slider-line",
                                onMouseDown: (e) => {
                                    let t = e.target.getBoundingClientRect();
                                    i((t.bottom - e.clientY) / t.height), l(!0), e.stopPropagation();
                                },
                                children: Object(lc.jsx)(fp, { level: t, setLevel: i, dragging: h, setDragging: l, container: d }),
                            }),
                        }),
                    })
                );
            };
            const bp = [Cc, jc, Nc],
                Ap = {
                    clearSnow: Kc,
                    clearSpring: Kc,
                    clearAutumn: Kc,
                    sunset: _c,
                    twilight: _c,
                    autumnSunset: _c,
                    winterSunset: _c,
                    autumnSunrise: $c,
                    winterSunrise: $c,
                    springSunrise: $c,
                    sunrise: $c,
                    clear: Kc,
                    rain: ep,
                    autumnRain: ep,
                    springRain: ep,
                    snow: ep,
                    mars: Kc,
                    venus: ep,
                    night: tp,
                    nightSnow: tp,
                    marsRise: _c,
                    venusSet: _c,
                    moon: Kc,
                },
                yp = { spring: np, summer: ap, autumn: op, winter: sp, mars: rp, venus: lp, moon: hp },
                Ip = n.a.memo(({ toggleSplash: e }) =>
                    Object(lc.jsx)(lc.Fragment, {
                        children: Object(lc.jsxs)("div", {
                            id: "menu-bar",
                            onMouseEnter: () => {
                                f.setMouseEnabled(!1);
                            },
                            onMouseLeave: () => {
                                f.setMouseEnabled(!0);
                            },
                            children: [Object(lc.jsx)(Sp, {}), Object(lc.jsx)(Lp, { toggleSplash: e })],
                        }),
                    })
                ),
                Sp = () => Object(lc.jsxs)("div", { id: "menu-bar-left", children: [Object(lc.jsx)(Mp, {}), Object(lc.jsx)("div", { className: "menu-bar-vertical-divider" }), Object(lc.jsx)(zp, {}), Object(lc.jsx)(Op, {})] }),
                Mp = () => {
                    const [e, t] = Object(s.useState)(!1),
                        [i, n] = Object(s.useState)(Be),
                        [a, o] = Object(s.useState)(Ih.value.sceneName),
                        [r, h] = Object(s.useState)(Ih.value.topography),
                        [l, d] = Object(s.useState)(!1),
                        [c, p] = Object(s.useState)(!1),
                        [u, g] = Object(s.useState)(!1),
                        [m, x] = Object(s.useState)(Be),
                        [v, f] = Object(s.useState)(Ih.value.sceneName),
                        [w, b] = Object(s.useState)(Ih.value.topography),
                        [A, y] = Object(s.useState)(!1);
                    return (
                        Object(s.useEffect)(() => {
                            t(l || c || u);
                        }, [t, l, c, u]),
                        Object(s.useEffect)(() => {
                            d(m !== i);
                        }, [d, m, i]),
                        Object(s.useEffect)(() => {
                            p(v !== a);
                        }, [p, v, a]),
                        Object(s.useEffect)(() => {
                            g(w !== r);
                        }, [g, w, r]),
                        Object(lc.jsx)(lc.Fragment, {
                            children: Object(lc.jsxs)("div", {
                                className: "menu-item",
                                tabIndex: -1,
                                onMouseEnter: () => {
                                    y(!0);
                                },
                                onMouseLeave: () => {
                                    y(!1);
                                },
                                children: [
                                    Object(lc.jsx)(Cp, { src: Xc }),
                                    A &&
                                        Object(lc.jsxs)("div", {
                                            className: "menu-panel",
                                            children: [
                                                Object(lc.jsx)("div", { className: "menu-panel-row menu-panel-title", style: { color: c ? "#fff" : "", textShadow: c ? "0px 0px 5px #fff" : "" }, children: "scene" }),
                                                Object(lc.jsx)(kp, {
                                                    options: ["HILLS", "OFF-WORLD"],
                                                    bgs: [gp, mp],
                                                    selectedIndex: xh.indexOf(v),
                                                    onSelectIndex: (e) => {
                                                        e < 2 && f(xh[e]);
                                                    },
                                                }),
                                                Object(lc.jsx)("div", { className: "menu-panel-row menu-panel-title", style: { color: u ? "#fff" : "", textShadow: u ? "0px 0px 5px #fff" : "" }, children: "road complexity" }),
                                                Object(lc.jsx)(kp, {
                                                    options: ["STRAIGHT", "CASUAL", "EASY", "NORMAL", "HARD"],
                                                    bgs: [
                                                        "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAAA8CAYAAAC9xKUYAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGkGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4wLWMwMDAgNzkuMTcxYzI3ZiwgMjAyMi8wOC8xNi0xODowMjo0MyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyMi0wNy0yMFQxODoyNjo1MCswMTowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0xMi0xOVQxNzo0Mjo0MVoiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTEyLTE5VDE3OjQyOjQxWiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpjMWZkNWU2My03NDI2LWI3NGMtYTNjYy1mNDk2MDg2NGYxNGYiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpkN2ZkMWIzMS1kMDBmLTBhNGUtYjBmMS01ZTFiNzU3MWNmYzYiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpkN2RiZGM1Zi02OTcwLWYyNGQtOGVjYi1kY2U0NDQ1NWNmMTgiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpkN2RiZGM1Zi02OTcwLWYyNGQtOGVjYi1kY2U0NDQ1NWNmMTgiIHN0RXZ0OndoZW49IjIwMjItMDctMjBUMTg6MjY6NTArMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6NWJlMDMwNDYtMmI1OS1kNzQ1LTkxNTItNGEyMzJjYjFiMjQ3IiBzdEV2dDp3aGVuPSIyMDIyLTA3LTIwVDE4OjI2OjUwKzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmMxZmQ1ZTYzLTc0MjYtYjc0Yy1hM2NjLWY0OTYwODY0ZjE0ZiIgc3RFdnQ6d2hlbj0iMjAyMi0xMi0xOVQxNzo0Mjo0MVoiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyNC4wIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7yvX13AAAAwUlEQVR42u3asQ3AIAxEUZepqAn773lMYRSUV7wFztKvXEkKoIMRAIEBBAZAYACBAQQGQGAAgQEEBkBgAIEBBAZAYACBAQQGQGAAgQEEBkBgAIEBBAZAYACBAQQGQGCAKwIzADpUkgXQQWAAgQEEBkBggDOBmVzptYF7fl0leQA6eAYCfPICAgMgMIDAAAIDIDCAwAACAyAwgMAAAgMgMIDAAAIDIDCAwAACAyAwgMAAAgMgMIDAAAIDIDCAwAD/tQGalucfXEH8mwAAAABJRU5ErkJggg==",
                                                        "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAAA8CAYAAAC9xKUYAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGkGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4wLWMwMDAgNzkuMTcxYzI3ZiwgMjAyMi8wOC8xNi0xODowMjo0MyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIiB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAyMi0wNy0yMFQxODoyNjo1MCswMTowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAyMi0xMi0xOVQxNzo0MjoyNFoiIHhtcDpNb2RpZnlEYXRlPSIyMDIyLTEyLTE5VDE3OjQyOjI0WiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozYWRjY2Y0OS1kNWYyLTBlNDYtOWM4NS02MDU4ZDJmM2Q3YTIiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo3MjIyMDVhZS0wNmM4LTdlNGItYjBiNS02OTIyNmQ3YWM0NGEiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpkN2RiZGM1Zi02OTcwLWYyNGQtOGVjYi1kY2U0NDQ1NWNmMTgiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIj4gPHhtcE1NOkhpc3Rvcnk+IDxyZGY6U2VxPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY3JlYXRlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpkN2RiZGM1Zi02OTcwLWYyNGQtOGVjYi1kY2U0NDQ1NWNmMTgiIHN0RXZ0OndoZW49IjIwMjItMDctMjBUMTg6MjY6NTArMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6NWJlMDMwNDYtMmI1OS1kNzQ1LTkxNTItNGEyMzJjYjFiMjQ3IiBzdEV2dDp3aGVuPSIyMDIyLTA3LTIwVDE4OjI2OjUwKzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjNhZGNjZjQ5LWQ1ZjItMGU0Ni05Yzg1LTYwNThkMmYzZDdhMiIgc3RFdnQ6d2hlbj0iMjAyMi0xMi0xOVQxNzo0MjoyNFoiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyNC4wIChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz59L7euAAAH30lEQVR42u2dyZqqMBCF9bazyKCA0O//nnU3J59pBCEhDIlnUasWaZPKn5pS2YjIJmD5JyJHEYlFpBCRWkR+DaUWkVxEIhHZicg28DHzRbYichGRZ8/8PUXkCl3guH0ezx8ROYvIXUQqw3VSYpx/9O/9psHbQSFtBk+BpgSsDgTNqiDTN58V5u2HY9a6Ce+xgeYWm3AlIgm+421NfOuAHjEopQVofjXQ7AkabyyZWkQyztmbtZJi7GzAcheR0yfr8NsHeTeC3L+0aLyDzC9c5csXukzbRsjAVucVWM5DLEIq53jfU/n5BM3y83geaJVWsGZCny8FlYOI3ACVytJqr03AQsB8dp/SgbthF2hohi+3oE6wUobO1y2w+VIb5tEBVJoWi7HVR6XsBo2ifmlhSpZ4llmnZRbYQUQelsH7f57q6x4QSADYMVBR8M36YiwEjLs4jWmau8YzV2YvFpEdLNHKYlFdVr45KL08YSO7WwZqu3TWGWypiGYTerUETW7qu1Kc7ewXi2yhsmoUbPb4rq0sF0fRgZI5slKabpBzsG7gq/3QlDcGTW4BGpXW41jP7zJlIwotn3C5YizCw0RrZqvFUA54V4x3lw6BoqCSA1iTuYYbvKiAORlNOHihyY8laD4WJlEmt2byka6EAk4OaMVYNxdsHkfM7Q460pQd/n7AZ8/Qoxv04q5ZJ7VDoPxqaz2ey7DYtAyeIluCH89AZb+vb+M6lYzPeBVT64OOWjtPzG2JdxRYT4UmJT5Xac/+TiRqPccA4KzGw8bQFyVsPivuzdDfr2H+noRnZXxxddcuukt3WzoEshH7wBdh0664e1h/T8NdJqXbtGiRZeYoE7MEUPQwx9JBaWvAtMEmWcLs8qxgr6Lb5FUtyRWwKVcKGx0oGdy91SZqNo5+8OTRaI+V9gRztRazbNORY7mawrV8QetGDyonAKA3md8NlNkVrVWh0plWTWvGqRAeO/D5PI9KG2cadFxke/QgcYkNKcWmfV6Ty2MDmGZV4MMBrfUmTVwgf+MzsUF8Ri/SozWznnlUsZs91o1KM8ewMlJI1iEpPpfgOZXmPmIt/gtlzXTR2pUvWmvncgia1xgfYTkOHVcGgf2Cz1AJfkxMOsGNjbKzSdN4t4lBYEpQgGkz8a/a4Spb0NCieU9rV2JeO0NQU4IBTFc7A5tCJeU6RdyNrbNNPHJACRYwTVNfL1SyCQYziPkay8hwHNkSghI0YFw0aVJBTLactDv9yyMHlOAB4+JAGd2m99O/hSGoM4KaEjJgxh4oU5WsXCR/D1GauE2q1yzPi1GCBUxXNzjTlCxNfrvaGT2QTtBQggVMEzSmlawpnuOEvWpnTFtCFKyqpixR6exLEDPHDs7FYd8SglXVlCnOaO2wNi/y3pXvuZYWhkPjChe6TG8tIWx6zRI0FJu+OeqEedQESZcOriWIGQ+sZOUl5p9BbQOaRNhmg/IOkwNgcmucHjfSsTX9qPPAILB+iTkV4iVjes3ql2wR3t/p5pygP6k47H+zxtjCUJP/wVR25xia9gbWLcSHsCVq6EBRrk4sr35QLq9EWSVgdJM/GviDCx766wVNISu44Y+yOFD0O5Zm68635oEZeol5CRoTMp+rqm37+vhynSrltUHrFsqcQGl25ct8OJNzN8gwUfndH99oWjWJsNH7GoOyR3ndUz11w/Ku9p5vXfl8CV4mAwasYuWvUVX1Y4QSLnqZF+fwj9uTitt7qruajheAVyyvxuO97T19MvtuAwaxwi5NZR/eZuM+Ujl5E+h8G4PLvtl9V6IomDTv4jaaW998y+uA6lUFGVoyZgV7iWXmqa1aOMVcHSSgBtYLQUVdnTKFlaJfiZI2LBMnfYN9HPTzgIVAS8Y+8xSJm+tU9StMY/H8+o0ZXZ+DTHf5mz4nSYt14vVhx7kzTComQ2W2Cxq6vk5VWTd3AqfV9VEZn8ohVJqXtl3mtip9b1/QB5knU9hOUp6RpvxTmecRFlrI0NEzPtFEVop+T/V1agslVMAoGQoZFuO5i9WoRu9TZC0GpT49GzO9DD/TYikurRRlGa7unuoQdoTDAMgU+BxB4b7uYupCrraaC5UqPWNedfhsZbn4iYLJVTttPEUZfjNzt19rUiMUpR8CmVzYuGrKwORUJn8feFSNxgPvT+TvdaxnwPCAhbgDIHUgdck/fHaHZ48AyEVe18Um2mnj0rF10nQn73jnqqyUbwCMisn0ZZcynhaexSVQZeq5zHjuRdovlNdBVAJGOYD0wKJtkwc+V+C5Uv5edl/P8P+X0Nmrr7Gp0HbTU0+dTA3FZ43M/GnXdGHgrF3qRoV0EEWLISr1pcfnZfp6+UZG6mTvfUK3wgdRGZ9sjQFaAqZbkaMehVWZJS789TQ70gOjRaCWjg6UG3530EcrQo4F9B2QzIVd8dYIHT1L1dpIeqYYiIv4T7PO5/htZ7VCP8zX1+qBQV//wKN6xaosTop5bmZxpoRQM4Bc4v13wDDS0sdffdI89B+470lf1zyzFJy7ddQAFAFCMRZ+ik0la8kYdWWTMjyX4jtifOdVS4HzjNWXAmZIZonxmO+ygsYIx5GAsQr6sgiPQiFgRgd9P7lKCetjKBQCZkzrzbwnhXimUlAoBIyt9MVj6CpRKATMpPGYmAE9CoWAmao+pmJWiUIhYMa2d/jkKj1YgEehjJf/a1g7wQxTnAIAAAAASUVORK5CYII=",
                                                        "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAAA8CAYAAAC9xKUYAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGymlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTA3LTIwVDE4OjI2OjUwKzAxOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIyLTA3LTIwVDIyOjI1OjI3KzAxOjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMi0wNy0yMFQyMjoyNToyNyswMTowMCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpiMDMwZWJhNi0zM2ExLTczNGEtOWVmYS1mNWNiZTYxOGUwNmUiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo1NWZiMTAyYi03OTQxLWIxNGQtYWMzYi1hOGQwN2QzNjRhOTkiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpkN2RiZGM1Zi02OTcwLWYyNGQtOGVjYi1kY2U0NDQ1NWNmMTgiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmQ3ZGJkYzVmLTY5NzAtZjI0ZC04ZWNiLWRjZTQ0NDU1Y2YxOCIgc3RFdnQ6d2hlbj0iMjAyMi0wNy0yMFQxODoyNjo1MCswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo1YmUwMzA0Ni0yYjU5LWQ3NDUtOTE1Mi00YTIzMmNiMWIyNDciIHN0RXZ0OndoZW49IjIwMjItMDctMjBUMTg6MjY6NTArMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YjAzMGViYTYtMzNhMS03MzRhLTllZmEtZjVjYmU2MThlMDZlIiBzdEV2dDp3aGVuPSIyMDIyLTA3LTIwVDIyOjI1OjI3KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+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",
                                                        "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAAA8CAYAAAC9xKUYAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGymlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTA3LTIwVDE4OjI2OjUwKzAxOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIyLTA3LTIwVDIyOjI0OjE5KzAxOjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMi0wNy0yMFQyMjoyNDoxOSswMTowMCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpkOGQzZTNhOC1lZTRkLWRmNDYtOTc0MS00YThkOGZmNDVmYjYiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDo2MDk3Y2Y0Zi01MzRhLTA5NGMtYjg1MS03NDAzODQ1NjM5YjciIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpkN2RiZGM1Zi02OTcwLWYyNGQtOGVjYi1kY2U0NDQ1NWNmMTgiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmQ3ZGJkYzVmLTY5NzAtZjI0ZC04ZWNiLWRjZTQ0NDU1Y2YxOCIgc3RFdnQ6d2hlbj0iMjAyMi0wNy0yMFQxODoyNjo1MCswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo1YmUwMzA0Ni0yYjU5LWQ3NDUtOTE1Mi00YTIzMmNiMWIyNDciIHN0RXZ0OndoZW49IjIwMjItMDctMjBUMTg6MjY6NTArMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZDhkM2UzYTgtZWU0ZC1kZjQ2LTk3NDEtNGE4ZDhmZjQ1ZmI2IiBzdEV2dDp3aGVuPSIyMDIyLTA3LTIwVDIyOjI0OjE5KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+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",
                                                        "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAAA8CAYAAAC9xKUYAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGymlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHhtcDpDcmVhdGVEYXRlPSIyMDIyLTA3LTIwVDE4OjI2OjUwKzAxOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIyLTA3LTIwVDIyOjIzOjI2KzAxOjAwIiB4bXA6TW9kaWZ5RGF0ZT0iMjAyMi0wNy0yMFQyMjoyMzoyNiswMTowMCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpmMjI5ZmVhYS1kM2Q5LTI3NDktOTMxYy1hOTcxZmNiNGUwMzkiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDowMWQxODExZC1hNjczLTc5NDctOGU1ZS0yYTc5OWE4MjVlMzUiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpkN2RiZGM1Zi02OTcwLWYyNGQtOGVjYi1kY2U0NDQ1NWNmMTgiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmQ3ZGJkYzVmLTY5NzAtZjI0ZC04ZWNiLWRjZTQ0NDU1Y2YxOCIgc3RFdnQ6d2hlbj0iMjAyMi0wNy0yMFQxODoyNjo1MCswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKFdpbmRvd3MpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDo1YmUwMzA0Ni0yYjU5LWQ3NDUtOTE1Mi00YTIzMmNiMWIyNDciIHN0RXZ0OndoZW49IjIwMjItMDctMjBUMTg6MjY6NTArMDE6MDAiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE5IChXaW5kb3dzKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZjIyOWZlYWEtZDNkOS0yNzQ5LTkzMWMtYTk3MWZjYjRlMDM5IiBzdEV2dDp3aGVuPSIyMDIyLTA3LTIwVDIyOjIzOjI2KzAxOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoV2luZG93cykiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+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",
                                                    ],
                                                    selectedIndex: vh.indexOf(w),
                                                    onSelectIndex: (e) => b(vh[e]),
                                                }),
                                                Object(lc.jsx)("div", { className: "menu-panel-row menu-panel-title", style: { color: l ? "#fff" : "", textShadow: l ? "0px 0px 5px #fff" : "" }, children: "generation seed" }),
                                                Object(lc.jsx)(Dp, { curValue: m, onChanged: x }),
                                                Object(lc.jsx)("div", { className: "menu-panel-row menu-panel-title", children: e && Object(lc.jsx)("div", { className: "menu-apply-arrows arrows-down", children: "\u25be \u25be \u25be" }) }),
                                                Object(lc.jsx)("div", {
                                                    className: "menu-panel-row menu-apply-row",
                                                    children: Object(lc.jsx)("div", {
                                                        id: "menu-apply",
                                                        className: e ? "menu-panel-button" : "menu-panel-button-inactive",
                                                        onMouseDown: () => {
                                                            e &&
                                                                (l ? (Ze(m), Ih.set("topography", w, !0), Ih.set("sceneName", v, !0), Ih.set("seed", m)) : c ? (Ih.set("topography", w, !0), Ih.set("sceneName", v)) : Ih.set("topography", w),
                                                                n(Be),
                                                                h(w),
                                                                o(v));
                                                        },
                                                        children: "apply changes",
                                                    }),
                                                }),
                                                Object(lc.jsx)("div", { className: "menu-panel-row menu-panel-title", children: e && Object(lc.jsx)("div", { className: "menu-apply-arrows arrows-up", children: "\u25b4 \u25b4 \u25b4" }) }),
                                            ],
                                        }),
                                ],
                            }),
                        })
                    );
                },
                Dp = ({ curValue: e, onChanged: t }) => {
                    const [i, n] = Object(s.useState)(e),
                        [a, o] = Object(s.useState)(!1);
                    return (
                        Object(s.useEffect)(() => {
                            o(!He(i));
                        }, [o, i]),
                        Object(s.useEffect)(() => {
                            a && t(i);
                        }, [a, t, i]),
                        Object(s.useEffect)(
                            () => () => {
                                f.unlockKeys();
                            },
                            []
                        ),
                        Object(lc.jsx)("div", {
                            className: "menu-panel-row",
                            children: Object(lc.jsx)("input", {
                                className: a || 0 == i.length ? "seed-input" : "seed-input seed-invalid",
                                tabIndex: 1,
                                placeholder: "seed",
                                value: i,
                                maxLength: 32,
                                onChange: (e) => n(e.target.value),
                                onKeyDown: (e) => {
                                    13 == e.which && e.target.blur();
                                },
                                onFocus: () => {
                                    f.lockKeys();
                                },
                                onBlur: () => {
                                    a || n(Be), f.unlockKeys();
                                },
                            }),
                        })
                    );
                },
                kp = ({ options: e, bgs: t, selectedIndex: i, onSelectIndex: n }) => {
                    const [a, o] = Object(s.useState)(!1);
                    return Object(lc.jsxs)("div", {
                        className: "menu-panel-row",
                        style: t ? { backgroundImage: "url(" + t[i] + ")" } : {},
                        onMouseEnter: () => o(!0),
                        onMouseLeave: () => o(!1),
                        children: [
                            Object(lc.jsxs)("div", { className: "", children: [e[i], Object(lc.jsx)("div", { className: "menu-panel-row-expand", style: { opacity: a ? 1 : 0.75 }, children: "\u25b8" })] }),
                            a &&
                                Object(lc.jsxs)("div", {
                                    className: "menu-panel-option-list",
                                    style: { transform: "translateY(-" + (31 * e.length - 31) + "px)" },
                                    children: [
                                        e.map((e, i) => Object(lc.jsx)("div", { className: "menu-panel-option-list-row", style: t ? { backgroundImage: "url(" + t[i] + ")" } : {}, onClick: () => n(i), children: e }, "option-" + e)),
                                        Object(lc.jsx)("div", { className: "panel-expander" }),
                                    ],
                                }),
                        ],
                    });
                },
                Cp = ({ src: e, text: t, onMouseDown: i, highlight: s }) =>
                    t
                        ? Object(lc.jsx)("div", { className: s ? "menu-icon-text highlight" : "menu-icon-text", onMouseDown: i, children: t })
                        : Object(lc.jsx)("img", { className: s ? "menu-icon highlight" : "menu-icon", src: e, alt: "", width: "50%", onMouseDown: i }),
                jp = () => {
                    const [e, t] = Object(s.useState)(Vs.value);
                    return (
                        Object(s.useEffect)(
                            () => (
                                Vs.addListener(t),
                                () => {
                                    Vs.removeListener(t);
                                }
                            ),
                            [t]
                        ),
                        Object(lc.jsx)("div", {
                            style: { borderTop: "1px solid #fff4" },
                            children: Object(lc.jsxs)(Zp, {
                                selected: !1,
                                icon: ip,
                                label: "cycle timer",
                                children: [
                                    Object(lc.jsx)(Qp, { selected: 0 == e, text: "off", onMouseDown: () => Vs.set(0) }),
                                    Object(lc.jsx)(Qp, { selected: 1 == e, text: "3m", onMouseDown: () => Vs.set(1) }),
                                    Object(lc.jsx)(Qp, { selected: 2 == e, text: "8m", onMouseDown: () => Vs.set(2) }),
                                    Object(lc.jsx)(Qp, { selected: 3 == e, text: "15m", onMouseDown: () => Vs.set(3) }),
                                ],
                            }),
                        })
                    );
                },
                Np = ({ canSelect: e, configKey: t, configVal: i, icon: n, onMouseDown: a }) => {
                    const [o, r] = Object(s.useState)(Ih.value[t]);
                    return (
                        Object(s.useEffect)(
                            () => (
                                Ih.addListener(t, r),
                                () => {
                                    Ih.removeListener(t, r);
                                }
                            ),
                            [t]
                        ),
                        Object(lc.jsx)(Qp, { selected: o == i && e, icon: n, onMouseDown: a })
                    );
                },
                zp = () => {
                    const [e, t] = Object(s.useState)(Ih.sceneMeta.scenes[Ih.sceneMeta.current]),
                        [i, n] = Object(s.useState)(Ih.value.skin),
                        a = Object(s.useCallback)(() => {
                            t(Ih.sceneMeta.scenes[Ih.value.sceneName]), n("default");
                        }, [t]);
                    Object(s.useEffect)(
                        () => (
                            Ih.addListener("sceneName", a),
                            () => {
                                Ih.removeListener("sceneName", a);
                            }
                        ),
                        [a]
                    ),
                        Object(s.useEffect)(
                            () => (
                                Ih.addListener("skin", n),
                                () => {
                                    Ih.removeListener("skin", n);
                                }
                            ),
                            [n]
                        ),
                        Object(s.useEffect)(
                            () => (
                                Ih.addListener("seed", a),
                                () => {
                                    Ih.removeListener("seed", a);
                                }
                            ),
                            [a]
                        );
                    const o = Object(s.useCallback)(
                            (t, i) => {
                                Ih.set("skin", e.skins[t]), Ih.set("weatherIndex", i);
                            },
                            [e]
                        ),
                        r = Object(s.useCallback)(
                            (t) => {
                                Ih.set("skin", e.skins[t]), Ih.set("weatherIndex", 0);
                            },
                            [e]
                        );
                    let h = e.skins,
                        l = e.skinNames,
                        d = e.skinWeathers;
                    return Object(lc.jsxs)(Ep, {
                        icon: dp,
                        children: [
                            h.length &&
                                h.map((e, t) =>
                                    Object(lc.jsx)(
                                        Zp,
                                        {
                                            selected: e == i,
                                            icon: yp[l[e]],
                                            label: l[e],
                                            onMouseDown: () => r(t),
                                            children: d[e].map((s, n) => Object(lc.jsx)(Np, { canSelect: e == i, configKey: "weatherIndex", configVal: n, icon: Ap[s], onMouseDown: () => o(t, n) }, n)),
                                        },
                                        e
                                    )
                                ),
                            e.hasCycles && Object(lc.jsx)(jp, {}),
                            Object(lc.jsx)("div", { className: "stack-back", style: { width: "200px" } }),
                        ],
                    });
                },
                Op = () => {
                    const [e, t] = Object(s.useState)(Pe.value.type);
                    return (
                        Object(s.useEffect)(
                            () => (
                                Pe.addListener("type", t),
                                () => {
                                    Pe.removeListener("type", t);
                                }
                            ),
                            []
                        ),
                        Object(lc.jsxs)(Ep, {
                            icon: qc,
                            children: [
                                Ce.map((t) => Object(lc.jsx)(Zp, { selected: t == e, icon: ke[t].icon, label: t.toLowerCase(), onMouseDown: () => Pe.set("type", t) }, "veh-type-" + t)),
                                Object(lc.jsx)("div", { className: "stack-back", style: { width: "200px" } }),
                            ],
                        })
                    );
                },
                Lp = ({ toggleSplash: e }) => {
                    const [t, i] = Object(s.useState)(null);
                    return Object(lc.jsxs)("div", {
                        id: "menu-bar-right",
                        children: [
                            Object(lc.jsx)(Tp, {}),
                            Object(lc.jsx)(wp, { requestFocus: () => i(0) }),
                            Object(lc.jsx)(Rp, { requestFocus: () => i(1) }),
                            Object(lc.jsx)(Gp, { canPin: 2 == t, requestFocus: () => i(2) }),
                            Object(lc.jsx)(Pp, { canPin: 3 == t, requestFocus: () => i(3) }),
                            Object(lc.jsx)("div", { className: "menu-bar-vertical-divider" }),
                            Object(lc.jsx)(Wp, { toggleSplash: e }),
                        ],
                    });
                },
                Rp = ({ requestFocus: e }) => {
                    const [t, i] = Object(s.useState)(!1),
                        [n, a] = Object(s.useState)(""),
                        [o, r] = Object(s.useState)(!1),
                        [h, l] = Object(s.useState)(!1);
                    return (
                        Object(s.useEffect)(() => {
                            t || r(!1);
                        }, [r, t]),
                        Object(s.useEffect)(
                            () => () => {
                                f.setMouseEnabled(!0), f.unlockKeys();
                            },
                            []
                        ),
                        Object(s.useEffect)(() => {
                            t && (l(!1), window.localStorage.setItem("feedback-seen", !0)), (t && !o) || (f.setMouseEnabled(!0), f.unlockKeys());
                        }, [t, o]),
                        Object(lc.jsxs)(lc.Fragment, {
                            children: [
                                h && Object(lc.jsx)("div", { className: "feedback-prompt", children: "Any thoughts so far?" }),
                                t &&
                                    Object(lc.jsxs)("div", {
                                        className: "feedback-main",
                                        onMouseEnter: (e) => {
                                            i(!0);
                                        },
                                        onMouseLeave: (e) => {
                                            i(!1);
                                        },
                                        children: [
                                            Object(lc.jsxs)("div", {
                                                className: "feedback-header",
                                                children: [
                                                    Object(lc.jsx)("div", { className: "feedback-title", children: "Feedback" }),
                                                    Object(lc.jsx)("div", {
                                                        className: "feedback-close",
                                                        onMouseDown: (e) => {
                                                            i(!1), e.preventDefault();
                                                        },
                                                        children: "close",
                                                    }),
                                                ],
                                            }),
                                            Object(lc.jsxs)("div", {
                                                className: "feedback-blurb",
                                                children: [
                                                    "Please share any thoughts, complaints, or ideas for features below.",
                                                    Object(lc.jsx)("br", {}),
                                                    "You can also join the ",
                                                    Object(lc.jsx)("a", { className: "feedback-link", href: "https://discord.gg/slowroads", children: "discord" }),
                                                    " and hang out!",
                                                ],
                                            }),
                                            o
                                                ? Object(lc.jsx)("div", { className: "feedback-input feedback-sent", children: "Thanks!" })
                                                : Object(lc.jsxs)(lc.Fragment, {
                                                      children: [
                                                          Object(lc.jsx)("textarea", {
                                                              className: "feedback-input",
                                                              type: "text",
                                                              maxLength: "500",
                                                              placeholder: "Max 500 characters",
                                                              value: n,
                                                              onChange: (e) => a(e.target.value),
                                                              onFocus: () => {
                                                                  f.lockKeys();
                                                              },
                                                              onBlur: () => {
                                                                  f.unlockKeys();
                                                              },
                                                          }),
                                                          Object(lc.jsx)("div", {
                                                              className: "feedback-send",
                                                              onMouseDown: (e) => {
                                                                  n.length && !o && (Uh.sendFeedback(n), a(""), r(!0), window.localStorage.setItem("feedback-seen", !0)), e.preventDefault();
                                                              },
                                                              children: "Send",
                                                          }),
                                                      ],
                                                  }),
                                        ],
                                    }),
                                Object(lc.jsx)("div", {
                                    className: t ? "menu-item item-selected" : h ? "menu-item highlight" : "menu-item",
                                    style: { padding: "0px 12px", width: "auto", textAlign: "right", display: "flex" },
                                    onMouseEnter: (t) => {
                                        i(!0), e(), t.preventDefault();
                                    },
                                    onMouseLeave: (e) => {
                                        i(!1), e.preventDefault();
                                    },
                                    children: Object(lc.jsx)("img", { alt: "", style: { height: "50%", marginTop: "25px", marginRight: "4px", transform: "translateY(-50%)" }, src: cp }),
                                }),
                            ],
                        })
                    );
                },
                Tp = () =>
                    Object(lc.jsxs)("a", {
                        href: "https://ko-fi.com/slowroads",
                        target: "_blank",
                        rel: "noreferrer",
                        title: "Support development on Ko-fi!",
                        className: "menu-item",
                        style: { padding: "0px 12px", width: "auto", textAlign: "right", display: "flex" },
                        children: [
                            Object(lc.jsx)("img", { alt: "", style: { height: "50%", marginTop: "25px", marginRight: "8px", transform: "translateY(-50%)" }, src: up }),
                            Object(lc.jsx)("div", { style: { fontSize: "14px", color: "#fff" }, children: "donate" }),
                        ],
                    }),
                Pp = ({ canPin: e, requestFocus: t }) => {
                    const [i, n] = Object(s.useState)(!1),
                        [a, o] = Object(s.useState)(!1),
                        [r, h] = Object(s.useState)(ec.value);
                    Object(s.useEffect)(
                        () => (
                            ec.addListener(h),
                            () => {
                                ec.removeListener(h);
                            }
                        ),
                        [h]
                    ),
                        Object(s.useEffect)(() => {
                            i ? (ec.disable(), f.setMouseEnabled(!1)) : f.setMouseEnabled(!0);
                        }, [i]),
                        Object(s.useEffect)(() => {
                            o(a && e);
                        }, [o, a, e]);
                    let l = i && e;
                    return Object(lc.jsxs)(lc.Fragment, {
                        children: [
                            l &&
                                Object(lc.jsxs)(lc.Fragment, {
                                    children: [
                                        Object(lc.jsx)(Uc, {
                                            onMouseEnter: (e) => {
                                                n(!0);
                                            },
                                            onMouseLeave: (e) => {
                                                n(a);
                                            },
                                            onMouseDown: (e) => {
                                                o(!0);
                                            },
                                        }),
                                        Object(lc.jsx)(Bp, {
                                            onMouseDown: (e) => {
                                                o(!1), n(!1);
                                            },
                                        }),
                                    ],
                                }),
                            Object(lc.jsx)("div", {
                                className: l ? "menu-item item-selected" : "menu-item",
                                style: { padding: "0px 12px", width: "auto", textAlign: "right", display: "flex" },
                                onMouseDown: (e) => {
                                    o(!a), t();
                                },
                                onMouseEnter: (e) => {
                                    n(!0), t();
                                },
                                onMouseLeave: (e) => {
                                    n(a);
                                },
                                children: Object(lc.jsx)("img", { alt: "", style: { height: "50%", marginTop: "25px", marginRight: "4px", transform: "translateY(-50%)" }, src: Jc }),
                            }),
                            r &&
                                Object(lc.jsxs)("div", {
                                    id: "fps-prompt",
                                    children: [
                                        Object(lc.jsx)("span", { style: { fontSize: "18px", fontWeight: 1e3 }, children: "Low FPS?" }),
                                        Object(lc.jsx)("br", {}),
                                        "Try lowering the quality settings",
                                        Object(lc.jsx)("br", {}),
                                        " or enabling hardware acceleration",
                                        Object(lc.jsx)("br", {}),
                                        Object(lc.jsx)("span", { style: { paddingLeft: "calc(100% - 50px)" }, children: "\u2193" }),
                                    ],
                                }),
                        ],
                    });
                },
                Gp = ({ canPin: e, requestFocus: t }) => {
                    const [i, n] = Object(s.useState)(!1),
                        [a, o] = Object(s.useState)(!1),
                        [r, h] = Object(s.useState)(D.value);
                    Object(s.useEffect)(
                        () => (
                            D.addListener(h),
                            () => {
                                D.removeListener(h);
                            }
                        ),
                        [h]
                    ),
                        Object(s.useEffect)(() => {
                            i ? f.setMouseEnabled(!1) : f.setMouseEnabled(!0);
                        }, [i]),
                        Object(s.useEffect)(() => {
                            o(a && e);
                        }, [o, a, e]);
                    let l = i && e;
                    return Object(lc.jsxs)(lc.Fragment, {
                        children: [
                            l &&
                                Object(lc.jsxs)(lc.Fragment, {
                                    children: [
                                        Object(lc.jsx)(Hc, {
                                            onMouseEnter: (e) => {
                                                n(!0);
                                            },
                                            onMouseLeave: (e) => {
                                                n(a);
                                            },
                                            onMouseDown: (e) => {
                                                o(!0);
                                            },
                                        }),
                                        Object(lc.jsx)(Bp, {
                                            onMouseDown: (e) => {
                                                o(!1), n(!1);
                                            },
                                        }),
                                    ],
                                }),
                            Object(lc.jsx)("div", {
                                className: l ? "menu-item item-selected" : "menu-item",
                                style: { padding: "0px 12px", width: "auto", textAlign: "right", display: "flex" },
                                onMouseDown: (e) => {
                                    o(!a), t();
                                },
                                onMouseEnter: (e) => {
                                    n(!0), t();
                                },
                                onMouseLeave: (e) => {
                                    n(a);
                                },
                                children: Object(lc.jsx)("img", { alt: "", style: { height: "50%", marginTop: "25px", marginRight: "4px", transform: "translateY(-50%)" }, src: bp[r] }),
                            }),
                        ],
                    });
                },
                Bp = ({ onMouseDown: e }) =>
                    Object(lc.jsx)("div", {
                        id: "input-blocker",
                        onMouseDown: (t) => {
                            e(t), t.preventDefault();
                        },
                    }),
                Wp = ({ toggleSplash: e }) => Object(lc.jsx)(lc.Fragment, { children: Object(lc.jsx)("div", { className: "menu-item", onMouseDown: () => e(), children: Object(lc.jsx)(Cp, { src: pp }) }) }),
                Ep = (e) => {
                    const [t, i] = Object(s.useState)(e.expanded);
                    return Object(lc.jsxs)("div", {
                        className: e.highlight ? "menu-item highlight" : "menu-item",
                        tabIndex: -1,
                        onMouseEnter: () => {
                            var t;
                            i(!0), null === (t = e.onExpanded) || void 0 === t || t.call(e, !0);
                        },
                        onMouseLeave: () => {
                            var t;
                            i(!1), null === (t = e.onExpanded) || void 0 === t || t.call(e, !1);
                        },
                        children: [Object(lc.jsx)(Cp, { src: e.icon, onMouseDown: e.onMouseDown, highlight: e.highlight }), (t || e.expanded) && Object(lc.jsx)(Fp, { children: e.children })],
                    });
                },
                Fp = (e) => Object(lc.jsx)("div", { className: "menu-stack", children: e.children }),
                Zp = (e) => {
                    const [t, i] = Object(s.useState)(e.expanded || e.pinned);
                    return (
                        Object(s.useEffect)(() => {
                            i(e.pinned);
                        }, [e.pinned]),
                        Object(lc.jsxs)("div", {
                            className: e.selected ? "menu-item item-selected" : "menu-item",
                            onMouseEnter: () => {
                                var t;
                                i(!0), null === (t = e.onMouseEnter) || void 0 === t || t.call(e);
                            },
                            onMouseLeave: () => {
                                var t;
                                i(e.pinned), null === (t = e.onMouseLeave) || void 0 === t || t.call(e);
                            },
                            children: [
                                Object(lc.jsx)("img", {
                                    className: "menu-icon",
                                    src: e.icon,
                                    alt: "",
                                    onMouseDown: () => {
                                        var t;
                                        return null === (t = e.onMouseDown) || void 0 === t ? void 0 : t.call(e);
                                    },
                                }),
                                t && e.children
                                    ? Object(lc.jsx)(Hp, { children: e.children })
                                    : Object(lc.jsx)("div", { className: "stack-label", style: e.selected ? { color: "#fff" } : {}, onMouseEnter: () => i(!0), onMouseLeave: () => i(!1), children: e.label }),
                            ],
                        })
                    );
                },
                Hp = (e) => Object(lc.jsx)("div", { className: "stack-row", children: e.children }),
                Qp = (e) =>
                    Object(lc.jsx)("div", {
                        className: e.selected ? "stack-row-item item-selected" : "stack-row-item",
                        onMouseDown: () => {
                            var t;
                            return null === (t = e.onMouseDown) || void 0 === t ? void 0 : t.call(e);
                        },
                        children: Object(lc.jsx)(Cp, { src: e.icon, text: e.text }),
                    });
            var Yp = Ip;
            i(52);
            const Vp = 16,
                Up = 0.0625;
            class Xp {
                constructor(e, t, i, s) {
                    (this.origin = { x: 0, z: 0 }),
                        (this.seenIndex = 0),
                        (this.loadedNode = null),
                        (this.subNode = 0),
                        (this.angles = []),
                        (this.pos = { x: 0, y: 0 }),
                        (this.onLoadStateBound = this.onLoadState.bind(this)),
                        (this.onTickBound = this.onTick.bind(this)),
                        (this.progressCounter = 0),
                        (this.tickTimer = 0),
                        (this.svg = e),
                        (this.lineDOM = t),
                        (this.points = this.lineDOM.points),
                        (this.underlineDOM = i),
                        (this.uPoints = this.underlineDOM.points),
                        (this.circleDOM = s),
                        (this.loadedNode = $t.vehicleNode),
                        (this.seenIndex = $t.vehicleNode.i),
                        (this.baseA = $t.vehicleNode.a),
                        this.angles.push(this.baseA),
                        (this.pA = this.baseA),
                        (this.pos.x = this.loadedNode.p.x),
                        (this.pos.y = this.loadedNode.p.z),
                        d.addListener(this.onLoadStateBound),
                        this.onLoadState(d.value);
                }
                onLoadState(e) {
                    e ? oe.removeSlowListener(this.onTickBound) : oe.addSlowListener(this.onTickBound);
                }
                makePoint(e, t) {
                    let i = this.svg.createSVGPoint();
                    return (i.x = e), (i.y = t), i;
                }
                destroy() {
                    oe.removeSlowListener(this.onTickBound), d.removeListener(this.onLoadStateBound);
                }
                onTick(e) {
                    if (
                        ((this.lerp = Math.floor(
                            ((e, t, i) => {
                                let s, n, a, o, r, h;
                                return (a = i.p.x), (o = i.p.z), (r = i.next.p.x), (h = i.next.p.z), (s = (r - a) * (r - a) + (h - o) * (h - o)), (n = ((e - a) * (r - a) + (t - o) * (h - o)) / s), isNaN(n) ? 0 : Math.max(Math.min(n, 1), 0);
                            })(fe.position.x, fe.position.z, $t.vehicleNode) * Vp
                        )),
                        !(this.loadedNode.i == $t.vehicleNode.i + 16 && this.lerp <= this.subNode))
                    ) {
                        for (; this.loadedNode.i < $t.vehicleNode.i + 16; ) {
                            for (this.i = this.subNode; this.i < Vp; this.i++)
                                (this.l = this.i / Vp),
                                    (this.l1 = 1 - this.l),
                                    (this.p = this.makePoint(this.loadedNode.p.x * this.l1 + this.loadedNode.next.p.x * this.l, this.loadedNode.p.z * this.l1 + this.loadedNode.next.p.z * this.l)),
                                    this.points.appendItem(this.p),
                                    this.uPoints.appendItem(this.p),
                                    (this.baseA -= this.loadedNode.next.da * Up),
                                    this.angles.push(this.baseA);
                            (this.loadedNode = this.loadedNode.next),
                                this.progressCounter++,
                                this.progressCounter > 100 && Math.abs(this.loadedNode.a - this.baseA) < 0.1 && ((this.baseA = this.loadedNode.a), (this.progressCounter = 0)),
                                (this.subNode = 0);
                        }
                        for (this.i = this.subNode; this.i < this.lerp; this.i++)
                            (this.l = this.i / Vp),
                                (this.l1 = 1 - this.l),
                                (this.p = this.makePoint(this.loadedNode.p.x * this.l1 + this.loadedNode.next.p.x * this.l, this.loadedNode.p.z * this.l1 + this.loadedNode.next.p.z * this.l)),
                                this.points.appendItem(this.p),
                                this.uPoints.appendItem(this.p),
                                (this.baseA -= this.loadedNode.next.da * Up),
                                this.angles.push(this.baseA);
                        for (this.subNode = this.lerp; this.points.length > 256; ) this.points.removeItem(0), this.uPoints.removeItem(0), this.angles.shift(), (this.pos = this.points.getItem(0));
                    }
                    (this.pA = 0.95 * this.pA + 0.05 * this.angles[0]),
                        (this.transform = "rotate(" + (90 - (180 * this.pA) / Math.PI) + ")"),
                        (this.transform += " translate(" + -1 * this.pos.x + " " + -1 * this.pos.y + ")"),
                        this.lineDOM.setAttribute("transform", this.transform),
                        this.underlineDOM.setAttribute("transform", this.transform),
                        this.circleDOM.setAttribute("cx", this.pos.x),
                        this.circleDOM.setAttribute("cy", this.pos.y),
                        this.circleDOM.setAttribute("transform", this.transform);
                }
            }
            var Jp = n.a.memo(() => {
                const e = Object(s.useRef)(null),
                    t = Object(s.useRef)(null),
                    i = Object(s.useRef)(null),
                    n = Object(s.useRef)(null),
                    a = Object(s.useRef)(null),
                    [o, r] = Object(s.useState)(ce.value),
                    [h, l] = Object(s.useState)(ie.value.ShowWorm);
                Object(s.useEffect)(() => {
                    if (null !== e.current && null !== t.current && null !== i.current && null !== n.current)
                        return (
                            a.current || (a.current = new Xp(e.current, t.current, i.current, n.current)),
                            () => {
                                a.current && a.current.destroy();
                            }
                        );
                }, [e, t, i, n, a]),
                    Object(s.useEffect)(
                        () => (
                            ce.addListener(r),
                            () => {
                                ce.removeListener(r);
                            }
                        ),
                        [r]
                    ),
                    Object(s.useEffect)(
                        () => (
                            ie.addListener("ShowWorm", l),
                            () => {
                                ie.removeListener("ShowWorm", l);
                            }
                        ),
                        [r]
                    );
                let d = h == K || (h == _ && !o);
                return Object(lc.jsx)("div", {
                    id: "upcoming-container",
                    style: { opacity: d ? "1" : "0" },
                    children: Object(lc.jsx)("svg", {
                        ref: e,
                        viewBox: "0 0 160 120",
                        width: "100%",
                        height: "100%",
                        children: Object(lc.jsxs)("g", {
                            transform: "translate(80 96) scale(-0.5 -0.5)",
                            children: [
                                Object(lc.jsx)("polyline", { ref: i, points: "", transform: "translate(0 0)", stroke: "#2224", strokeWidth: "24", strokeLinecap: "round", fill: "none" }),
                                Object(lc.jsx)("polyline", { ref: t, points: "", transform: "translate(0 0)", stroke: "#fff9", strokeWidth: "12", strokeLinecap: "round", fill: "none" }),
                                Object(lc.jsx)("circle", { ref: n, fill: "#444", r: "3" }),
                            ],
                        }),
                    }),
                });
            });
            i(53);
            const qp = { edge: { title: "The Edge", body: '"No, it\'s not a bug! Stay on the road!"' } };
            var Kp = () => {
                const [e, t] = Object(s.useState)(null),
                    [i, n] = Object(s.useState)(null);
                return (
                    Object(s.useEffect)(
                        () => (
                            Hl.addListener("any", t),
                            () => {
                                Hl.removeListener("any", t);
                            }
                        ),
                        [t]
                    ),
                    Object(s.useEffect)(() => {
                        e && n(qp[e]);
                    }, [e, n]),
                    null !== e &&
                        setTimeout(() => {
                            t(null);
                        }, 5e3),
                    Object(lc.jsx)("div", {
                        id: "achievement",
                        className: null !== e ? "achievement-active" : "",
                        children:
                            null != i &&
                            Object(lc.jsxs)(lc.Fragment, {
                                children: [
                                    Object(lc.jsx)("div", { id: "achievement-title", children: i.title }),
                                    Object(lc.jsx)("div", { id: "achievement-body", children: i.body }),
                                    Object(lc.jsx)("div", { id: "achievement-unlocked", children: "achievement unlocked" }),
                                ],
                            }),
                    })
                );
            };
            i(54);
            const _p = (e) => {
                    if (("number" !== typeof e && (e = parseFloat(e)), e < 60)) return e.toFixed(3);
                    let t = Math.floor(e / 60);
                    return (e = (e - 60 * t).toFixed(3)) < 10 && (e = "0" + e), t < 10 && (t = "0" + t), t + ":" + e;
                },
                $p = ({ view: e }) =>
                    Object(lc.jsxs)("div", {
                        id: "ui-records-leaderboard",
                        children: [
                            Object(lc.jsxs)("div", {
                                className: "ui-records-title",
                                children: [
                                    Object(lc.jsx)("div", { children: "Records" }),
                                    Object(lc.jsxs)("div", {
                                        className: "ui-records-board-switch",
                                        children: [
                                            Object(lc.jsx)("div", { className: "ui-records-board-switch-arrow", onMouseDown: () => $l.switchBoard(), children: "\u25c2" }),
                                            Object(lc.jsx)("div", { className: "ui-records-board-switch-value", children: e.board }),
                                            Object(lc.jsx)("div", { className: "ui-records-board-switch-arrow", onMouseDown: () => $l.switchBoard(), children: "\u25b8" }),
                                        ],
                                    }),
                                    "global" == e.board &&
                                        Object(lc.jsxs)("div", {
                                            className: "ui-records-board-switch",
                                            children: [
                                                Object(lc.jsx)("div", { className: "ui-records-board-switch-arrow", onMouseDown: () => $l.switchTime(), children: "\u25c2" }),
                                                Object(lc.jsx)("div", { className: "ui-records-board-switch-value", children: "allTime" == e.time ? "all time" : "daily" }),
                                                Object(lc.jsx)("div", { className: "ui-records-board-switch-arrow", onMouseDown: () => $l.switchTime(), children: "\u25b8" }),
                                            ],
                                        }),
                                ],
                            }),
                            "personal" == e.board ? Object(lc.jsx)(eu, { topography: e.topography, vehicle: e.vehicle }) : Object(lc.jsx)(tu, { time: e.time, topography: e.topography, vehicle: e.vehicle }),
                        ],
                    }),
                eu = ({ topography: e, vehicle: t }) => {
                    const [i, n] = Object(s.useState)(Kl.personal),
                        a = Object(s.useCallback)(
                            (e) => {
                                n({ ...e });
                            },
                            [n]
                        );
                    Object(s.useEffect)(
                        () => (
                            Kl.addListener("personal", a),
                            () => {
                                Kl.removeListener("personal", a);
                            }
                        ),
                        [a]
                    );
                    const o = i[e][t];
                    return Object(lc.jsxs)("div", {
                        className: "ui-records-row",
                        children: [Object(lc.jsx)("div", { className: "ui-records-record", children: "Fastest Mile:" }), Object(lc.jsx)("div", { className: "ui-records-value", children: o < 0 ? "-" : _p(o) })],
                    });
                },
                tu = ({ time: e, topography: t, vehicle: i }) => {
                    var n, a;
                    const [o, r] = Object(s.useState)($l.global);
                    Object(s.useEffect)(
                        () => (
                            $l.addListener("global", r),
                            () => {
                                $l.removeListener("global", r);
                            }
                        ),
                        [r]
                    );
                    let h = null;
                    return (
                        o && (h = o[e][t][i]),
                        h
                            ? Object(lc.jsxs)("div", {
                                  className: "ui-records-row",
                                  children: [
                                      Object(lc.jsx)("div", { className: "ui-records-record", children: "Fastest Mile:" }),
                                      Object(lc.jsx)("div", {
                                          className: "ui-records-value",
                                          children: (null === (n = h) || void 0 === n || null === (a = n.fastestMile) || void 0 === a ? void 0 : a.value) > 0 ? _p(h.fastestMile.value) : "-",
                                      }),
                                      Object(lc.jsx)("div", { className: "ui-records-addendum", children: h.fastestMile.name }),
                                  ],
                              })
                            : Object(lc.jsx)("div", { className: "ui-records-row", style: { fontStyle: "italic" }, children: "Could not connect" })
                    );
                },
                iu = (e) => {
                    const [t, i] = Object(s.useState)(Kl.live),
                        n = Object(s.useCallback)(
                            (e) => {
                                i({ ...e });
                            },
                            [i]
                        );
                    return (
                        Object(s.useEffect)(
                            () => (
                                Kl.addListener("live", n),
                                () => {
                                    Kl.removeListener("live", n);
                                }
                            ),
                            [n]
                        ),
                        Object(lc.jsxs)("div", {
                            id: "ui-records-current",
                            children: [
                                Object(lc.jsx)("div", { className: "ui-records-title", children: "Current" }),
                                Object(lc.jsxs)("div", {
                                    className: "ui-records-row",
                                    children: [
                                        Object(lc.jsx)("div", { className: "ui-records-record", children: "Fastest Mile:" }),
                                        Object(lc.jsx)("div", { className: "ui-records-value", children: t.value < 0 ? "-" : _p(t.value.toFixed(3)) }),
                                        Object(lc.jsxs)("div", {
                                            className: "ui-records-addendum",
                                            children: [
                                                Object(lc.jsx)("div", { className: "ui-records-progress", children: Object(lc.jsx)("div", { className: "ui-records-progress-fill", style: { width: 100 * t.progress + "%" } }) }),
                                                Object(lc.jsx)("img", {
                                                    alt: "",
                                                    src: bc,
                                                    className: "ui-records-reset",
                                                    onMouseDown: () => {
                                                        td.resetFastestMile();
                                                    },
                                                }),
                                            ],
                                        }),
                                    ],
                                }),
                                Object(lc.jsxs)("div", {
                                    className: "ui-records-row",
                                    children: [
                                        Object(lc.jsx)("div", { className: "ui-records-record", style: { fontSize: "14px", fontStyle: "italic" }, children: "previous:" }),
                                        Object(lc.jsx)("div", { className: "ui-records-value", style: { fontSize: "12px" }, children: t.prev <= 0 ? "-" : _p(t.prev) }),
                                        Object(lc.jsx)("div", { className: "ui-records-addendum", style: { fontSize: "10px" } }),
                                    ],
                                }),
                            ],
                        })
                    );
                };
            var su = (e) => {
                var t;
                const [i, n] = Object(s.useState)(ed.value),
                    [a, o] = Object(s.useState)($l.view);
                return (
                    Object(s.useEffect)(
                        () => (
                            ed.addListener(n),
                            () => {
                                ed.removeListener(n);
                            }
                        ),
                        []
                    ),
                    Object(s.useEffect)(
                        () => (
                            $l.addListener("view", o),
                            () => {
                                $l.removeListener("view", o);
                            }
                        ),
                        [o]
                    ),
                    i
                        ? Object(lc.jsxs)("div", {
                              id: "ui-records-main",
                              children: [
                                  Object(lc.jsxs)("div", {
                                      id: "ui-records-header",
                                      children: [
                                          Object(lc.jsx)("div", { id: "ui-records-title", children: "STATS" }),
                                          Object(lc.jsx)("div", { id: "ui-records-category", children: a.topography + " / " + (null === (t = a.vehicle) || void 0 === t ? void 0 : t.toLowerCase()) }),
                                      ],
                                  }),
                                  Object(lc.jsx)($p, { view: a }),
                                  Object(lc.jsx)("br", {}),
                                  Object(lc.jsx)(iu, {}),
                              ],
                          })
                        : Object(lc.jsx)(lc.Fragment, { children: " " })
                );
            };
            const nu = "reloading";
            let au = !1;
            if (!Nh.newUser)
                try {
                    let e = JSON.parse(Nh.lastActiveTime);
                    au = Date.now() - e < 3e4;
                } catch (Au) {}
            const ou = !(window.location.href.indexOf("?") > 0 || au || null !== window.localStorage.getItem(nu));
            window.localStorage.removeItem(nu);
            const ru = n.a.memo(() => {
                    const e = Object(s.useRef)(null),
                        t = Object(s.useRef)(null),
                        i = Object(s.useRef)(null),
                        [n, a] = Object(s.useState)(ou),
                        [o, r] = Object(s.useState)(!0),
                        [h, l] = Object(s.useState)(0),
                        [d, c] = Object(s.useState)(null),
                        [p, u] = Object(s.useState)(!ou),
                        [g, m] = Object(s.useState)(!1),
                        x = Object(s.useCallback)(() => {
                            n ? oe.resume(!0) : oe.pause(!0), !p && n && u(!0), a(!n);
                        }, [a, n, u, p]),
                        v = Object(s.useCallback)(() => {
                            r(!o);
                        }, [r, o]);
                    Object(s.useEffect)(
                        () => (
                            f.addListener(V.Esc, x),
                            () => {
                                f.removeListener(V.Esc, x);
                            }
                        ),
                        [x]
                    ),
                        Object(s.useEffect)(
                            () => (
                                Y.addListener("ToggleUI", v),
                                () => {
                                    Y.removeListener("ToggleUI", v);
                                }
                            ),
                            [v]
                        ),
                        Object(s.useEffect)(
                            () => (
                                ne.addListener(m),
                                () => {
                                    ne.removeListener(m);
                                }
                            ),
                            [m]
                        ),
                        Object(s.useEffect)(() => {
                            if (null === e.current || null === t.current) return;
                            if (
                                (new ResizeObserver((t) => {
                                    i.current && e.current && i.current.setSize(e.current.offsetWidth, e.current.offsetHeight);
                                }).observe(e.current),
                                !i.current && p)
                            ) {
                                if (X) return;
                                (i.current = new ic(t.current, e.current, c, l)), console.log("Making new sceneController and beginning"), i.current.beginGame();
                            }
                            return () => {
                                i.current;
                            };
                        }, [p]);
                    const w = h < 1;
                    return Object(lc.jsxs)("div", {
                        id: "game-main",
                        ref: e,
                        tabIndex: 1,
                        className: "render-panel",
                        children: [
                            n &&
                                Object(lc.jsx)(vc, {
                                    supported: !X,
                                    loadProgress: h,
                                    gameHasBegun: p,
                                    onClose: () => {
                                        var e;
                                        x(), null === (e = i.current) || void 0 === e || e.beginGame();
                                    },
                                }),
                            null !== d && Object(lc.jsx)(pu, { msg: d }),
                            Object(lc.jsxs)("div", {
                                id: "update-alert",
                                onMouseDown: (e) => {
                                    e.target.style.display = "none";
                                },
                                children: [Object(lc.jsx)("div", { className: "update-alert-title", children: "New version available!" }), "Update with a hard refresh", Object(lc.jsx)("br", {}), "(CTRL + F5)"],
                            }),
                            p &&
                                Object(lc.jsxs)("div", {
                                    id: "game-ui",
                                    style: { display: n || !o ? "none" : "block" },
                                    onContextMenu: (e) => {
                                        e.preventDefault();
                                    },
                                    children: [
                                        Object(lc.jsx)(du, {}),
                                        Object(lc.jsx)(Kp, {}),
                                        Object(lc.jsx)(cu, { sceneController: i }),
                                        Object(lc.jsx)("div", {
                                            id: "game-paused",
                                            onClick: () => {
                                                g ? ne.disable() : oe.resume(!0);
                                            },
                                            children:
                                                1 == g
                                                    ? Object(lc.jsxs)("div", {
                                                          className: "game-paused-ha",
                                                          children: [
                                                              "Critically low FPS detected - check you have hardware acceleration enabled for your browser.",
                                                              Object(lc.jsx)("br", {}),
                                                              Object(lc.jsx)("br", {}),
                                                              "You may have to check your browser settings, GPU control panel, or OS settings for your browser application.",
                                                              Object(lc.jsx)("br", {}),
                                                              Object(lc.jsx)("br", {}),
                                                              "Refresh the page to dismiss this message.",
                                                              Object(lc.jsx)("br", {}),
                                                          ],
                                                      })
                                                    : Object(lc.jsx)("div", { className: "game-paused-main", children: "PAUSED" }),
                                        }),
                                        Object(lc.jsx)(su, {}),
                                        Object(lc.jsx)(lu, {}),
                                        Object(lc.jsx)(Yp, { toggleSplash: x }),
                                        Object(lc.jsx)(kc, {}),
                                        w ? Object(lc.jsx)(hu, { loadProgress: h }) : Object(lc.jsx)(Jp, {}),
                                        Object(lc.jsx)("div", { id: "game-ui-backing" }),
                                    ],
                                }),
                            Object(lc.jsxs)("div", {
                                id: "ui-debug",
                                children: [
                                    Object(lc.jsxs)("div", {
                                        className: "ui-debug-row",
                                        children: [Object(lc.jsx)("div", { className: "ui-debug-label", children: "Position:" }), Object(lc.jsx)("div", { id: "ui-debug-position", children: "1, 2, 3" })],
                                    }),
                                    Object(lc.jsxs)("div", {
                                        className: "ui-debug-row",
                                        children: [Object(lc.jsx)("div", { className: "ui-debug-label", children: "Far Coords:" }), Object(lc.jsx)("div", { id: "ui-debug-far-coords", children: "1, 2, 3" })],
                                    }),
                                    Object(lc.jsxs)("div", {
                                        className: "ui-debug-row",
                                        children: [Object(lc.jsx)("div", { className: "ui-debug-label", children: "Vehicle Node:" }), Object(lc.jsx)("div", { id: "ui-debug-node", children: "1" })],
                                    }),
                                    Object(lc.jsxs)("div", {
                                        className: "ui-debug-row",
                                        children: [Object(lc.jsx)("div", { className: "ui-debug-label", children: "Midline Tail:" }), Object(lc.jsx)("div", { id: "ui-debug-midline-tail", children: "123" })],
                                    }),
                                    Object(lc.jsx)("hr", {}),
                                ],
                            }),
                            Object(lc.jsx)("canvas", {
                                ref: t,
                                className: "render-canvas",
                                tabIndex: -1,
                                onContextMenu: (e) => {
                                    e.preventDefault();
                                },
                            }),
                        ],
                    });
                }),
                hu = ({ loadProgress: e }) =>
                    Object(lc.jsx)("div", {
                        id: "live-loader-bg",
                        children: Object(lc.jsxs)("div", {
                            id: "live-loader",
                            children: [
                                Object(lc.jsx)("div", { className: "live-load-text", children: Math.round(100 * e) + "%" }),
                                Object(lc.jsx)("div", { className: "live-load-bar", style: { width: 100 * e + "%" } }),
                                Object(lc.jsx)("div", { className: "live-load-title", children: "generating..." }),
                            ],
                        }),
                    }),
                lu = () => {
                    const [e, t] = Object(s.useState)(ce.value);
                    return (
                        Object(s.useEffect)(
                            () => (
                                ce.addListener(t),
                                () => {
                                    ce.removeListener(t);
                                }
                            ),
                            [t]
                        ),
                        Object(lc.jsxs)("div", {
                            id: "autodrive",
                            className: e ? "autodrive-active" : "",
                            onMouseDown: () => ce.set(!e),
                            children: [
                                Object(lc.jsx)("div", { className: e ? "autodrive-bar autodrive-bar-left autodrive-bar-active" : "autodrive-bar autodrive-bar-left" }),
                                Object(lc.jsxs)("div", { id: "autodrive-button", children: ["autodrive ", e ? "on" : "off"] }),
                                Object(lc.jsx)("div", { className: e ? "autodrive-bar autodrive-bar-right autodrive-bar-active" : "autodrive-bar autodrive-bar-right" }),
                            ],
                        })
                    );
                },
                du = () => {
                    const [e, t] = Object(s.useState)(rd.value),
                        [i, n] = Object(s.useState)(rd.value);
                    return (
                        Object(s.useEffect)(
                            () => (
                                rd.addListener(t),
                                () => {
                                    rd.removeListener(t);
                                }
                            ),
                            [t]
                        ),
                        Object(s.useEffect)(() => {
                            e !== id.None && n(e);
                        }, [e, n]),
                        Object(lc.jsxs)("div", {
                            id: "control-prompt",
                            style: { opacity: rd.value },
                            children: [
                                i == id.Basic &&
                                    Object(lc.jsxs)(lc.Fragment, {
                                        children: [
                                            Object(lc.jsxs)("div", {
                                                children: [
                                                    Object(lc.jsx)("div", { className: "control-key-row", children: Object(lc.jsx)("div", { className: "control-key", children: "W" }) }),
                                                    Object(lc.jsxs)("div", {
                                                        className: "control-key-row",
                                                        children: [
                                                            Object(lc.jsx)("div", { className: "control-key", children: "A" }),
                                                            Object(lc.jsx)("div", { className: "control-key", children: "S" }),
                                                            Object(lc.jsx)("div", { className: "control-key", children: "D" }),
                                                        ],
                                                    }),
                                                    Object(lc.jsx)("div", { className: "control-label", children: "drive" }),
                                                ],
                                            }),
                                            Object(lc.jsxs)("div", {
                                                style: { width: "18vh" },
                                                children: [
                                                    Object(lc.jsxs)("div", {
                                                        className: "control-key-row",
                                                        style: { marginTop: "5.8vh" },
                                                        children: [Object(lc.jsx)("div", { className: "control-key", children: "Q" }), Object(lc.jsx)("div", { className: "control-key", children: "E" })],
                                                    }),
                                                    Object(lc.jsx)("div", { className: "control-label", children: "change setting" }),
                                                ],
                                            }),
                                            Object(lc.jsxs)("div", {
                                                style: { width: "18vh" },
                                                children: [
                                                    Object(lc.jsx)("div", { className: "control-key-row", style: { marginTop: "5.8vh" }, children: Object(lc.jsx)("div", { className: "control-key", children: "C" }) }),
                                                    Object(lc.jsx)("div", { className: "control-label", children: "change camera" }),
                                                ],
                                            }),
                                            Object(lc.jsxs)("div", {
                                                style: { width: "18vh" },
                                                children: [
                                                    Object(lc.jsx)("div", { className: "control-key-row", style: { marginTop: "5.8vh" }, children: Object(lc.jsx)("div", { className: "control-key", children: "F" }) }),
                                                    Object(lc.jsx)("div", { className: "control-label", children: "toggle autodrive" }),
                                                ],
                                            }),
                                        ],
                                    }),
                                i == id.Reset &&
                                    Object(lc.jsxs)("div", {
                                        style: { width: "18vh" },
                                        children: [
                                            Object(lc.jsx)("div", { className: "control-key-row", style: { marginTop: "6.5vh" }, children: Object(lc.jsx)("div", { className: "control-key", children: "R" }) }),
                                            Object(lc.jsx)("div", { className: "control-label", children: "stay on the road" }),
                                        ],
                                    }),
                                i == id.Boost &&
                                    Object(lc.jsxs)("div", {
                                        style: { width: "18vh" },
                                        children: [
                                            Object(lc.jsx)("div", { className: "control-key-row", style: { marginTop: "6.5vh" }, children: Object(lc.jsx)("div", { className: "control-key", style: { width: "8vh" }, children: "shift" }) }),
                                            Object(lc.jsx)("div", { className: "control-label", children: "hold to boost acceleration" }),
                                        ],
                                    }),
                                i == id.UTurn &&
                                    Object(lc.jsxs)("div", {
                                        style: { width: "18vh" },
                                        children: [
                                            Object(lc.jsx)("div", { className: "control-key-row", style: { marginTop: "6.5vh" }, children: Object(lc.jsx)("img", { id: "wrong-way-icon", src: nc, alt: "" }) }),
                                            Object(lc.jsx)("div", { className: "control-label", children: "wrong way" }),
                                        ],
                                    }),
                                i == id.Reverse &&
                                    Object(lc.jsxs)("div", {
                                        style: { width: "18vh" },
                                        children: [
                                            Object(lc.jsx)("div", { className: "control-key-row", style: { marginTop: "6.5vh" }, children: Object(lc.jsx)("img", { id: "wrong-way-icon", src: ac, alt: "" }) }),
                                            Object(lc.jsx)("div", { className: "control-label", children: "keep moving forward" }),
                                        ],
                                    }),
                            ],
                        })
                    );
                },
                cu = ({ sceneController: e }) => {
                    const [t, i] = Object(s.useState)(D.value),
                        [n, a] = Object(s.useState)(m.axisWidth);
                    Object(s.useEffect)(() => (D.addListener(i), () => D.removeListener(i)), [i]);
                    const o = 1 == t;
                    return (
                        Object(s.useEffect)(() => (m.addListener("axisWidth", a), () => m.removeListener("axisWidth", a)), [a]),
                        Object(lc.jsxs)("div", {
                            id: "ui-mouse",
                            style: { bottom: "calc(" + c.mouseWidgetHeight + "vh + 25px)", display: o ? "block" : "none" },
                            children: [
                                Object(lc.jsx)("div", { id: "ui-mouse-prompt", children: "[ click to begin ]" }),
                                Object(lc.jsxs)("div", {
                                    id: "ui-mouse-input",
                                    style: { width: "max(320px, " + 100 * n + "vw)" },
                                    children: [
                                        Object(lc.jsxs)("div", { className: "ui-mouse-bar", children: [Object(lc.jsx)("div", { className: "ui-mouse-bar-line" }), Object(lc.jsx)("div", { className: "ui-mouse-bar-midline" })] }),
                                        Object(lc.jsx)("div", { id: "ui-mouse-bar-marker", children: Object(lc.jsx)("div", { className: "ui-mouse-bar-marker-tick" }) }),
                                    ],
                                }),
                                Object(lc.jsx)("div", { className: "ui-mouse-bar-boundary" }),
                                Object(lc.jsx)("div", {
                                    className: "ui-mouse-reset",
                                    onMouseDown: (t) => {
                                        var i;
                                        null === (i = e.current) || void 0 === i || i.resetVehicle(), t.preventDefault(), t.stopPropagation();
                                    },
                                    children: "reset",
                                }),
                            ],
                        })
                    );
                },
                pu = ({ msg: e }) =>
                    Object(lc.jsxs)("div", {
                        id: "game-error",
                        children: [
                            Object(lc.jsx)("img", { id: "game-error-icon", src: sc, alt: "" }),
                            Object(lc.jsx)("br", {}),
                            Object(lc.jsx)("br", {}),
                            Object(lc.jsx)("div", { id: "game-error-title", children: "Critical Error" }),
                            Object(lc.jsx)("br", {}),
                            Object(lc.jsxs)("div", {
                                id: "game-error-message",
                                children: [
                                    "Apologies - please click below to continue with a different generation seed. Your distance progress will carry over.",
                                    Object(lc.jsx)("br", {}),
                                    Object(lc.jsx)("br", {}),
                                    "This error has been recorded for investigation.",
                                ],
                            }),
                            Object(lc.jsx)("br", {}),
                            Object(lc.jsx)("br", {}),
                            Object(lc.jsx)("div", {
                                id: "game-error-reload",
                                onMouseDown: () => {
                                    window.localStorage.setItem("restore-progress", $t.vehicleIndex - $t.initIndex + Ih.accumulatedProgress), Ze(null, !0);
                                },
                                children: "reload",
                            }),
                        ],
                    });
            var uu = ru;
            const gu = () => Object(lc.jsx)("div", { className: "App", children: Object(lc.jsx)(uu, {}) });
            var mu = function () {
                return Object(lc.jsx)(gu, {});
            };
            i(28), i(3), i(55);
            lc.Fragment, lc.Fragment, lc.Fragment;
            i(56);
            const xu = {
                sessionCount: 0,
                pastSessionCount: 0,
                averages: {
                    duration: 0,
                    distance: 0,
                    resetCount: 0,
                    skins: {},
                    difficultyResets: { easy: 0, normal: 0, hard: 0 },
                    skinChanges: 0,
                    weatherChanges: 0,
                    vehicleChanges: 0,
                    driveModeChanges: 0,
                    cruiseControlSpeed: 0,
                    fps: 0,
                    autodriveTime: 0,
                },
                maxes: { duration: 0, distance: 0 },
                cumulatives: {
                    difficulty: { easy: 0, normal: 0, hard: 0 },
                    totalVisits: 0,
                    viewDistance: [],
                    detailLevel: [],
                    returningPlayers: 0,
                    revisits: 0,
                    skinTimes: {},
                    driveModeTimes: {},
                    stickySteer: 0,
                    cruiseControlUses: 0,
                    browser: {},
                    hourlyVisits: [],
                    lowFPS: 0,
                    lowFPSBrowser: {},
                    lowFPSResolution: {},
                    lowFPSView: [0, 0, 0, 0],
                    lowFPSDetail: [0, 0, 0, 0],
                    location: {},
                },
                poorPerformance: [],
                activeSessions: {},
                feedback: [],
                quarterlyActiveSessions: [],
                quarterlyCumulativeSessions: [],
                pastSessions: [],
                upTime: 0,
            };
            new (class {
                constructor() {
                    (this.connected = !1),
                        (this.sessionCount = 0),
                        (this.pastSessionCount = 0),
                        (this.averages = {
                            duration: 0,
                            distance: 0,
                            resetCount: 0,
                            skins: {},
                            difficultyResets: { easy: 0, normal: 0, hard: 0 },
                            skinChanges: 0,
                            weatherChanges: 0,
                            vehicleChanges: 0,
                            driveModeChanges: 0,
                            autodriveTime: 0,
                        }),
                        (this.maxes = { duration: 0, distance: 0 }),
                        (this.cumulatives = {
                            totalVisits: 0,
                            revisits: 0,
                            mobileVisits: 0,
                            returningPlayers: 0,
                            difficulty: { easy: 0, normal: 0, hard: 0 },
                            viewDistance: [],
                            detailLevel: [],
                            skinTimes: {},
                            driveModeTimes: {},
                            hourlyVisits: [],
                            browser: {},
                        }),
                        (this.activeSessions = {}),
                        (this.feedback = []),
                        (this.quarterlyActiveSessions = []),
                        (this.quarterlyCumulativeSessions = []),
                        (this.poorPerformance = []),
                        (this.pastSessions = []),
                        (this.upTime = 0),
                        (this.callbacks = {}),
                        (this.setConnected = () => {});
                    for (let e in xu) this.callbacks[e] = () => {};
                }
                initialise() {
                    this.connected ||
                        (console.log("yada yada"),
                        (this.socket = Object(Dh.a)(Rh)),
                        this.socket.on("connect", () => {
                            console.log("Got connect"), this.socket.emit("request-dash", window.location.hash.slice(1));
                        }),
                        this.socket.on("connect_error", () => {
                            this.setConnected(!1);
                        }),
                        this.socket.on("disconnect", () => {
                            this.setConnected(!1);
                        }),
                        this.socket.on("authenticated", (e) => {
                            console.log("Authenticated"), console.log(e), (this.connected = !0), this.setConnected(!0), this.parseData(e);
                        }),
                        this.socket.on("dash-update", (e) => {
                            this.parseData(e);
                        }));
                }
                parseData(e) {
                    for (let t in e)
                        "dashSessionCount" !== t &&
                            "dashSessions" !== t &&
                            ((this[t] = e[t]), "averages" == t && ((e.averages.autodriveTime = vu(e.averages.autodriveTime)), (e.averages.duration = vu(e.averages.duration))), this.callbacks[t](this[t]));
                }
                addCallback(e, t) {
                    this.callbacks[e] = t;
                }
            })();
            function vu(e) {
                let t = e / 1e3,
                    i = t / 60;
                t %= 60;
                let s = i / 60;
                return (i %= 60), fu(Math.floor(s)) + ":" + fu(Math.floor(i)) + ":" + fu(Math.floor(t));
            }
            function fu(e) {
                return e < 10 ? "0" + e : "" + e;
            }
            Math.PI;
            const wu = { layer: 0, d: 0, h: 0, sq: 0, sqb: 0, wx: 0, wz: 0, ox: 0, oz: 0, px: 0, pz: 0, cell: null, ix: 0, iz: 0, depth: 0 };
            new r.D({ vertexColors: !0 }),
                new r.Q({
                    uniforms: { groundCol: { value: new r.i(4473924) } },
                    vertexShader:
                        "\n  attribute float gradient;\n\n  varying vec4 col;\n\n  varying float height;\n  varying float vGradient;\n\n  void main() {\n    vec4 wPos = modelMatrix * vec4( position, 1.0 );\n\n    // col.x = 0.5;\n    // col.y = wPos.y / 1000.0; // Height range between black and white // doesn't get used\n    // col.z = 0.5;\n    // col.w = 1.0;\n\n    height = wPos.y / 200.0; // clamp between 0 and 1 if possible? choose something matched to scene, 200m max range\n\n    vGradient = gradient;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position.x, 0.0, position.z, 1.0 );\n  }\n",
                    fragmentShader:
                        "\n\nvarying vec4 col;\nvarying float height;\nvarying float vGradient;\n\nvoid main() {\n\n  float hh = mod(height * 200.0, 5.0); // mod is spacing between lines, height converted back to metres\n\n  // swap - and pos tan for whack art\n  // Use atan for more accurate version\n\n  float boundA = 0.1 + vGradient * 0.25;// + tan(vGradient);//*vGradient*0.25;\n\n  float addB = 0.1 + vGradient * 0.25;\n  float boundB = 5.0 - addB;\n\n  if(hh < boundA) {\n    if(hh < boundA * 0.6) {\n      hh = 0.0;\n    } else {\n      hh = (hh - boundA * 0.6) / (boundA * 0.4);\n    }\n  } else if(hh > boundB) {\n    if(hh > 5.0 - (addB * 0.4)) {\n      hh = 1.0 - (hh - (addB * 0.4)) / (addB * 0.6);\n    } else {\n      hh = 1.0;\n    }\n  } else {\n    hh = 1.0;\n  }\n\n  vec3 base = vec3(0.0, 0.0, 0.0);\n  // vec3 base = vec3(height);\n  vec3 topo = vec3(hh, hh, hh);\n\n  gl_FragColor = vec4(mix(base, topo, 1.0), 1.0);\n}\n\n",
                }),
                new r.a(16777215, 0.1),
                new r.s(16777215, 16777215, 0.2),
                new r.j(16777215, 0.6);
            var bu = (e) => {
                e &&
                    e instanceof Function &&
                    i
                        .e(3)
                        .then(i.bind(null, 58))
                        .then(({ getCLS: t, getFID: i, getFCP: s, getLCP: n, getTTFB: a }) => {
                            t(e), i(e), s(e), n(e), a(e);
                        });
            };
            o.a.render(Object(lc.jsx)(n.a.StrictMode, { children: Object(lc.jsx)(mu, {}) }), document.getElementById("root")), bu();
        },
    ],
    [[57, 1, 2]],
]);
